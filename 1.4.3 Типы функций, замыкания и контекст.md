# **1.4.3. Типы функций, замыкания и контекст**

> [Index](./0%20Index.md)
> || [1.4 Функции](./1.4%20Функции.md)

---

## |1| **Контекст (Context)**

Контекст `this` в JavaScript — это одна из самых сложных и важных тем для понимания. Значение `this` зависит от того, **как** и **где** функция была вызвана, а не от того, где она была объявлена. Давайте разберем эту тему подробно, рассмотрим примеры в различных типах функций, а также использование методов `bind`, `call` и `apply`.

---

### 1. **Что такое `this`?**

В JavaScript контекст (**context**) и область видимости (**scope**) — это разные концепции, которые важно понимать для работы с кодом.

Контекст `this` — это ключевое слово, которое ссылается на объект, и определяет, какой объект используется в данный момент, в контексте которого выполняется функция.

Значение `this` определяется в момент вызова функции и может меняться в зависимости от контекста, и зависит от того, как вызвана функция, а не от того, где она объявлена.

---

### 2. **Поведение `this` в различных типах функций**

#### a) **Глобальный контекст**

В глобальном контексте (вне функций) `this` ссылается на глобальный объект:

-   В браузере — это `window`.
-   В Node.js — это `global`.

```javascript
console.log(this); // В браузере: window, в Node.js: global
```

---

#### b) **В обычных функциях**

Контекст `this` в анонимных функциях ведет себя так же, как и в именованных функциях. Поведение `this` зависит от того, **как** и **где** функция была вызвана. Однако есть некоторые нюансы, которые важно учитывать при использовании анонимных функций. Давайте разберем это подробнее, сравнивая анонимные функции с именованными.

---

##### 1. **Поведение `this` в анонимных и именованных функциях**

a) **Общее поведение**

И в анонимных, и в именованных функциях значение `this` определяется контекстом вызова. Если функция вызывается как метод объекта, `this` ссылается на этот объект. Если функция вызывается без контекста, `this` ссылается на глобальный объект (в нестрогом режиме) или `undefined` (в строгом режиме).

**Пример 1: Функция как метод объекта**

```javascript
const obj = {
    name: 'Alice',
    greet: function () {
        console.log(`Привет, меня зовут ${this.name}`);
    },
};

obj.greet(); // Привет, меня зовут Alice
```

Здесь:

-   Анонимная функция вызывается как метод объекта `obj`.
-   `this` ссылается на `obj`.

Если бы мы использовали именованную функцию, поведение было бы таким же:

```javascript
const obj = {
    name: 'Alice',
    greet: function greet() {
        console.log(`Привет, меня зовут ${this.name}`);
    },
};

obj.greet(); // Привет, меня зовут Alice
```

**Пример 2: Функция без контекста**

```javascript
const greet = function () {
    console.log(`Привет, меня зовут ${this.name}`);
};

greet(); // Привет, меня зовут undefined (в строгом режиме) или window.name (в нестрогом режиме)
```

Здесь:

-   Анонимная функция вызывается без контекста.
-   В строгом режиме (`'use strict'`) `this` равно `undefined`.
-   В нестрогом режиме `this` ссылается на глобальный объект (`window` в браузере или `global` в Node.js).

Если бы мы использовали именованную функцию, поведение было бы таким же:

```javascript
function greet() {
    console.log(`Привет, меня зовут ${this.name}`);
}

greet(); // Привет, меня зовут undefined (в строгом режиме) или window.name (в нестрогом режиме)
```

---

b) **Различия в отладке**

Одно из ключевых различий между анонимными и именованными функциями — это удобство отладки. Именованные функции легче идентифицировать в стеке вызовов, так как они имеют имя. Анонимные функции, напротив, отображаются как `anonymous` в стеке вызовов, что может затруднить отладку.

**Пример:**

```javascript
// Анонимная функция
setTimeout(function() {
    throw new Error('Ошибка в анонимной функции');
}, 1000);

// Именованная функция
setTimeout function timeoutHandler() {
    throw new Error('Ошибка в именованной функции');
}, 1000);
```

В стеке вызовов:

-   Анонимная функция будет отображена как `anonymous`.
-   Именованная функция будет отображена как `timeoutHandler`.

---

##### 2. **Примеры использования `this` в анонимных и именованных функциях**

a) **Анонимные функции как колбэки**

Анонимные функции часто используются как колбэки. В этом случае значение `this` зависит от того, как вызывается колбэк.

**Пример с `setTimeout`:**

```javascript
const obj = {
    name: 'Charlie',
    greet: function () {
        setTimeout(function () {
            console.log(`Привет, меня зовут ${this.name}`);
        }, 1000);
    },
};

obj.greet(); // Привет, меня зовут undefined
```

Почему `this.name` равно `undefined`?

-   Анонимная функция внутри `setTimeout` вызывается без контекста.
-   В строгом режиме `this` равно `undefined`, в нестрогом — глобальный объект.

Если бы мы использовали именованную функцию, поведение было бы таким же:

```javascript
const obj = {
    name: 'Charlie',
    greet: function () {
        setTimeout(function timeoutCallback() {
            console.log(`Привет, меня зовут ${this.name}`);
        }, 1000);
    },
};

obj.greet(); // Привет, меня зовут undefined
```

---

b) **Анонимные функции в методах объектов**

Если анонимная функция используется как метод объекта, `this` ссылается на этот объект.

**Пример:**

```javascript
const obj = {
    name: 'David',
    greet: function () {
        console.log(`Привет, меня зовут ${this.name}`);
    },
};

obj.greet(); // Привет, меня зовут David
```

Если бы мы использовали именованную функцию, поведение было бы таким же:

```javascript
const obj = {
    name: 'David',
    greet: function greet() {
        console.log(`Привет, меня зовут ${this.name}`);
    },
};

obj.greet(); // Привет, меня зовут David
```

---

c) **Анонимные функции в обработчиках событий**

В обработчиках событий `this` ссылается на элемент, на котором произошло событие.

**Пример:**

```html
<button id="myButton">Нажми меня</button>
<script>
    document.getElementById('myButton').addEventListener('click', function () {
        console.log(this); // <button id="myButton">Нажми меня</button>
    });
</script>
```

Если бы мы использовали именованную функцию, поведение было бы таким же:

```html
<button id="myButton">Нажми меня</button>
<script>
    document
        .getElementById('myButton')
        .addEventListener('click', function handleClick() {
            console.log(this); // <button id="myButton">Нажми меня</button>
        });
</script>
```

---

##### 3. **Итог**

-   В **анонимных и именованных функциях** значение `this` определяется контекстом вызова:
    -   Если функция вызывается как метод объекта, `this` ссылается на этот объект.
    -   Если функция вызывается без контекста, `this` ссылается на глобальный объект или `undefined`.
-   **Анонимные функции** удобны для краткости, но их сложнее отлаживать, так как они не имеют имени.
-   **Именованные функции** легче отлаживать, так как их имя отображается в стеке вызовов.
-   В остальном поведение `this` в анонимных и именованных функциях идентично.

---

#### c) **В стрелочных функциях**

Стрелочные функции (**arrow functions**) были введены в ES6 (ECMAScript 2015). Они отличаются от обычных функций не только синтаксисом, но и поведением ключевого слова `this`. Основное отличие заключается в том, что стрелочные функции **не имеют своего собственного `this`**. Вместо этого они **захватывают значение `this` из окружающего лексического контекста** (то есть из области видимости, в которой они были объявлены).

---

##### Почему это важно?

В обычных функциях значение `this` определяется в момент вызова функции и может меняться в зависимости от контекста. Это часто приводит к путанице, особенно когда функция передается как callback или используется в методах объектов.

Стрелочные функции решают эту проблему, так как их `this` всегда остается таким же, как и в окружающем контексте.

---

##### Пример 1: Сравнение обычной функции и стрелочной функции

**Обычная функция:**

```javascript
const obj = {
    name: 'Alice',
    greet: function () {
        setTimeout(function () {
            console.log(`Привет, меня зовут ${this.name}`);
        }, 1000);
    },
};

obj.greet(); // Привет, меня зовут undefined
```

Почему `this.name` равно `undefined`?

-   Внутри `setTimeout` используется обычная функция, и её `this` ссылается на глобальный объект (`window` в браузере или `global` в Node.js), а не на `obj`.
-   У глобального объекта нет свойства `name`, поэтому `this.name` равно `undefined`.

**Стрелочная функция:**

```javascript
const obj = {
    name: 'Alice',
    greet: function () {
        setTimeout(() => {
            console.log(`Привет, меня зовут ${this.name}`);
        }, 1000);
    },
};

obj.greet(); // Привет, меня зовут Alice
```

Почему теперь `this.name` равно `Alice`?

-   Стрелочная функция не имеет своего `this`, поэтому она берет `this` из окружающего контекста, то есть из функции `greet`.
-   Внутри `greet` значение `this` равно `obj`, поэтому `this.name` равно `Alice`.

---

##### Пример 2: Стрелочная функция как метод объекта

Если стрелочная функция используется как метод объекта, она **не привязывает `this` к этому объекту**. Вместо этого она захватывает `this` из окружающего контекста.

```javascript
const obj = {
    name: 'Bob',
    greet: () => {
        console.log(`Привет, меня зовут ${this.name}`);
    },
};

obj.greet(); // Привет, меня зовут undefined
```

Почему `this.name` равно `undefined`?

-   Стрелочная функция захватывает `this` из глобального контекста (так как она объявлена в глобальной области видимости).
-   В глобальном контексте `this` ссылается на глобальный объект (`window` или `global`), у которого нет свойства `name`.

---

##### Пример 3: Стрелочная функция внутри метода объекта

Если стрелочная функция используется внутри метода объекта, она захватывает `this` из этого метода.

```javascript
const obj = {
    name: 'Charlie',
    greet: function () {
        const innerFunc = () => {
            console.log(`Привет, меня зовут ${this.name}`);
        };
        innerFunc();
    },
};

obj.greet(); // Привет, меня зовут Charlie
```

Почему `this.name` равно `Charlie`?

-   Стрелочная функция `innerFunc` захватывает `this` из функции `greet`.
-   Внутри `greet` значение `this` равно `obj`, поэтому `this.name` равно `Charlie`.

---

##### Пример 4: Стрелочная функция и конструкторы

Стрелочные функции **не могут быть использованы как конструкторы**. Если попытаться вызвать стрелочную функцию с `new`, это вызовет ошибку.

```javascript
const Person = (name) => {
    this.name = name; // Ошибка: стрелочная функция не может быть конструктором
};

const alice = new Person('Alice'); // TypeError: Person is not a constructor
```

---

##### Пример 5: Стрелочная функция и методы `call`, `apply`, `bind`

Поскольку стрелочные функции не имеют своего `this`, методы `call`, `apply` и `bind` **не могут изменить их контекст**.

```javascript
const obj = {
    name: 'David',
};

const greet = () => {
    console.log(`Привет, меня зовут ${this.name}`);
};

greet.call(obj); // Привет, меня зовут undefined
```

Почему `this.name` равно `undefined`?

-   Стрелочная функция захватывает `this` из глобального контекста, и `call` не может изменить это поведение.

---

##### Итог по стрелочным функциям

-   **Стрелочные функции не имеют своего `this`.** Они захватывают `this` из окружающего лексического контекста.
-   **Используйте стрелочные функции, когда нужно сохранить контекст `this`.** Например, в колбэках или внутри методов объектов.
-   **Не используйте стрелочные функции как методы объектов**, если вам нужно, чтобы `this` ссылался на объект.
-   **Стрелочные функции нельзя использовать как конструкторы.**

---

#### d) **В методах объектов**

Когда функция вызывается как метод объекта, `this` ссылается на этот объект.

**Пример:**

```javascript
const obj = {
    name: 'Bob',
    sayName: function () {
        console.log(this.name);
    },
};

obj.sayName(); // Bob (this === obj)
```

---

#### e) **В конструкторах**

Когда функция используется как конструктор (с ключевым словом `new`), `this` ссылается на новый созданный объект.

**Пример:**

```javascript
function Person(name) {
    this.name = name;
}

const alice = new Person('Alice');
console.log(alice.name); // Alice (this === alice)
```

---

#### f) **В обработчиках событий**

В обработчиках событий `this` ссылается на элемент, на котором произошло событие.

**Пример:**

```html
<button id="myButton">Нажми меня</button>
<script>
    document.getElementById('myButton').addEventListener('click', function () {
        console.log(this); // <button id="myButton">Нажми меня</button>
    });
</script>
```

---

#### g) **В функциях IIFE**

IIFE (Immediately Invoked Function Expression) — это функция, которая выполняется сразу после своего объявления. В JavaScript IIFE часто используются для создания изолированных областей видимости и предотвращения загрязнения глобального пространства имен.

---

##### 1. **Что такое IIFE?**

IIFE — это функция, которая объявляется и сразу же вызывается. Синтаксис IIFE выглядит следующим образом:

```javascript
(function () {
    console.log('Это IIFE');
})();
```

Здесь:

-   Функция заключена в круглые скобки `(function() { ... })`.
-   После объявления она сразу вызывается с помощью `()`.

---

##### 2. **Контекст `this` в IIFE**

Поведение `this` в IIFE зависит от того, как и где вызывается функция. Рассмотрим основные случаи.

---

a) **IIFE в глобальном контексте**

Если IIFE вызывается в глобальном контексте (вне других функций или объектов), то `this` внутри IIFE будет ссылаться на глобальный объект:

-   В браузере — это `window`.
-   В Node.js — это `global`.

**Пример:**

```javascript
(function () {
    console.log(this); // В браузере: window, в Node.js: global
})();
```

---

b) **IIFE в строгом режиме**

Если включен строгий режим (`'use strict'`), то `this` внутри IIFE будет равно `undefined`.

**Пример:**

```javascript
'use strict';

(function () {
    console.log(this); // undefined
})();
```

---

c) **IIFE внутри метода объекта**

Если IIFE вызывается внутри метода объекта, то `this` внутри IIFE будет зависеть от контекста вызова. Однако, поскольку IIFE вызывается сразу, она не наследует контекст `this` из окружающего метода.

**Пример:**

```javascript
const obj = {
    name: 'Alice',
    greet: function () {
        (function () {
            console.log(`Привет, меня зовут ${this.name}`);
        })();
    },
};

obj.greet(); // Привет, меня зовут undefined
```

Почему `this.name` равно `undefined`?

-   IIFE вызывается без контекста, поэтому `this` ссылается на глобальный объект или `undefined` (в строгом режиме).
-   У глобального объекта нет свойства `name`, поэтому `this.name` равно `undefined`.

---

d) **Использование `this` из внешнего контекста**

Если нужно использовать `this` из внешнего контекста внутри IIFE, его можно передать как аргумент.

**Пример:**

```javascript
const obj = {
    name: 'Bob',
    greet: function () {
        (function (self) {
            console.log(`Привет, меня зовут ${self.name}`);
        })(this);
    },
};

obj.greet(); // Привет, меня зовут Bob
```

Здесь:

-   `this` из метода `greet` передается в IIFE как аргумент `self`.
-   Внутри IIFE `self` ссылается на объект `obj`.

---

##### 3. **Итог**

-   В **глобальном контексте** `this` внутри IIFE ссылается на глобальный объект (`window` в браузере или `global` в Node.js).
-   В **строгом режиме** `this` внутри IIFE равно `undefined`.
-   Если IIFE вызывается внутри метода объекта, она **не наследует контекст `this`** из этого метода. Для передачи контекста можно использовать аргументы.
-   IIFE часто используются для создания изолированных областей видимости, где значение `this` может быть явно передано или установлено.

Примеры использования `this` в IIFE:

```javascript
// Глобальный контекст
(function () {
    console.log(this); // window или global
})();

// Строгий режим
(function () {
    'use strict';
    console.log(this); // undefined
})();

// Передача контекста
const obj = {
    name: 'Charlie',
    greet: function () {
        (function (self) {
            console.log(`Привет, меня зовут ${self.name}`);
        })(this);
    },
};

obj.greet(); // Привет, меня зовут Charlie
```

---

### 3. **Методы для управления `this`: `bind`, `call`, `apply`**

Эти методы позволяют явно указать значение `this` при вызове функции.

#### a) **`bind`**

Метод `bind` создает новую функцию с привязанным значением `this`. Привязанная функция может быть вызвана позже.

**Пример:**

```javascript
const obj = {
    name: 'Alice',
};

function greet() {
    console.log(`Привет, меня зовут ${this.name}`);
}

const boundGreet = greet.bind(obj); // Привязываем this к obj
boundGreet(); // Привет, меня зовут Alice
```

---

#### b) **`call`**

Метод `call` вызывает функцию с указанным значением `this` и аргументами, переданными по отдельности.

**Пример:**

```javascript
const obj = {
    name: 'Bob',
};

function greet(greeting) {
    console.log(`${greeting}, меня зовут ${this.name}`);
}

greet.call(obj, 'Привет'); // Привет, меня зовут Bob
```

---

#### c) **`apply`**

Метод `apply` похож на `call`, но аргументы передаются в виде массива.

**Пример:**

```javascript
const obj = {
    name: 'Charlie',
};

function greet(greeting, punctuation) {
    console.log(`${greeting}, меня зовут ${this.name}${punctuation}`);
}

greet.apply(obj, ['Привет', '!']); // Привет, меня зовут Charlie!
```

> [!NOTE]
>
> Стрелочные функции не могут изменить значение `this` с помощью `call`, `apply` или `bind`. Их `this` всегда остается таким же, как и в окружающем контексте.
>
> **Пример:**
>
> ```js
> const greet = () => {
>     console.log(`Привет, меня зовут ${this.name}`);
> };
>
> const obj = { name: 'Alice' };
> greet.call(obj); // Привет, меня зовут undefined (this берется из глобального контекста)
> ```

---

### 4. **Итог**

-   **`this`** — это контекст выполнения функции, который определяется в момент вызова.
-   В **обычных функциях** `this` зависит от контекста вызова.
-   В **стрелочных функциях** `this` берется из окружающего контекста.
-   Методы **`bind`**, **`call`** и **`apply`** позволяют явно управлять значением `this`.

Понимание контекста `this` и умение управлять им — ключевой навык для работы с JavaScript.

---

### **Ключевые различия Scope vs Context**

| **Параметр**       | **Область видимости (Scope)**                             | **Контекст (Context)**                                 |
| ------------------ | --------------------------------------------------------- | ------------------------------------------------------ |
| **Зависимость**    | Определяется на этапе написания кода                      | Определяется на этапе выполнения кода                  |
| **Ключевое слово** | Управляется с помощью `var`, `let`, `const`               | Управляется с помощью `this`                           |
| **Фокус**          | Контроль доступа к переменным и функциям                  | Указывает на объект, от имени которого вызвана функция |
| **Пример**         | Видимость переменной в зависимости от её места объявления | Контекст функции внутри объекта                        |

---

### Пример для иллюстрации разницы

```javascript
let name = 'Global';

function showName() {
    console.log(this.name); // Контекст
}

let obj = {
    name: 'Object',
    showName,
};

showName(); // 'Global' (контекст — глобальный объект)
obj.showName(); // 'Object' (контекст — объект obj)
```

---

## |2| **Анонимные функции**

Анонимные функции — это функции, которые объявляются без имени. Они часто используются в JavaScript для выполнения задач, где имя функции не требуется, например, в качестве аргументов других функций (колбэков) или для создания самовызывающихся функций.

---

### 1. **Что такое анонимные функции?**

Анонимная функция — это функция, которая не имеет имени. В JavaScript функции могут быть именованными или анонимными. Именованные функции объявляются с помощью ключевого слова `function` и имеют имя, например:

```javascript
function namedFunction() {
    console.log('Это именованная функция');
}
```

Анонимная функция, напротив, не имеет имени:

```javascript
function() {
    console.log('Это анонимная функция');
}
```

Однако анонимная функция сама по себе не может существовать в коде, так как синтаксически это недопустимо. Она должна быть либо присвоена переменной, либо передана как аргумент, либо использована в качестве самовызывающейся функции.

---

### 2. **Примеры использования анонимных функций**

#### a) **Присваивание анонимной функции переменной**

Анонимную функцию можно присвоить переменной, после чего её можно вызывать по имени этой переменной.

```javascript
const greet = function () {
    console.log('Привет, мир!');
};

greet(); // Привет, мир!
```

Здесь:

-   Анонимная функция присваивается переменной `greet`.
-   После этого функцию можно вызвать как `greet()`.

---

#### b) **Анонимные функции как колбэки**

Анонимные функции часто используются как колбэки (функции, передаваемые в качестве аргументов другим функциям). Например, в методах массивов, таких как `forEach`, `map`, `filter`, или в обработчиках событий.

**Пример с `forEach`:**

```javascript
const numbers = [1, 2, 3];

numbers.forEach(function (number) {
    console.log(number * 2);
});
// Вывод:
// 2
// 4
// 6
```

Здесь:

-   Анонимная функция передается в `forEach` как аргумент.
-   Она выполняется для каждого элемента массива.

**Пример с обработчиком событий:**

```javascript
document.getElementById('myButton').addEventListener('click', function () {
    console.log('Кнопка нажата!');
});
```

Здесь:

-   Анонимная функция используется как обработчик события `click`.

---

#### c) **Самовызывающиеся функции (IIFE)**

Самовызывающиеся функции (Immediately Invoked Function Expressions, IIFE) — это анонимные функции, которые выполняются сразу после их объявления. Они используются для создания изолированных областей видимости.

**Пример:**

```javascript
(function () {
    const message = 'Это самовызывающаяся функция';
    console.log(message);
})();
// Вывод: Это самовызывающаяся функция
```

Здесь:

-   Анонимная функция заключена в круглые скобки `(function() { ... })`.
-   После объявления она сразу вызывается с помощью `()`.

---

#### d) **Анонимные функции в стрелочном синтаксисе**

Стрелочные функции также могут быть анонимными. Они часто используются для более короткого и удобного синтаксиса.

**Пример с `map`:**

```javascript
const numbers = [1, 2, 3];
const doubled = numbers.map((number) => number * 2);

console.log(doubled); // [2, 4, 6]
```

Здесь:

-   Анонимная стрелочная функция `(number) => number * 2` передается в `map`.

---

#### e) **Анонимные функции в возвращаемых значениях**

Анонимные функции могут возвращаться из других функций. Это полезно для создания замыканий (closures).

**Пример:**

```javascript
function createCounter() {
    let count = 0;
    return function () {
        count++;
        return count;
    };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3
```

Здесь:

-   Функция `createCounter` возвращает анонимную функцию.
-   Возвращаемая функция имеет доступ к переменной `count` благодаря замыканию.

---

### 3. **Преимущества анонимных функций**

1. **Краткость и удобство**:

    - Анонимные функции позволяют писать более компактный код, особенно в случаях, когда функция используется только один раз.

2. **Изоляция контекста**:

    - Самовызывающиеся функции (IIFE) создают изолированные области видимости, что помогает избежать конфликтов имен.

3. **Гибкость**:
    - Анонимные функции можно передавать как аргументы, возвращать из других функций и использовать в различных контекстах.

---

### 4. **Недостатки анонимных функций**

1. **Сложность отладки**:

    - Поскольку анонимные функции не имеют имен, их сложнее идентифицировать в стеке вызовов при отладке.

2. **Читаемость**:

    - Чрезмерное использование анонимных функций может ухудшить читаемость кода, особенно если они вложены друг в друга.

3. **Повторное использование**:
    - Анонимные функции нельзя вызвать повторно, если они не присвоены переменной или не переданы в другую функцию.

---

### 5. **Когда использовать анонимные функции?**

-   **Колбэки**: Когда функция используется только один раз, например, в методах массивов или обработчиках событий.
-   **IIFE**: Когда нужно создать изолированную область видимости.
-   **Замыкания**: Когда нужно сохранить состояние между вызовами функции.

---

### Итог

-   **Анонимные функции** — это функции без имени.
-   Они могут быть присвоены переменным, переданы как аргументы, использованы в IIFE или возвращены из других функций.
-   Анонимные функции полезны для создания краткого и гибкого кода, но их следует использовать с осторожностью, чтобы не ухудшить читаемость и поддерживаемость кода.

Примеры использования анонимных функций:

```javascript
// Присваивание переменной
const greet = function () {
    console.log('Привет!');
};

// Колбэк
setTimeout(function () {
    console.log('Прошло 1 секунда');
}, 1000);

// IIFE
(function () {
    console.log('Самовызывающаяся функция');
})();

// Стрелочная функция
const numbers = [1, 2, 3];
const doubled = numbers.map((num) => num * 2);
```

---

## |3| **Стрелочные функции**

Существует ещё один очень простой и лаконичный синтаксис для создания функций, который часто лучше, чем **Function Expression**.

Он называется **«функции-стрелки»** или **«стрелочные функции»** (arrow functions), т.к. выглядит следующим образом:

```js
let func = (arg1, arg2, ...argN) => expression;
```

Это создаёт функцию `func`, которая принимает аргументы `arg1..argN`, затем вычисляет `expression` в правой части с их использованием и возвращает результат.

Другими словами, это сокращённая версия:

```js
let func = function (arg1, arg2, ...argN) {
    return expression;
};
```

Давайте рассмотрим конкретный пример:

```js
let sum = (a, b) => a + b;

/* Эта стрелочная функция представляет собой более короткую форму:

let sum = function(a, b) {
return a + b;
};
*/

alert(sum(1, 2)); // 3
```

Как вы можете видеть, `(a, b) => a + b` задаёт функцию, которая принимает два аргумента с именами `a` и `b`. И при выполнении она вычисляет выражение `a + b` и возвращает результат.

Если у нас только один аргумент, то круглые скобки вокруг параметров можно опустить, сделав запись ещё короче:

```js
let double = (n) => n * 2;
// примерно тоже что и: let double = function(n) { return n * 2 }

alert(double(3)); // 6
```

Если аргументов нет, круглые скобки будут пустыми, но они должны присутствовать:

```js
let sayHi = () => alert('Hello!');

sayHi();
```

Стрелочные функции можно использовать так же, как и **Function Expression**.

Например, для динамического создания функции:

```js
let age = prompt('Сколько Вам лет?', 18);

let welcome = age < 18 ? () => alert('Привет!') : () => alert('Здравствуйте!');

welcome();
```

Поначалу стрелочные функции могут показаться необычными и даже трудночитаемыми, но это быстро пройдёт по мере того, как глаза привыкнут к этим конструкциям.

Они очень удобны для простых однострочных действий, когда лень писать много слов.

### **Многострочные стрелочные функции**

Стрелочные функции, которые мы видели до этого, были очень простыми. Они брали аргументы слева от `=>` и вычисляли и возвращали выражение справа.

Иногда нам нужна более сложная функция, с несколькими выражениями и инструкциями. Это также возможно, нужно лишь заключить их в фигурные скобки. При этом важное отличие – в том, что в таких скобках для возврата значения нужно использовать `return` (как в обычных функциях).

Вроде этого:

```js
let sum = (a, b) => {
    // фигурная скобка, открывающая тело многострочной функции
    let result = a + b;
    return result; // если мы используем фигурные скобки, то нам нужно явно указать "return"
};

alert(sum(1, 2)); // 3
```

Дальше – больше
Здесь мы представили главной целью стрелочных функций краткость. Но это ещё не всё!

Стрелочные функции обладают и другими интересными возможностями, о которых мы поговорим после изучения объектов.

А пока мы можем использовать их для простых однострочных действий и колбэков.

---

### **Итого**

Стрелочные функции очень удобны для простых действий, особенно для однострочных.

Они бывают двух типов:

1. Без фигурных скобок: `(...args) => expression` – правая сторона выражения: функция вычисляет его и возвращает результат. Скобки можно не ставить, если аргумент только один: `n => n * 2`.
2. С фигурными скобками: `(...args) => { body }` – скобки позволяют нам писать несколько инструкций внутри функции, но при этом необходимо явно вызывать `return`, чтобы вернуть значение.

#### **Основные различия с обычной функцией**

| Характеристика                     | Обычная функция                | Стрелочная функция                     |
| ---------------------------------- | ------------------------------ | -------------------------------------- |
| **Синтаксис**                      | Использует `function`          | Короткий синтаксис (`=>`)              |
| **Контекст `this`**                | Определяется контекстом вызова | Захватывается из окружающего контекста |
| **Аргументы `arguments`**          | Имеет доступ к `arguments`     | Не имеет своего `arguments`            |
| **Конструктор**                    | Может быть конструктором       | Не может быть конструктором            |
| **Методы `call`, `apply`, `bind`** | Может изменять `this`          | Не может изменять `this`               |

#### **Когда использовать стрелочные функции?**

-   Когда нужен короткий синтаксис.
-   Когда нужно сохранить контекст `this` из окружающей области видимости.
-   Когда функция используется как колбэк или в методах массивов (`map`, `filter`, `reduce` и т.д.).

#### **Когда использовать обычные функции?**

-   Когда нужен доступ к `arguments`.
-   Когда функция используется как конструктор.
-   Когда нужно явно управлять контекстом `this` с помощью `call`, `apply` или `bind`.

---

## |4| **Замыкания (Closures)**

Замыкания — это одна из самых мощных и важных концепций в JavaScript. Они позволяют функциям "запоминать" окружение, в котором они были созданы, даже после того, как это окружение вышло из области видимости.

---

### 1. **Что такое замыкание?**

**Замыкание (closure)** — это функция, которая запоминает своё лексическое окружение (lexical environment) в момент создания. Это окружение включает все переменные, которые были доступны в области видимости на момент создания функции.

Проще говоря, замыкание позволяет функции сохранять доступ к переменным из внешней функции, даже после того, как внешняя функция завершила своё выполнение.

---

### 2. **Определение и примеры**

#### a) **Простой пример замыкания**

Рассмотрим пример, где внутренняя функция "запоминает" переменную из внешней функции.

```javascript
function outer() {
    const outerVar = 'Я из внешней функции!';

    function inner() {
        console.log(outerVar); // Используем переменную из внешней функции
    }

    return inner;
}

const closureFunc = outer(); // Вызываем outer, она возвращает inner
closureFunc(); // Вывод: "Я из внешней функции!"
```

Здесь:

-   Функция `outer` создает переменную `outerVar` и возвращает функцию `inner`.
-   Функция `inner` "запоминает" переменную `outerVar` из окружения, в котором она была создана.
-   Даже после завершения выполнения `outer`, `inner` сохраняет доступ к `outerVar`.

---

#### b) **Практический пример: Счетчик**

Замыкания часто используются для создания функций с "состоянием". Например, счетчик:

```javascript
function createCounter() {
    let count = 0; // Переменная count "замыкается" внутри функции

    return function () {
        count++;
        return count;
    };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3
```

Здесь:

-   Функция `createCounter` возвращает анонимную функцию, которая увеличивает переменную `count`.
-   Переменная `count` "замыкается" внутри анонимной функции, и её значение сохраняется между вызовами.

---

### 3. **Карирование (Currying)**

Карирование — это функциональная техника, при которой функция с несколькими аргументами преобразуется в последовательность функций, каждая из которых принимает только один аргумент. Карирование позволяет создавать более гибкие и модульные функции, которые можно частично применять и комбинировать.

---

#### 1. **Что такое карирование?**

Карирование (currying) названо в честь математика Хаскелла Карри. Это процесс преобразования функции, которая принимает несколько аргументов, в последовательность функций, каждая из которых принимает только один аргумент.

**Пример:**

Рассмотрим функцию, которая складывает два числа:

```javascript
function add(a, b) {
    return a + b;
}

console.log(add(2, 3)); // 5
```

После карирования эта функция превращается в последовательность функций:

```javascript
function curriedAdd(a) {
    return function (b) {
        return a + b;
    };
}

const addTwo = curriedAdd(2); // Частичное применение: a = 2
console.log(addTwo(3)); // 5
```

Здесь:

-   Функция `curriedAdd` принимает первый аргумент `a` и возвращает функцию, которая принимает второй аргумент `b`.
-   Внутренняя функция "запоминает" значение `a` благодаря замыканию.

---

#### 2. **Преимущества карирования**

Карирование полезно в следующих случаях:

1. **Частичное применение функции**: Можно зафиксировать часть аргументов и создать новую функцию с оставшимися аргументами.
2. **Упрощение композиции функций**: Карированные функции легче комбинировать.
3. **Повышение читаемости и модульности**: Карирование позволяет разбивать сложные функции на более простые и понятные части.

---

#### 3. **Примеры карирования**

a) **Базовый пример**

Рассмотрим функцию, которая умножает три числа:

```javascript
function multiply(a, b, c) {
    return a * b * c;
}

console.log(multiply(2, 3, 4)); // 24
```

После карирования:

```javascript
function curriedMultiply(a) {
    return function (b) {
        return function (c) {
            return a * b * c;
        };
    };
}

console.log(curriedMultiply(2)(3)(4)); // 24
```

b) **Частичное применение**

Карирование позволяет зафиксировать часть аргументов и создать новую функцию:

```javascript
const multiplyByTwo = curriedMultiply(2); // Фиксируем a = 2
const multiplyByTwoAndThree = multiplyByTwo(3); // Фиксируем b = 3
console.log(multiplyByTwoAndThree(4)); // 24
```

---

#### 4. **Автоматическое карирование**

Вручную карировать функции с большим количеством аргументов может быть неудобно. Для автоматического карирования можно написать вспомогательную функцию.

**Пример:**

```javascript
function curry(fn) {
    return function curried(...args) {
        if (args.length >= fn.length) {
            return fn.apply(this, args);
        } else {
            return function (...moreArgs) {
                return curried.apply(this, args.concat(moreArgs));
            };
        }
    };
}

// Пример использования
function sum(a, b, c) {
    return a + b + c;
}

const curriedSum = curry(sum);
console.log(curriedSum(1)(2)(3)); // 6
console.log(curriedSum(1, 2)(3)); // 6
console.log(curriedSum(1)(2, 3)); // 6
```

Здесь:

-   Функция `curry` принимает функцию `fn` и возвращает карированную версию.
-   Если количество переданных аргументов достаточно, вызывается исходная функция.
-   Если аргументов недостаточно, возвращается новая функция, которая ожидает оставшиеся аргументы.

---

#### 5. **Карирование и замыкания**

Карирование тесно связано с замыканиями. Каждая функция в цепочке карирования "запоминает" свои аргументы благодаря замыканию.

**Пример:**

```javascript
function greet(greeting) {
    return function (name) {
        return `${greeting}, ${name}!`;
    };
}

const greetHello = greet('Привет');
console.log(greetHello('Алексей')); // Привет, Алексей!
console.log(greetHello('Мария')); // Привет, Мария!
```

Здесь:

-   Функция `greet` возвращает функцию, которая "запоминает" значение `greeting`.
-   Это позволяет создавать специализированные функции, такие как `greetHello`.

---

#### 6. **Практическое применение карирования**

a) **Создание специализированных функций**

Карирование позволяет создавать функции с предустановленными значениями.

```javascript
function createLogger(prefix) {
    return function (message) {
        console.log(`[${prefix}] ${message}`);
    };
}

const infoLogger = createLogger('INFO');
const errorLogger = createLogger('ERROR');

infoLogger('Запуск приложения'); // [INFO] Запуск приложения
errorLogger('Ошибка загрузки'); // [ERROR] Ошибка загрузки
```

b) **Работа с DOM**

Карирование можно использовать для создания обработчиков событий с предустановленными параметрами.

```html
<button id="button1">Кнопка 1</button>
<button id="button2">Кнопка 2</button>
<script>
    function createButtonHandler(buttonId) {
        return function () {
            console.log(`Нажата кнопка с ID: ${buttonId}`);
        };
    }

    const button1Handler = createButtonHandler('button1');
    const button2Handler = createButtonHandler('button2');

    document
        .getElementById('button1')
        .addEventListener('click', button1Handler);
    document
        .getElementById('button2')
        .addEventListener('click', button2Handler);
</script>
```

---

#### 7. **Итог**

-   **Карирование** — это преобразование функции с несколькими аргументами в последовательность функций с одним аргументом.
-   Карирование позволяет:
    -   Фиксировать часть аргументов (частичное применение).
    -   Создавать специализированные функции.
    -   Упрощать композицию функций.
-   Карирование тесно связано с замыканиями, так как каждая функция в цепочке "запоминает" свои аргументы.

**Примеры карирования:**

```javascript
// Ручное карирование
function add(a) {
    return function (b) {
        return a + b;
    };
}

const addFive = add(5);
console.log(addFive(10)); // 15

// Автоматическое карирование
function curry(fn) {
    return function curried(...args) {
        if (args.length >= fn.length) {
            return fn.apply(this, args);
        } else {
            return function (...moreArgs) {
                return curried.apply(this, args.concat(moreArgs));
            };
        }
    };
}

const curriedSum = curry((a, b, c) => a + b + c);
console.log(curriedSum(1)(2)(3)); // 6
```

---

### 4. **Использование замыканий**

Замыкания широко используются в JavaScript для решения различных задач. Рассмотрим несколько примеров.

#### a) **Создание приватных переменных**

Замыкания позволяют создавать приватные переменные, которые недоступны извне.

```javascript
function createPerson(name) {
    let age = 0; // Приватная переменная

    return {
        getName: function () {
            return name;
        },
        getAge: function () {
            return age;
        },
        incrementAge: function () {
            age++;
        },
    };
}

const person = createPerson('Алексей');
console.log(person.getName()); // Алексей
console.log(person.getAge()); // 0
person.incrementAge();
console.log(person.getAge()); // 1
```

Здесь:

-   Переменная `age` недоступна напрямую извне, но её можно изменить с помощью методов `incrementAge` и прочитать с помощью `getAge`.

---

#### b) **Обработка событий**

Замыкания часто используются в обработчиках событий для сохранения состояния.

```html
<button id="button1">Нажми меня</button>
<script>
    function setupButton(buttonId, message) {
        const button = document.getElementById(buttonId);
        button.addEventListener('click', function () {
            console.log(message); // Замыкание: message сохраняется
        });
    }

    setupButton('button1', 'Кнопка нажата!');
</script>
```

Здесь:

-   Функция `setupButton` создает обработчик события, который "запоминает" значение `message`.

---

#### c) **Мемоизация**

Замыкания можно использовать для мемоизации (кэширования результатов функции).

```javascript
function createMemoizedFunction(fn) {
    const cache = {}; // Кэш для хранения результатов

    return function (arg) {
        if (cache[arg] !== undefined) {
            return cache[arg];
        }
        const result = fn(arg);
        cache[arg] = result;
        return result;
    };
}

function expensiveCalculation(n) {
    console.log('Выполняется сложный расчет...');
    return n * 2;
}

const memoizedCalculation = createMemoizedFunction(expensiveCalculation);

console.log(memoizedCalculation(5)); // Выполняется сложный расчет... 10
console.log(memoizedCalculation(5)); // 10 (результат берется из кэша)
```

Здесь:

-   Функция `createMemoizedFunction` возвращает замыкание, которое кэширует результаты вызовов функции `fn`.

---

### 5. **Итог**

-   **Замыкание** — это функция, которая запоминает своё лексическое окружение.
-   Замыкания позволяют:
    -   Сохранять состояние между вызовами функции.
    -   Создавать приватные переменные.
    -   Реализовывать карирование и мемоизацию.
-   Замыкания широко используются в JavaScript для обработки событий, создания фабрик функций, управления состоянием и многого другого.

Примеры замыканий:

```javascript
// Простое замыкание
function outer() {
    const outerVar = 'Я из внешней функции!';
    return function () {
        console.log(outerVar);
    };
}

const closureFunc = outer();
closureFunc(); // "Я из внешней функции!"

// Карирование
function add(a) {
    return function (b) {
        return a + b;
    };
}

const addFive = add(5);
console.log(addFive(10)); // 15

// Приватные переменные
function createCounter() {
    let count = 0;
    return function () {
        count++;
        return count;
    };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
```

---

## |5| **IIFE: Immediately Invoked Function Expression**

**IIFE — Immediately Invoked Function Expression** (немедленно вызываемое функциональное выражение) — это функция, которая создается и сразу же вызывается.

> [!TIP]
>
> Немедленно вызываемое функциональное выражение (`IIFE`) в JavaScript можно рассматривать как синтаксический сахар для создания и немедленного выполнения функции. Оно обеспечивает удобный способ создания изолированного контекста выполнения, предотвращая утечку переменных в глобальную область видимости.
> Можно сказать, что `IIFE` предоставляет более удобный и лаконичный способ написания кода для немедленного выполнения функций и изоляции их контекста, что делает код более чистым и понятным. В этом смысле, да, это своего рода синтаксический сахар, поскольку упрощает решение распространенных задач в JavaScript.

---

### **Синтаксис IIFE**

```javascript
(function () {
    // Код внутри IIFE
})();

// Или:

(() => {
    // Код внутри IIFE
})();
```

Это тип выражений, также известный как **Self-Executing Anonymous Function**, который состоит из двух основных частей.

-   **Круглые скобки** вокруг функции превращают её в **функциональное выражение**. Это сама анонимная функция с лексической областью видимости, заключённым внутри Оператора группировки `()`. Благодаря этому переменные `IIFE` замыкаются в его пределах, и глобальная область видимости ими не засоряется.
-   После этого функция сразу вызывается с помощью `()`, благодаря которому JavaScript-движок выполняет функцию напрямую.

---

### **Зачем используются IIFE**

`IIFE` часто используются для инкапсуляции переменных и предотвращения конфликтов имен. Это особенно полезно в случаях, когда требуется создать временные переменные или выполнить однократную инициализацию.

Конструкция `(.....)();` используется для непосредственного вызова функции или немедленного выполнения анонимной функции. С помощью этой конструкции можно объявить и выполнить функцию сразу же в месте ее объявления. Обеспечивает изоляцию переменных и инициализацию кода. Это мощный инструмент для написания чистого и безопасного кода.

1. **Изоляция области видимости.**
   `IIFE` создают собственную область видимости, изолируя переменные внутри функции и предотвращая их утечку в глобальную область видимости. Это полезно для предотвращения конфликтов имен переменных.
2. **Избежание конфликтов имен.**
   Полезно при написании кода, где несколько частей программы используют одинаковые переменные.
3. **Инициализация кода.**
   Позволяет выполнить какую-то логику сразу после загрузки файла. `IIFE` часто используются для начальной настройки или инициализации кода, которая должна быть выполнена один раз при загрузке скрипта.

**Пример использования**

```javascript
(function () {
    console.log('Hello, world!');
})(); // Вывод: Hello, world!
```

---

### Как это работает?

1. **Функциональное выражение**:
   Внутри скобок `(.....)` объявляется функция. Это может быть анонимная функция или функциональное выражение, которое не сохраняется в переменную.

2. **Вызов функции**:
   После закрывающей скобки функции следуют еще одни скобки `()`, которые вызывают только что объявленную функцию.

---

### **Преимущества IIFE**

1. **Изоляция области видимости.** Переменные внутри не "засоряют" глобальное пространство имен.
2. **Безопасность.** Защищает приватные данные от внешнего вмешательства.
3. **Инициализация.** Полезна для выполнения одноразовых операций.
4. **Инкапсуляция** `IIFE` позволяют инкапсулировать код и скрывать детали реализации, что улучшает модульность и безопасность кода.
5. **Использование параметров** В `IIFE` можно передавать параметры для настройки выполнения функции.

---

### **Недостатки IIFE**

1. **Сложность чтения.** Для новичков код может быть менее очевиден.
2. **Ограничение масштабируемости.** При большом количестве зависимостей лучше использовать модули или классы.

---

### **Передача аргументов в IIFE**

IIFE позволяет передать параметры при вызове, как в обычную функцию. Это полезно для гибкости кода и работы с внешними данными внутри изолированного контекста.

#### **Синтаксис передачи аргументов в IIFE**

1. **Объявление функции IIFE и определение параметров:**

    ```javascript
    (function (param1, param2) {
        // Код, использующий параметры
    })(arg1, arg2);
    ```

2. **Что происходит:**
    - `param1` и `param2` — это параметры функции, объявленные внутри IIFE.
    - `arg1` и `arg2` — это значения, переданные при вызове IIFE.

#### **Примеры передачи аргументов**

**1. Использование входных данных**

```javascript
(function (name, age) {
    console.log(`Привет, ${name}! Тебе ${age} лет.`);
})('Алиса', 25);

// Вывод: Привет, Алиса! Тебе 25 лет.
```

**2. Передача значений из глобальной области видимости**

```javascript
const userName = 'Боб';
const userAge = 30;

(function (name, age) {
    console.log(`Привет, ${name}! Тебе ${age} лет.`);
})(userName, userAge);

// Вывод: Привет, Боб! Тебе 30 лет.
```

```javascript
const user = 'Alice';

(function (name) {
    console.log(`Привет, ${name}`);
})(user); // Привет, Alice
```

**3. Передача результата функции**

```javascript
(function (sum) {
    console.log(`Результат: ${sum}`);
})(5 + 3);

// Вывод: Результат: 8
```

**4. Передача текущей даты**

```javascript
(function (date) {
    console.log(`Сегодняшняя дата: ${date.toDateString()}`);
})(new Date());

// Вывод: Сегодняшняя дата: (например, Sat Dec 21 2024)
```

**5. Модификация переданного аргумента**

```javascript
(function (message) {
    console.log(message.toUpperCase());
})('hello, world');

// Вывод: HELLO, WORLD
```

```javascript
var name = 'World';

(function (greeting) {
    console.log(greeting + ', ' + name + '!');
})('Hello'); // Вывод: Hello, World!
```

#### **Преимущества передачи аргументов в IIFE**

1. **Универсальность.**
   Позволяет адаптировать код к разным сценариям без изменений внутри функции.
2. **Изоляция данных.**
   Передаваемые данные остаются доступными только внутри IIFE, что предотвращает их изменение снаружи.

3. **Использование внешних значений.**
   IIFE может работать с переменными из глобальной области или другого контекста.

#### **Реальные примеры использования**

**1. Работа с глобальными объектами**

Передача глобального объекта, чтобы минимизировать доступ к `window`:

```javascript
(function (global) {
    global.myLibrary = global.myLibrary || {};
    global.myLibrary.sayHello = function (name) {
        console.log(`Привет, ${name}!`);
    };
})(window);

myLibrary.sayHello('Алиса'); // Привет, Алиса!
```

**2. Инициализация настроек**

Передача настроек в виде объекта:

```javascript
const settings = { theme: 'dark', language: 'ru' };

(function (config) {
    console.log(`Тема: ${config.theme}, Язык: ${config.language}`);
})(settings);

// Вывод: Тема: dark, Язык: ru
```

**3. Ускорение вычислений**

Выполнение вычислений сразу при передаче данных:

```javascript
(function (a, b) {
    console.log(`Сумма: ${a + b}`);
})(10, 20);

// Вывод: Сумма: 30
```

#### **Когда передача аргументов в IIFE полезна**

1. **Обработка внешних данных.**
   Вы можете передавать аргументы вместо их жесткого кодирования.
2. **Глобальная изоляция.**
   Вы избегаете загрязнения глобального пространства имен.
3. **Сокращение кода.**
   Передача данных упрощает логику и делает её более читаемой.

---

### Примеры использования

#### **1. Простая изоляция области видимости**

```javascript
(function () {
    const secret = 'IIFE';
    console.log(`Это секретное сообщение: ${secret}`);
})();

// console.log(secret); // Ошибка: secret не определена
```

---

#### **2. Избежание конфликтов переменных**

```javascript
const counter = 100;

(function () {
    const counter = 0;
    console.log(`Внутренний счетчик: ${counter}`);
})();

console.log(`Глобальный счетчик: ${counter}`);
```

```javascript
var globalVar = "I'm global";

(function () {
    var localVar = "I'm local";
    console.log(globalVar); // Вывод: I'm global
    console.log(localVar); // Вывод: I'm local
})();

console.log(globalVar); // Вывод: I'm global
console.log(localVar); // Ошибка: localVar is not defined
```

---

#### **3. Присвоение в переменную**

Переменная, которой присвоено `IIFE`, хранит в себе результат выполнения функции, но не саму функцию.

```js
var result = (function () {
    var name = 'Barry';
    return name;
})();
// Immediately creates the output:
result; // "Barry"
```

---

#### **4. Создание модулей**

```javascript
const Module = (function () {
    let privateVar = 'Секрет';

    function privateMethod() {
        return `Доступ к ${privateVar}`;
    }

    return {
        setPrivateVar: function (newValue) {
            privateVar = newValue;
        },
        publicMethod: function () {
            return privateMethod();
        },
    };
})();

console.log(Module.publicMethod()); // Доступ к Секрет
Module.setPrivateVar('Новый Секрет');
console.log(Module.publicMethod()); // Доступ к Новый Секрет
// console.log(Module.privateVar); // Ошибка: privateVar не доступен
```

---

#### **5. Немедленная инициализация**

```javascript
(() => {
    const today = new Date();
    console.log(`Сегодня: ${today.toDateString()}`);
})();
```

#### **6. Использование объекта**

```javascript
const actions = {
    1: () => console.log('Понедельник'),
    2: () => console.log('Вторник'),
    3: () => console.log('Среда'),
    default: () => console.log('Неизвестный день'),
};

const day = 3;
(actions[day] || actions.default)();
```

---

## |6| **Функции-конструкторы**

Функции-конструкторы — это специальные функции в JavaScript, которые используются для создания и инициализации объектов. Они играют ключевую роль в объектно-ориентированном программировании (ООП) в JavaScript, особенно до появления классов в ES6. Давайте разберем эту тему подробно.

---

### 1. **Что такое функция-конструктор?**

Функция-конструктор — это обычная функция, которая используется с оператором `new` для создания объектов. По соглашению, имя функции-конструктора пишется с заглавной буквы, чтобы отличать её от обычных функций.

**Пример:**

```javascript
function Person(name, age) {
    this.name = name;
    this.age = age;
}

const person1 = new Person('Алексей', 30);
console.log(person1); // { name: 'Алексей', age: 30 }
```

Здесь:

-   `Person` — это функция-конструктор.
-   При вызове `new Person('Алексей', 30)` создается новый объект, и `this` внутри функции ссылается на этот объект.
-   Свойства `name` и `age` добавляются к новому объекту.

---

### 2. **Как работает `new`?**

Когда функция вызывается с оператором `new`, происходит следующее:

1. Создается новый пустой объект.
2. Свойство `this` внутри функции ссылается на этот новый объект.
3. Выполняется тело функции (обычно добавляются свойства и методы к объекту).
4. Если функция не возвращает явно другой объект, возвращается созданный объект.

**Пример:**

```javascript
function Car(brand, model) {
    this.brand = brand;
    this.model = model;
}

const car1 = new Car('Toyota', 'Corolla');
console.log(car1); // { brand: 'Toyota', model: 'Corolla' }
```

---

### 3. **Добавление методов**

Методы можно добавлять к объекту через `this` внутри функции-конструктора.

**Пример:**

```javascript
function Person(name, age) {
    this.name = name;
    this.age = age;

    this.greet = function () {
        console.log(`Привет, меня зовут ${this.name}, мне ${this.age} лет.`);
    };
}

const person1 = new Person('Мария', 25);
person1.greet(); // Привет, меня зовут Мария, мне 25 лет.
```

---

### 4. **Прототипы и методы**

Добавление методов внутри функции-конструктора имеет недостаток: каждый объект будет иметь свою копию метода, что может привести к избыточному использованию памяти. Чтобы избежать этого, методы добавляются в прототип функции-конструктора.

**Пример:**

```javascript
function Person(name, age) {
    this.name = name;
    this.age = age;
}

// Добавляем метод в прототип
Person.prototype.greet = function () {
    console.log(`Привет, меня зовут ${this.name}, мне ${this.age} лет.`);
};

const person1 = new Person('Иван', 30);
person1.greet(); // Привет, меня зовут Иван, мне 30 лет.
```

Здесь:

-   Метод `greet` добавляется в прототип `Person`, поэтому все объекты, созданные с помощью `new Person`, будут использовать один и тот же метод.

---

### 5. **Наследование через прототипы**

Функции-конструкторы позволяют реализовать наследование через прототипы. Дочерний конструктор может наследовать свойства и методы родительского конструктора.

**Пример:**

```javascript
// Родительский конструктор
function Animal(name) {
    this.name = name;
}

Animal.prototype.speak = function () {
    console.log(`${this.name} издает звук.`);
};

// Дочерний конструктор
function Dog(name, breed) {
    Animal.call(this, name); // Вызов родительского конструктора
    this.breed = breed;
}

// Наследование прототипа
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

Dog.prototype.bark = function () {
    console.log(`${this.name} лает: Гав-гав!`);
};

const dog1 = new Dog('Бобик', 'Дворняжка');
dog1.speak(); // Бобик издает звук.
dog1.bark(); // Бобик лает: Гав-гав!
```

Здесь:

-   `Dog` наследует свойства и методы `Animal`.
-   `Object.create(Animal.prototype)` создает новый объект с прототипом `Animal.prototype`.
-   `Dog.prototype.constructor = Dog` исправляет конструктор, чтобы он указывал на `Dog`.

---

### 6. **Проверка типа объекта**

Для проверки, был ли объект создан с помощью определенного конструктора, можно использовать оператор `instanceof`.

**Пример:**

```javascript
console.log(dog1 instanceof Dog); // true
console.log(dog1 instanceof Animal); // true
console.log(dog1 instanceof Object); // true
```

---

### 7. **Статические методы и свойства**

Статические методы и свойства принадлежат самой функции-конструктору, а не её экземплярам. Они полезны для реализации функциональности, которая не зависит от конкретного объекта.

**Пример:**

```javascript
function Person(name, age) {
    this.name = name;
    this.age = age;
}

// Статическое свойство
Person.species = 'Homo sapiens';

// Статический метод
Person.compareAges = function (person1, person2) {
    return person1.age - person2.age;
};

const person1 = new Person('Алексей', 30);
const person2 = new Person('Мария', 25);

console.log(Person.species); // Homo sapiens
console.log(Person.compareAges(person1, person2)); // 5 (Алексей старше Марии на 5 лет)
```

---

### 8. **Ограничения функций-конструкторов**

-   **Сложность с наследованием**: Наследование через прототипы может быть сложным для понимания.
-   **Отсутствие приватных свойств**: Все свойства и методы, добавленные через `this`, являются публичными.
-   **Путаница с `this`**: Если функция-конструктор вызывается без `new`, `this` будет ссылаться на глобальный объект (в нестрогом режиме) или `undefined` (в строгом режиме).

---

### 9. **Классы (ES6)**

С появлением классов в ES6 функции-конструкторы стали менее популярными, так как классы предоставляют более удобный и понятный синтаксис для создания объектов и работы с наследованием.

**Пример с классом:**

```javascript
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    greet() {
        console.log(`Привет, меня зовут ${this.name}, мне ${this.age} лет.`);
    }
}

const person1 = new Person('Алексей', 30);
person1.greet(); // Привет, меня зовут Алексей, мне 30 лет.
```

---

### 10. **Итог**

-   **Функции-конструкторы** — это функции, которые используются с оператором `new` для создания объектов.
-   Они позволяют добавлять свойства и методы через `this` и прототипы.
-   Наследование реализуется через прототипы.
-   С появлением классов в ES6 функции-конструкторы стали менее популярными, но они всё ещё важны для понимания основ JavaScript.

Пример функции-конструктора:

```javascript
function Car(brand, model) {
    this.brand = brand;
    this.model = model;
}

Car.prototype.displayInfo = function () {
    console.log(`Марка: ${this.brand}, Модель: ${this.model}`);
};

const car1 = new Car('Toyota', 'Corolla');
car1.displayInfo(); // Марка: Toyota, Модель: Corolla
```

---

## **Задачи**

### **Анонимные функции**

#### **Задача 1: Фильтрация списка**

Дан список чисел. Используя анонимные функции и функцию `filter`, оставьте в списке только те числа, которые делятся на 3.

```javascript
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
// Результат: [3, 6, 9]
```

#### **Задача 2: Возведение в степень**

Напишите анонимную функцию, которая принимает два аргумента: число и степень. Используйте её для создания списка, где каждое число возводится в квадрат.

```javascript
numbers = [1, 2, 3, 4, 5];
// Результат: [1, 4, 9, 16, 25]
```

#### **Задача 3: Сортировка строк по длине**

Дан список строк. Используя анонимную функцию, отсортируйте его по длине строк.

```javascript
words = ['apple', 'banana', 'kiwi', 'cherry', 'plum'];
// Результат: ['kiwi', 'plum', 'apple', 'cherry', 'banana']
```

#### **Задача 4: Применение функции к каждому элементу**

Используя `map` и анонимную функцию, преобразуйте список чисел так, чтобы каждое число увеличивалось на 10%.

```javascript
numbers = [10, 20, 30, 40, 50];
// Результат: [11.0, 22.0, 33.0, 44.0, 55.0]
```

#### **Задача 5: Поиск максимума по ключу**

Дан список словарей, представляющих товары. Найдите товар с максимальной ценой, используя анонимную функцию.

```javascript
products = [
    { name: 'apple', price: 50 },
    { name: 'banana', price: 20 },
    { name: 'cherry', price: 75 },
    { name: 'plum', price: 60 },
];
// Результат: {'name': 'cherry', 'price': 75}
```

---

### **Стрелочные функции**

#### **Задача 1. Перепишите с использованием функции-стрелки**

Замените код Function Expression стрелочной функцией:

```js
function ask(question, yes, no) {
    if (confirm(question)) yes();
    else no();
}

ask(
    'Вы согласны?',
    function () {
        alert('Вы согласились.');
    },
    function () {
        alert('Вы отменили выполнение.');
    },
);
```

Вот 5 задач на стрелочные функции без использования методов `map`, `reduce`, `join` и других подобных методов:

#### **Задача 2. Вычисление квадрата числа**

Создайте стрелочную функцию, которая принимает число и возвращает его квадрат. Вызовите её для числа 7.

```javascript
// Ожидаемый результат: 49
```

#### **Задача 3. Проверка на простое число**

Создайте стрелочную функцию, которая принимает число и возвращает `true`, если это число простое, и `false` в противном случае.

```javascript
// Пример: isPrime(7) -> true, isPrime(8) -> false
```

#### **Задача 4. Сумма двух чисел**

Напишите стрелочную функцию, которая принимает два числа и возвращает их сумму. Проверьте её на примере чисел 10 и 15.

```javascript
// Ожидаемый результат: 25
```

#### **Задача 5. Определение чётности числа**

Создайте стрелочную функцию, которая принимает число и возвращает строку "Чётное" или "Нечётное" в зависимости от переданного значения.

```javascript
// Пример: checkEven(4) -> "Чётное", checkEven(7) -> "Нечётное"
```

#### **Задача 6. Вычисление факториала числа**

Напишите стрелочную функцию для вычисления факториала числа. Для числа 5 результат должен быть 120.

```javascript
// Пример: factorial(5) -> 120
```

#### **Задача 7. Проверка на кратность**

Используя стрелочную функцию и метод `filter`, оставьте из массива только числа, кратные 3.

```javascript
const numbers = [3, 7, 9, 12, 15, 22, 27];
// Результат: [3, 9, 12, 15, 27]
```

#### **Задача 8. Преобразование объектов**

Дан массив объектов с информацией о людях. Используя стрелочную функцию и метод `map`, создайте новый массив, содержащий только имена.

```javascript
const people = [
    { name: 'Alice', age: 25 },
    { name: 'Bob', age: 30 },
    { name: 'Charlie', age: 35 },
];
// Результат: ['Alice', 'Bob', 'Charlie']
```

#### **Задача 9. Проверка всех элементов**

Дан массив чисел. Используя стрелочную функцию и метод `every`, проверьте, все ли числа в массиве положительные.

```javascript
const numbers = [1, 2, 3, 4, 5, 6];
// Результат: true
```

#### **Задача 10. Подсчёт элементов, начинающихся с буквы**

Дан массив строк. Используя стрелочную функцию и метод `reduce`, посчитайте, сколько строк начинаются с буквы "a".

```javascript
const words = ['apple', 'banana', 'apricot', 'cherry', 'avocado', 'plum'];
// Результат: 3
```

#### **Задача 11. Создание строки из массива**

Используя стрелочную функцию и метод `join`, объедините массив строк в одну строку, где все слова разделены запятой.

```javascript
const words = ['JavaScript', 'is', 'awesome'];
// Результат: 'JavaScript,is,awesome'
```

---

### **Замыкания (Closures)**

#### **Задача 1. Карирование**

Создайте функцию `curry`, которая преобразует функцию с несколькими аргументами в функцию, которую можно вызывать по одному аргументу за раз.

**Пример использования:**

```javascript
function sum(a, b, c) {
    return a + b + c;
}

const curriedSum = curry(sum);
console.log(curriedSum(1)(2)(3)); // 6
```

---

#### **Задача 2. Замыкание для скрытия данных**

Реализуйте функцию `createSecretHolder(secret)`, которая возвращает объект с двумя методами:

1. `getSecret` — возвращает сохранённое значение.
2. `setSecret` — устанавливает новое значение.

**Пример использования:**

```javascript
const secretHolder = createSecretHolder(42);
console.log(secretHolder.getSecret()); // 42
secretHolder.setSecret(100);
console.log(secretHolder.getSecret()); // 100
```

---

#### **Задача 3. Использование замыканий в таймерах**

Напишите функцию `countdown(start)`, которая использует замыкание для отсчёта времени. Эта функция должна возвращать функцию, которая при вызове выводит текущее значение счётчика и уменьшает его на 1. Если счётчик достиг нуля, возвращаемая функция выводит сообщение "Время вышло!".

**Пример использования:**

```javascript
const timer = countdown(3);

timer(); // 3
timer(); // 2
timer(); // 1
timer(); // Время вышло!
```

---

#### **Задача 4. Замыкания для создания приватных методов**

Создайте функцию `createPerson(name)`, которая возвращает объект с двумя методами:

1. `getName` — возвращает имя.
2. `setName(newName)` — изменяет имя.

Имя должно храниться в приватной переменной, недоступной напрямую.

**Пример использования:**

```javascript
const person = createPerson('Alice');
console.log(person.getName()); // Alice
person.setName('Bob');
console.log(person.getName()); // Bob
```

---

#### **Задача 5. Инкремент с шагом**

Напишите функцию `createIncrementer(step)`, которая возвращает функцию. Возвращаемая функция увеличивает переданное ей число на значение `step`.

**Пример использования:**

```javascript
const incrementBy2 = createIncrementer(2);
const incrementBy5 = createIncrementer(5);

console.log(incrementBy2(10)); // 12
console.log(incrementBy5(10)); // 15
```

---

#### **Задача 6. Счетчик вызовов**

Реализуйте функцию `createCallTracker`, которая возвращает функцию. Эта функция, при каждом вызове, должна возвращать, сколько раз она уже была вызвана.

**Пример использования:**

```javascript
const tracker = createCallTracker();

console.log(tracker()); // 1
console.log(tracker()); // 2
console.log(tracker()); // 3
```

---

#### **Задача 7. Карирование для сложения**

Создайте функцию `curriedAdd`, которая позволяет добавлять числа по одному. Когда функция вызывается без аргументов, она возвращает сумму всех переданных чисел.

**Пример использования:**

```javascript
const add = curriedAdd();
console.log(add(1)(2)(3)()); // 6
console.log(add(10)(20)()); // 30
```

---

#### **Задача 8. Генератор диапазона**

Напишите функцию `rangeGenerator(start, end)`, которая возвращает замыкание. Замыкание должно выдавать числа из диапазона `[start, end]` при каждом вызове. Когда диапазон заканчивается, возвращается `undefined`.

**Пример использования:**

```javascript
const range = rangeGenerator(1, 3);

console.log(range()); // 1
console.log(range()); // 2
console.log(range()); // 3
console.log(range()); // undefined
```

---

#### **Задача 9. Математическое выражение**

Сделайте карированную функцию, которая отнимает от первого числа второе и делит на третье.

```js
console.log(countFunc(7, 1, 2));
console.log(countFunc(7)(1, 2));
console.log(countFunc(7)(1)(2));
console.log(countFunc(7, 1)(2));
```

---

#### **Задача 10. Проверка на кратность**

Сделайте функцию замыкание isEven() (even - это четный), которая сохраняет в замыкании парамтр кратности, а параметром принимает целое число и проверяет: кратное оно или нет.
Если кратное - пусть функция возвращает true, иначе - false.

```js
console.log(isEven(6));
```

---

### **IIFE: Immediately Invoked Function Expression**

#### **Задача 1. Определение IIFE**

Создайте IIFE, которая сразу выводит в консоль строку `"IIFE выполнена!"`.

**Пример результата:**

```javascript
// В консоли: "IIFE выполнена!"
```

---

#### **Задача 2. Локальные переменные в IIFE**

Напишите IIFE, в которой объявляется переменная `message` со значением `"Привет, мир!"`. Выведите эту переменную внутри IIFE в консоль. Убедитесь, что она недоступна за пределами IIFE.

**Пример результата:**

```javascript
// Внутри IIFE: "Привет, мир!"
// За пределами: ошибка, переменная не определена
```

---

#### **Задача 3. IIFE с параметрами**

Создайте IIFE, которая принимает два числа в качестве аргументов и возвращает их сумму. Выведите результат вызова в консоль.

**Пример результата:**

```javascript
// В консоли: 15 (если переданы 10 и 5)
```

---

#### **Задача 4. Ограничение области видимости**

Напишите IIFE, в которой создается объект с названием `"user"`, имеющий свойства `"name"` и `"age"`. Реализуйте методы `setName` и `getName`. Убедитесь, что объект недоступен вне IIFE.

**Пример результата:**

```javascript
// Внутри IIFE: объект с name и age
// За пределами: ошибка, объект не определен
```

---

#### **Задача 5. Немедленный вызов с функцией внутри**

Создайте IIFE, которая возвращает другую функцию. Эта функция должна выводить в консоль строку `"Функция изнутри IIFE"`.

**Пример использования:**

```javascript
const innerFunc = (function () {
    // Реализация внутри IIFE
})();

innerFunc(); // "Функция изнутри IIFE"
```

---

#### **Задача 6. Счетчик с помощью IIFE**

Напишите IIFE, которая создает счетчик. Счетчик должен быть реализован через замыкание и возвращать функции `increment` и `getCount`.

**Пример использования:**

```javascript
const counter = (function () {
    // Реализация внутри IIFE
})();

counter.increment(); // Увеличивает счетчик
console.log(counter.getCount()); // Выводит текущее значение счетчика
```

---

#### **Задача 7. Карирование с IIFE**

Реализуйте IIFE, которая возвращает функцию для карирования. Например, при вызове `curriedAdd(2)(3)` результатом будет `5`.

**Пример использования:**

```javascript
const curriedAdd = (function () {
    // Реализация внутри IIFE
})();

console.log(curriedAdd(2)(3)); // 5
```

---

#### **Задача 8. Немедленный вызов с модулем**

Создайте IIFE, которая реализует модуль для управления списком задач. Модуль должен иметь методы `addTask(task)`, `removeTask(index)` и `getTasks()`.

**Пример использования:**

```javascript
const taskModule = (function () {
    // Реализация модуля
})();

taskModule.addTask('Изучить IIFE');
console.log(taskModule.getTasks()); // ["Изучить IIFE"]
taskModule.removeTask(0);
console.log(taskModule.getTasks()); // []
```

---

#### **Задача 9. Генератор случайных чисел**

Создайте IIFE, которая возвращает функцию для генерации случайного числа между двумя заданными значениями `min` и `max`.

**Пример использования:**

```javascript
const randomGenerator = (function () {
    // Реализация внутри IIFE
})();

console.log(randomGenerator(1, 10)); // случайное число от 1 до 10
```

---

#### **Задача 10. Одноразовая настройка**

Напишите IIFE, которая выполняет одноразовую настройку приложения, выводя сообщение `"Настройка выполнена"` только один раз.

**Пример результата:**

```javascript
// В консоли: "Настройка выполнена"
```

#### **Задача 11. Проверка числа на четность**

Напишите IIFE, которое проверяет, является ли переданное число четным или нечетным.

#### **Задача 12. Добавить глобальный объект**

Используйте IIFE, чтобы безопасно добавить в глобальный объект `window` метод `logHello`, который выводит "Hello".

#### **Задача 13. Защита глобальной переменной**

Напишите IIFE, чтобы предотвратить изменение глобальной переменной:

```javascript
let data = 'Protected';
```

#### **Задача 14. Факториал числа**

Используйте IIFE для вычисления факториала числа. Передайте число в качестве аргумента в IIFE.

---

### **Функции-конструкторы**

#### **Задача 1. Создание простого объекта через функцию-конструктор**

Создайте функцию-конструктор `Person`, которая принимает два параметра: `name` и `age`. На основе этой функции создайте объект и выведите его свойства в консоль.

**Пример результата:**

```javascript
const person1 = new Person('Иван', 30);
console.log(person1.name); // "Иван"
console.log(person1.age); // 30
```

---

#### **Задача 2. Добавление метода в прототип**

Добавьте метод `greet` в прототип функции-конструктора `Person`, который выводит в консоль приветствие вида: `"Привет, меня зовут [name]!"`.

**Пример использования:**

```javascript
const person = new Person('Анна', 25);
person.greet(); // "Привет, меня зовут Анна!"
```

---

#### **Задача 3. Расширение функциональности**

Создайте функцию-конструктор `Rectangle`, которая принимает параметры `width` и `height`. Добавьте в прототип метод `getArea`, который вычисляет площадь прямоугольника.

**Пример использования:**

```javascript
const rect = new Rectangle(10, 5);
console.log(rect.getArea()); // 50
```

---

#### **Задача 4. Проверка свойства через `hasOwnProperty`**

Создайте объект через функцию-конструктор `Car` с параметрами `brand` и `model`. Проверьте, являются ли свойства `brand` и `model` собственными свойствами объекта.

**Пример результата:**

```javascript
const car = new Car('Toyota', 'Camry');
console.log(car.hasOwnProperty('brand')); // true
console.log(car.hasOwnProperty('toString')); // false
```

---

#### **Задача 5. Унаследование через прототипы**

Создайте функцию-конструктор `Animal` с методом `speak`, который выводит в консоль: `"Животное говорит"`. Создайте функцию-конструктор `Dog`, унаследуйте её от `Animal` и переопределите метод `speak` так, чтобы он выводил: `"Собака лает"`.

**Пример использования:**

```javascript
const dog = new Dog('Шарик');
dog.speak(); // "Собака лает"
```

---

#### **Задача 6. Создание статического метода**

Добавьте статический метод `createRandom` к функции-конструктору `User`, который создает объект `User` с произвольным именем и возрастом.

**Пример использования:**

```javascript
const randomUser = User.createRandom();
console.log(randomUser); // { name: 'СлучайноеИмя', age: 25 }
```

---

#### **Задача 7. Использование свойства `instanceof`**

Создайте два конструктора: `Circle` и `Square`. Создайте объекты через эти конструкторы и проверьте с помощью оператора `instanceof`, к какому типу они принадлежат.

**Пример использования:**

```javascript
const circle = new Circle(5);
console.log(circle instanceof Circle); // true
console.log(circle instanceof Square); // false
```

---

#### **Задача 8. Использование `call` внутри конструктора**

Создайте функцию-конструктор `Employee`, которая принимает `name` и `position`. Создайте другой конструктор `Manager`, который вызывает `Employee` с помощью метода `call` и добавляет дополнительное свойство `team`.

**Пример использования:**

```javascript
const manager = new Manager('Алексей', 'Руководитель', 'Команда A');
console.log(manager);
// { name: 'Алексей', position: 'Руководитель', team: 'Команда A' }
```

---

#### **Задача 9. Создание фабричной функции**

Напишите функцию `createUser`, которая возвращает объект, созданный через функцию-конструктор `User`, с переданными параметрами `name` и `age`.

**Пример использования:**

```javascript
const user = createUser('Мария', 20);
console.log(user); // { name: 'Мария', age: 20 }
```

---

#### **Задача 10. Инициализация объекта с уникальным ID**

Создайте функцию-конструктор `Item`, которая автоматически присваивает каждому создаваемому объекту уникальный идентификатор `id`. Для этого используйте статическое свойство конструктора.

**Пример использования:**

```javascript
const item1 = new Item('Стол');
const item2 = new Item('Стул');
console.log(item1.id); // 1
console.log(item2.id); // 2
```

---
