# **1.4.1 Введение в функции и объявление функций**

> [Index](./0%20Index.md)
> || [1.4 Функции](./1.4%20Функции.md)

## Что такое функция?

Функция — это блок кода, предназначенный для выполнения определенной задачи. Функции позволяют структурировать код, делать его более читаемым и многократно использовать один и тот же блок кода без необходимости его дублирования.

### Примеры использования функций:

-   Выполнение арифметических операций.
-   Работа с массивами и объектами.
-   Асинхронные операции, такие как запросы к серверу.

## Зачем использовать функции?

Функции упрощают поддержку и расширяемость кода. Вот некоторые причины, почему функции полезны:

-   **Повторное использование кода**: Один раз написав функцию, можно использовать ее многократно.
-   **Улучшение читаемости**: Функции помогают разделить код на логические блоки.
-   **Изоляция логики**: Функции изолируют логику и переменные, что снижает вероятность конфликтов имен.

## Объявление функций

Для создания функций мы можем использовать объявление функции.

Пример объявления функции:

```js
function showMessage() {
    alert('Всем привет!');
}
```

Вначале идёт ключевое слово `function`, после него имя функции, затем список параметров в круглых скобках через запятую (в вышеприведённом примере он пустой) и, наконец, код функции, также называемый «телом функции», внутри фигурных скобок.

```js
function имя(параметры) {
...тело...
}
```

Наша новая функция может быть вызвана по своему имени: `showMessage()`.

Например:

```js
function showMessage() {
    alert('Всем привет!');
}

showMessage();
showMessage();
```

Вызов `showMessage()` выполняет код функции. Здесь мы увидим сообщение дважды.

Этот пример явно демонстрирует одно из главных предназначений функций: избавление от дублирования кода.

Если понадобится поменять сообщение или способ его вывода – достаточно изменить его в одном месте: в функции, которая его выводит.

### Function Declaration (Декларация функции)

Это традиционный способ объявления функции в JavaScript. Функции, объявленные таким способом, поднимаются в начало своей области видимости (hoisting).

**Синтаксис:**

```javascript
function имяФункции(параметры) {
    // тело функции
    return результат;
}
```

**Пример:**

```javascript
function greet(name) {
    return `Привет, ${name}!`;
}

console.log(greet('Мир')); // Вывод: Привет, Мир!
```

### Function Expression (Функциональное выражение)

Функциональные выражения создают функцию в контексте другого выражения. Они не поднимаются (не имеют hoisting).

**Синтаксис:**

```javascript
const имяФункции = function (параметры) {
    // тело функции
    return результат;
};
```

**Пример:**

```javascript
const add = function (a, b) {
    return a + b;
};

console.log(add(2, 3)); // Вывод: 5
```

Поскольку создание функции происходит в контексте выражения присваивания (с правой стороны от `=`), это **Function Expression**.

Обратите внимание, что после ключевого слова `function` нет имени. Для **Function Expression** допускается его отсутствие.

В более сложных ситуациях, с которыми мы столкнёмся позже, функция может быть создана и немедленно вызвана, или запланирована для дальнейшего выполнения, нигде не сохраняясь, таким образом, оставаясь анонимной.

### **Функция – это значение**

Давайте повторим: независимо от того, как создаётся функция – она является значением.

Мы даже можем вывести это значение с помощью `alert`:

```js
function sayHi() {
    alert('Привет');
}

alert(sayHi); // выведет код функции
```

Обратите внимание, что последняя строка не вызывает функцию, потому что после `sayHi` нет круглых скобок. Существуют языки программирования, в которых любое упоминание имени функции приводит к её выполнению, но JavaScript к таким не относится.

В JavaScript функция – это значение, поэтому мы можем обращаться с ней как со значением. Приведённый выше код показывает её строковое представление, которое является её исходным кодом.

Конечно, функция – это особое значение, в том смысле, что мы можем вызвать её как `sayHi()`.

Но всё же это значение. Поэтому мы можем работать с ней так же, как и с другими видами значений.

Мы можем скопировать функцию в другую переменную:

```js
function sayHi() {
    // (1) создаём
    alert('Привет');
}

let func = sayHi; // (2) копируем

func(); // Привет // (3) вызываем копию (работает)!
sayHi(); // Привет // эта тоже все ещё работает (почему бы и нет)
```

Давайте подробно разберём всё, что тут произошло:

Объявление **Function Declaration** `(1)` создаёт функцию и помещает её в переменную с именем `sayHi`.
В строке `(2)` мы скопировали её значение в переменную `func`. Обратите внимание (ещё раз): нет круглых скобок после `sayHi`. Если бы они были, то выражение `func = sayHi()` записало бы результат вызова `sayHi()` в переменную `func`, а не саму функцию `sayHi`.
Теперь функция может вызываться как `sayHi()`, так и `func()`.
Мы также могли бы использовать **Function Expression** для объявления `sayHi` в первой строке:

```js
let sayHi = function () {
    // (1) создаём
    alert('Привет');
};

let func = sayHi;
// ...
```

Всё будет работать так же.

> [!NOTE]
>
> Зачем нужна точка с запятой в конце?
> У вас мог возникнуть вопрос: Почему в **Function Expression** ставится точка с запятой ; на конце, а в **Function Declaration** нет:
>
> ```js
> function sayHi() {
>     // ...
> }
>
> let sayHi = function () {
>     // ...
> };
> ```
>
> Ответ прост: **Function Expression** создаётся здесь как `function(...) {...}` внутри выражения присваивания: `let sayHi = …;`. Точку с запятой `;` рекомендуется ставить в конце выражения, она не является частью синтаксиса функции.
>
> Точка с запятой нужна там для более простого присваивания, такого как `let sayHi = 5;`, а также для присваивания функции.

### Различия между Function Declaration и Function Expression

Ключевые отличия **Function Declaration** от **Function Expression**.

Во-первых, синтаксис: как отличить их друг от друга в коде.

**Function Declaration**: функция объявляется отдельной конструкцией `«function…»` в основном потоке кода.

```js
// Function Declaration
function sum(a, b) {
    return a + b;
}
```

**Function Expression**: функция, созданная внутри другого выражения или синтаксической конструкции. В данном случае функция создаётся в правой части «выражения присваивания» `=`:

```js
// Function Expression
let sum = function (a, b) {
    return a + b;
};
```

Более тонкое отличие состоит в том, когда создаётся функция движком JavaScript.

**Function Expression** создаётся, когда выполнение доходит до него, и затем уже может использоваться.

После того, как поток выполнения достигнет правой части выражения присваивания `let sum = function…` – с этого момента, функция считается созданной и может быть использована (присвоена переменной, вызвана и т.д. ).

С **Function Declaration** всё иначе.

**Function Declaration** может быть вызвана раньше, чем она объявлена.

Другими словами, когда движок JavaScript готовится выполнять скрипт или блок кода, прежде всего он ищет в нём **Function Declaration** и создаёт все такие функции. Можно считать этот процесс «стадией инициализации».

И только после того, как все объявления **Function Declaration** будут обработаны, продолжится выполнение.

В результате функции, созданные как **Function Declaration**, могут быть вызваны раньше своих определений.

Например, так будет работать:

```js
sayHi('Вася'); // Привет, Вася

function sayHi(name) {
    alert(`Привет, ${name}`);
}
```

Функция `sayHi` была создана, когда движок JavaScript подготавливал скрипт к выполнению, и такая функция видна повсюду в этом скрипте.

…Если бы это было **Function Expression**, то такой код вызвал бы ошибку:

```js
sayHi('Вася'); // ошибка!

let sayHi = function (name) {
    // (*) магии больше нет
    alert(`Привет, ${name}`);
};
```

Функции, объявленные при помощи **Function Expression**, создаются тогда, когда выполнение доходит до них. Это случится только на строке, помеченной звёздочкой `(*)`. Слишком поздно.

Ещё одна важная особенность **Function Declaration** заключается в их блочной области видимости.

В строгом режиме, когда **Function Declaration** находится в блоке `{...}`, функция доступна везде внутри блока. Но не снаружи него.

Для примера давайте представим, что нам нужно объявить функцию `welcome()` в зависимости от значения переменной `age`, которое мы получим во время выполнения кода. И затем запланируем использовать её когда-нибудь в будущем.

Если мы попробуем использовать **Function Declaration**, это не заработает так, как задумывалось:

```js
let age = prompt('Сколько Вам лет?', 18);

// в зависимости от условия объявляем функцию
if (age < 18) {
    function welcome() {
        alert('Привет!');
    }
} else {
    function welcome() {
        alert('Здравствуйте!');
    }
}

// ...не работает
welcome(); // Error: welcome is not defined
```

Это произошло, так как объявление **Function Declaration** видимо только внутри блока кода, в котором располагается.

Вот ещё один пример:

```js
let age = 16; // возьмём для примера 16

if (age < 18) {
    welcome(); // \ (выполнится)
    // |
    function welcome() {
        // |
        alert('Привет!'); // | Function Declaration доступно
    } // | во всём блоке кода, в котором объявлено
    // |
    welcome(); // / (выполнится)
} else {
    function welcome() {
        alert('Здравствуйте!');
    }
}

// здесь фигурная скобка закрывается,
// поэтому Function Declaration, созданные внутри блока кода выше -- недоступны отсюда.

welcome(); // Ошибка: welcome is not defined
```

Что можно сделать, чтобы `welcome` была видима снаружи `if`?

Верным подходом будет воспользоваться функцией, объявленной при помощи **Function Expression**, и присвоить значение `welcome` переменной, объявленной снаружи `if`, что обеспечит нам нужную видимость.

Такой код заработает, как ожидалось:

```js
let age = prompt('Сколько Вам лет?', 18);

let welcome;

if (age < 18) {
    welcome = function () {
        alert('Привет!');
    };
} else {
    welcome = function () {
        alert('Здравствуйте!');
    };
}

welcome(); // теперь всё в порядке
```

Или мы могли бы упростить это ещё сильнее, используя условный оператор `?`:

```js
let age = prompt('Сколько Вам лет?', 18);

let welcome =
    age < 18
        ? function () {
              alert('Привет!');
          }
        : function () {
              alert('Здравствуйте!');
          };

welcome(); // теперь всё в порядке
```

> [!TIP]
>
> Когда использовать **Function Declaration**, а когда **Function Expression**?
>
> Как правило, если нам понадобилась функция, в первую очередь нужно рассматривать синтаксис **Function Declaration**, который мы использовали до этого. Он даёт нам больше свободы в том, как мы можем организовывать код. Функции, объявленные таким образом, можно вызывать до их объявления.
>
> Также функции вида `function f(…) {…}` чуть более заметны в коде, чем `let f = function(…) {…}`. **Function Declaration** легче «ловятся глазами».
>
> …Но если **Function Declaration** нам не подходит по какой-то причине, или нам нужно условное объявление (мы рассмотрели это в примере выше), то следует использовать **Function Expression**.

**Итого**
Основные отличия:

1. **Поднятие (hoisting)**: Function Declaration поднимаются в начало своей области видимости, а Function Expression — нет.
2. **Имя функции**: Function Declaration всегда имеют имя, а Function Expression могут быть анонимными.

---

## **Выбор имени функции**

Функция – это действие. Поэтому имя функции обычно является глаголом. Оно должно быть кратким, точным и описывать действие функции, чтобы программист, который будет читать код, получил верное представление о том, что делает функция.

Как правило, используются глагольные префиксы, обозначающие общий характер действия, после которых следует уточнение. Обычно в командах разработчиков действуют соглашения, касающиеся значений этих префиксов.

Например, функции, начинающиеся с `"show"` обычно что-то показывают.

Функции, начинающиеся с…

-   `"get…"` – возвращают значение,
-   `"calc…"` – что-то вычисляют,
-   `"create…"` – что-то создают,
-   `"check…"` – что-то проверяют и возвращают логическое значение, и т.д.

Примеры таких имён:

```js
showMessage(..) // показывает сообщение
getAge(..) // возвращает возраст (получая его каким-то образом)
calcSum(..) // вычисляет сумму и возвращает результат
createForm(..) // создаёт форму (и обычно возвращает её)
checkPermission(..) // проверяет доступ, возвращая true/false
```

Благодаря префиксам, при первом взгляде на имя функции становится понятным, что делает её код, и какое значение она может возвращать.

> [!TIP]
>
> Одна функция – одно действие
> Функция должна делать только то, что явно подразумевается её названием. И это должно быть одним действием.
>
> Два независимых действия обычно подразумевают две функции, даже если предполагается, что они будут вызываться вместе (в этом случае мы можем создать третью функцию, которая будет их вызывать).
>
> Несколько примеров, которые нарушают это правило:
>
> -   `getAge` – будет плохим выбором, если функция будет выводить `alert` с возрастом (должна только возвращать его).
> -   `createForm` – будет плохим выбором, если функция будет изменять документ, добавляя форму в него (должна только создавать форму и возвращать её).
> -   `checkPermission` – будет плохим выбором, если функция будет отображать сообщение с текстом доступ разрешён/запрещён (должна только выполнять проверку и возвращать её результат).
>
> В этих примерах использовались общепринятые смыслы префиксов. Конечно, вы в команде можете договориться о других значениях, но обычно они мало отличаются от общепринятых. В любом случае вы и ваша команда должны чётко понимать, что значит префикс, что функция с ним может делать, а чего не может.

> [!TIP]
>
> Сверхкороткие имена функций
> Имена функций, которые используются очень часто, иногда делают сверхкороткими.
>
> Например, фреймворк `jQuery` определяет функцию с помощью `$`. В библиотеке `Lodash` основная функция представлена именем `_`.
>
> Это исключения. В основном имена функций должны быть в меру краткими и описательными.

---

## **Функции == Комментарии**

Функции должны быть короткими и делать только что-то одно. Если это что-то большое, имеет смысл разбить функцию на несколько меньших. Иногда следовать этому правилу непросто, но это определённо хорошее правило.

Небольшие функции не только облегчают тестирование и отладку – само существование таких функций выполняет роль хороших комментариев!

Например, сравним ниже две функции `showPrimes(n)`. Каждая из них выводит простое число до `n`.

Первый вариант использует метку `nextPrime`:

```js
function showPrimes(n) {
    nextPrime: for (let i = 2; i < n; i++) {
        for (let j = 2; j < i; j++) {
            if (i % j == 0) continue nextPrime;
        }

        alert(i); // простое
    }
}
```

Второй вариант использует дополнительную функцию `isPrime(n)` для проверки на простое:

```js
function showPrimes(n) {
    for (let i = 2; i < n; i++) {
        if (!isPrime(i)) continue;

        alert(i); // простое
    }
}

function isPrime(n) {
    for (let i = 2; i < n; i++) {
        if (n % i == 0) return false;
    }
    return true;
}
```

Второй вариант легче для понимания, не правда ли? Вместо куска кода мы видим название действия (`isPrime`). Иногда разработчики называют такой код **самодокументируемым**.

Таким образом, допустимо создавать функции, даже если мы не планируем повторно использовать их. Такие функции структурируют код и делают его более понятным.

---

## Область видимости для функции

### **Внешние переменные**

У функции есть доступ к внешним переменным, например:

```js
let userName = 'Вася';

function showMessage() {
    let message = 'Привет, ' + userName;
    alert(message);
}

showMessage(); // Привет, Вася
```

Функция обладает полным доступом к внешним переменным и может изменять их значение.

Например:

```js
let userName = 'Вася';

function showMessage() {
    userName = 'Петя'; // (1) изменяем значение внешней переменной

    let message = 'Привет, ' + userName;
    alert(message);
}

alert(userName); // Вася перед вызовом функции

showMessage();

alert(userName); // Петя, значение внешней переменной было изменено функцией
```

Внешняя переменная используется, только если внутри функции нет такой локальной.

Если одноимённая переменная объявляется внутри функции, тогда она перекрывает внешнюю. Например, в коде ниже функция использует локальную переменную `userName`. Внешняя будет проигнорирована:

```js
let userName = 'Вася';

function showMessage() {
    let userName = 'Петя'; // объявляем локальную переменную

    let message = 'Привет, ' + userName; // Петя
    alert(message);
}

// функция создаст и будет использовать свою собственную локальную переменную userName
showMessage();

alert(userName); // Вася, не изменилась, функция не трогала внешнюю переменную
```

> [!TIP]
>
> **Глобальные переменные**
>
> Переменные, объявленные снаружи всех функций, такие как внешняя переменная `userName` в вышеприведённом коде – называются глобальными.
>
> Глобальные переменные видимы для любой функции (если только их не перекрывают одноимённые локальные переменные).
>
> Желательно сводить использование глобальных переменных к минимуму. В современном коде обычно мало или совсем нет глобальных переменных. Хотя они иногда полезны для хранения важнейших «общепроектовых» данных.

## Примеры реального использования в коде

### Пример 1: Функция для проверки четности числа

```javascript
// Декларация функции
function isEven(number) {
    return number % 2 === 0;
}

console.log(isEven(4)); // Вывод: true
console.log(isEven(5)); // Вывод: false
```

### Пример 2: Функция для вычисления факториала числа

```javascript
// Функциональное выражение
const factorial = function (n) {
    if (n === 0) {
        return 1;
    }
    return n * factorial(n - 1);
};

console.log(factorial(5)); // Вывод: 120
console.log(factorial(0)); // Вывод: 1
```

### Пример 3: Функция для обработки данных пользователей

```javascript
// Декларация функции
function processUserData(users) {
    users.forEach((user) => {
        console.log(`Имя: ${user.name}, Возраст: ${user.age}`);
    });
}

const users = [
    { name: 'John', age: 30 },
    { name: 'Jane', age: 25 },
];

processUserData(users);
// Вывод:
// Имя: John, Возраст: 30
// Имя: Jane, Возраст: 25
```

### Пример 4: Функция для конкатенации строк

```javascript
// Функциональное выражение
const concatenateStrings = function (str1, str2) {
    return str1 + ' ' + str2;
};

console.log(concatenateStrings('Hello', 'World')); // Вывод: Hello World
```

---

## **Задачи**

1. **Приветствие пользователя**
   Напишите функцию `greet`, которая принимает один параметр `name` и выводит строку "Привет, `name`!".

```javascript
function greet(name) {}

greet('Алексей');
```

2. **Сложение двух чисел**
   Напишите функцию `add`, которая принимает два параметра `a` и `b` и возвращает их сумму.

```javascript
function add(a, b) {}

console.log(add(3, 7)); // Вывод: 10
```

3. **Проверка на четность**
   Напишите функцию `isEven`, которая принимает один параметр `number` и возвращает `true`, если число четное, и `false` в противном случае.

```javascript
function isEven(number) {}

console.log(isEven(4)); // Вывод: true
console.log(isEven(7)); // Вывод: false
```

4. **Факториал числа**
   Напишите функцию `factorial`, которая принимает один параметр `n` и возвращает факториал числа `n`.

```javascript
function factorial(n) {}

console.log(factorial(5)); // Вывод: 120
```

5. **Конкатенация строк**
   Напишите функцию `concatenate`, которая принимает два параметра `str1` и `str2` и возвращает их конкатенацию.

```javascript
function concatenate(str1, str2) {}

console.log(concatenate('Hello', 'World')); // Вывод: Hello World
```

6. **Найти максимум**
   Напишите функцию `findMax`, которая принимает массив чисел и возвращает наибольшее число в массиве.

```javascript
function findMax(numbers) {}

console.log(findMax([1, 5, 3, 9, 2])); // Вывод: 9
```

7. **Поиск подстроки**
   Напишите функцию `containsSubstring`, которая принимает две строки `str` и `substr` и возвращает `true`, если `substr` содержится в `str`, и `false` в противном случае.

```javascript
function containsSubstring(str, substr) {}

console.log(containsSubstring('Hello World', 'World')); // Вывод: true
console.log(containsSubstring('Hello World', 'world')); // Вывод: false
```

8. **Подсчет количества символов**
   Напишите функцию `countCharacters`, которая принимает строку `str` и возвращает объект, содержащий количество каждого символа в строке.

```javascript
function countCharacters(str) {}

console.log(countCharacters('hello')); // Вывод: { h: 1, e: 1, l: 2, o: 1 }
```

9. **Проверка палиндрома**
   Напишите функцию `isPalindrome`, которая принимает строку `str` и возвращает `true`, если строка является палиндромом, и `false` в противном случае.

```javascript
function isPalindrome(str) {}

console.log(isPalindrome('racecar')); // Вывод: true
console.log(isPalindrome('hello')); // Вывод: false
```

10. **Подсчет слов в строке**
    Напишите функцию `countWords`, которая принимает строку `str` и возвращает количество слов в строке.

```javascript
function countWords(str) {}

console.log(countWords('Hello world! How are you?')); // Вывод: 5
```

11. **Обязателен ли "else"?**
    Следующая функция возвращает `true`, если параметр `age` больше `18`.

В ином случае она запрашивает подтверждение через `confirm` и возвращает его результат:

```js
function checkAge(age) {
    if (age > 18) {
        return true;
    } else {
        // ...
        return confirm('Родители разрешили?');
    }
}
```

Будет ли эта функция работать как-то иначе, если убрать `else`?

```js
function checkAge(age) {
    if (age > 18) {
        return true;
    }
    // ...
    return confirm('Родители разрешили?');
}
```

Есть ли хоть одно отличие в поведении этого варианта?

12. **Перепишите функцию, используя оператор '?' или '||'**
    Следующая функция возвращает `true`, если параметр `age` больше `18`.

В ином случае она задаёт вопрос `confirm` и возвращает его результат.

```js
function checkAge(age) {
    if (age > 18) {
        return true;
    } else {
        return confirm('Родители разрешили?');
    }
}
```

Перепишите функцию, чтобы она делала то же самое, но без `if`, в одну строку.

Сделайте два варианта функции `checkAge`:

Используя оператор `?`
Используя оператор `||`

13. **Функция min(a, b)**
    Напишите функцию `min(a,b)`, которая возвращает меньшее из чисел `a` и `b`.

Пример вызовов:

```js
min(2, 5) == 2;
min(3, -1) == -1;
min(1, 1) == 1;
```

14. **Функция pow(x,n)**
    Напишите функцию `pow(x,n)`, которая возводит `x` в степень `n` и возвращает результат.

```js

pow(3, 2) = 3 _ 3 = 9
pow(3, 3) = 3 _ 3 _ 3 = 27
pow(1, 100) = 1 _ 1 _ ..._ 1 = 1
```

Создайте страницу, которая запрашивает `x` и `n`, а затем выводит результат `pow(x,n)`.

P.S. В этой задаче функция обязана поддерживать только натуральные значения `n`, т.е. целые от `1` и выше.
