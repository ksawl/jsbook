# **2.2. Переменные и типы данных**

> [Home](../readme.md)
> || [A1](./0%20Index.md)

---

## |1| **Синтаксис**

### 1. **Инструкции**

Инструкции – это синтаксические конструкции и команды, которые выполняют действия. В коде может быть столько инструкций, сколько мы захотим. Инструкции могут отделяться точкой с запятой.

Например, здесь мы разделили сообщение «Привет Мир» на два вызова alert:

```plaintext
alert('Привет'); alert('Мир');
```

Обычно каждую инструкцию пишут на новой строке, чтобы код было легче читать:

```js
alert('Привет');
alert('Мир');
```

### 2. **Точка с запятой**

В большинстве случаев точку с запятой можно не ставить, если есть переход на новую строку.

Так тоже будет работать:

```
alert('Привет')
alert('Мир')
```

В этом случае JavaScript интерпретирует перенос строки как «неявную» точку с запятой. Это называется автоматическая вставка точки с запятой.

В большинстве случаев новая строка подразумевает точку с запятой. Но «в большинстве случаев» не значит «всегда»!

В некоторых ситуациях новая строка всё же не означает точку с запятой. Например:

```
alert(3 +
1

- 2);
```

Код выведет 6, потому что JavaScript не вставляет здесь точку с запятой. Интуитивно очевидно, что, если строка заканчивается знаком "+", значит, это «незавершённое выражение», поэтому точка с запятой не требуется. И в этом случае всё работает, как задумано.

Но есть ситуации, где JavaScript «забывает» вставить точку с запятой там, где она нужна и ошибки, которые при этом появляются, достаточно сложно обнаруживать и исправлять.

> [!TIP]
>
> **Пример ошибки**
>
> Если вы хотите увидеть конкретный пример такой ошибки, обратите внимание на этот код:
>
> ```js
> alert('Hello');
>
> [1, 2].forEach(alert);
> ```
>
> Пока нет необходимости знать значение скобок `[]` и `forEach`. Мы изучим их позже. Пока что просто запомните результат выполнения этого кода: выводится Hello, затем 1, затем 2.
>
> А теперь давайте уберем точку с запятой после alert:
>
> ```
> alert('Hello')
>
> [1, 2].forEach(alert);
> ```
>
> Этот код отличается от кода, приведенного выше, только в одном: пропала точка с запятой в конце первой строки.
>
> Если мы запустим этот код, выведется только первый `alert`, а затем мы получим ошибку (вам может потребоваться открыть консоль, чтобы увидеть её)!
>
> Это потому что JavaScript не вставляет точку с запятой перед квадратными скобками `[...]`. И поэтому код в последнем примере выполняется, как одна инструкция.
>
> Вот как движок видит его:
>
> ```js
> alert('Hello')[(1, 2)].forEach(alert);
> ```
>
> Выглядит странно, правда? Такое слияние в данном случае неправильное. Мы должны поставить точку с запятой после `alert`, чтобы код работал правильно.
>
> Это может произойти и в некоторых других ситуациях.

Рекомендуется ставить точку с запятой между инструкциями, даже если они отделены переносами строк. Это правило широко используется в сообществе разработчиков. Стоит отметить ещё раз – в большинстве случаев можно не ставить точку с запятой. Но безопаснее, особенно для новичка, ставить её.

### 3. **Комментарии**

Со временем программы становятся всё сложнее и сложнее. Возникает необходимость добавлять комментарии, которые бы описывали, что делает код и почему.

Комментарии могут находиться в любом месте скрипта. Они не влияют на его выполнение, поскольку движок просто игнорирует их.

Однострочные комментарии начинаются с двойной косой черты `//`.

Часть строки после `//` считается комментарием. Такой комментарий может как занимать строку целиком, так и находиться после инструкции.

Как здесь:

```js
// Этот комментарий занимает всю строку
alert('Привет');

alert('Мир'); // Этот комментарий следует за инструкцией
```

Многострочные комментарии начинаются косой чертой со звёздочкой `/*` и заканчиваются звёздочкой с косой чертой `*/`.

Как вот здесь:

```js
/* Пример с двумя сообщениями.
Это - многострочный комментарий.
*/
alert('Привет');
alert('Мир');
```

Содержимое комментария игнорируется, поэтому, если мы поместим код внутри `/* … */`, он не будет исполняться.

Это бывает удобно для временного отключения участка кода:

```js
/* Закомментировали код
alert('Привет');
*/
alert('Мир');
```

> [!TIP]
>
> **Используйте горячие клавиши!**
>
> В большинстве редакторов строку кода можно закомментировать, нажав комбинацию клавиш `Ctrl+/` для однострочного комментария и что-то вроде `Ctrl+Shift+/` – для многострочных комментариев (выделите кусок кода и нажмите комбинацию клавиш). В системе Mac попробуйте Cmd вместо Ctrl и Option вместо Shift.

> [!WARNING]
>
> **Вложенные комментарии не поддерживаются!**
>
> Не может быть `/*...*/` внутри `/*...*/`.
>
> Такой код «умрёт» с ошибкой:
>
> ```js
> /*
> /* вложенный комментарий ?!? */
> */
> alert( 'Мир' );
> ```

Не стесняйтесь использовать комментарии в своём коде.

Комментарии увеличивают размер кода, но это не проблема. Есть множество инструментов, которые минифицируют код перед публикацией на рабочий сервер. Они убирают комментарии, так что они не содержатся в рабочих скриптах. Таким образом, комментарии никоим образом не вредят рабочему коду.

### 4. **Синтаксический сахар**

**Синтаксический сахар (syntactic sugar)** — это элемент синтаксиса языка программирования, который упрощает запись кода и делает его более понятным для человека, при этом не добавляя новых возможностей или функционала. Он существует исключительно для удобства разработчиков, улучшая читаемость и сокращая объем кода.

> [!NOTE]
>
> **Особенности синтаксического сахара**
>
> -   Не добавляет новой логики или функциональности.
> -   Упрощает и делает код более лаконичным.
> -   Часто используется для сокращения шаблонного кода.
> -   За кулисами преобразуется в более базовую форму во время компиляции или интерпретации.

#### **4.1. Тернарный оператор**

Тернарный оператор (`? :`) — синтаксический сахар для условных операторов `if...else`.

**Код без синтаксического сахара:**

```javascript
let result;
if (x > 10) {
    result = 'Больше 10';
} else {
    result = 'Меньше или равно 10';
}
```

**Код с синтаксическим сахаром:**

```javascript
let result = x > 10 ? 'Больше 10' : 'Меньше или равно 10';
```

#### **4.2. Стрелочные функции (arrow functions)**

В JavaScript стрелочные функции — это синтаксический сахар для сокращения записи анонимных функций.

**Без стрелочных функций:**

```javascript
const add = function (a, b) {
    return a + b;
};
```

**С использованием стрелочных функций:**

```javascript
const add = (a, b) => a + b;
```

#### **4.3. Деструктуризация**

Деструктуризация позволяет извлекать значения из объектов или массивов более компактно.

**Без деструктуризации:**

```javascript
const person = { name: 'Alice', age: 25 };
const name = person.name;
const age = person.age;
```

**С деструктуризацией:**

```javascript
const { name, age } = person;
```

#### **4.4. Шаблонные строки**

Шаблонные строки — это сахар для объединения строк с помощью конкатенации.

**Без шаблонных строк:**

```javascript
const name = 'Alice';
const greeting = 'Привет, ' + name + '!';
```

**С использованием шаблонных строк:**

```javascript
const greeting = `Привет, ${name}!`;
```

#### **4.5. Операторы `??` и `?.`**

Оператор **нулевого слияния (`??`)** и **опциональная цепочка (`?.`)** упрощают проверку на `null` или `undefined`.

**Без синтаксического сахара:**

```javascript
let value = obj && obj.prop ? obj.prop : 'default';
```

**С использованием `?.` и `??`:**

```javascript
let value = obj?.prop ?? 'default';
```

> [!NOTE]
>
> **Преимущества синтаксического сахара**
>
> 1.  **Читаемость**: Код становится проще для понимания.
> 2.  **Сокращение кода**: Уменьшается количество строк и повторяющихся шаблонов.
> 3.  **Меньше ошибок**: Благодаря упрощению конструкции снижается вероятность допустить ошибку.

> [!WARNING]
>
> **Недостатки синтаксического сахара**
>
> 1.  **Скрытая сложность**: Если не знать, как сахар работает под капотом, можно столкнуться с непредсказуемым поведением.
> 2.  **Учебная нагрузка**: Новичкам иногда сложнее понять код, насыщенный синтаксическим сахаром.
> 3.  **Сложность отладки**: После трансформации (например, через Babel) отладка может стать менее интуитивной.

> [!IMPORTANT]
>
> **Заключение**
>
> Синтаксический сахар — это мощный инструмент, который делает код лаконичным и понятным. Однако важно помнить, что он не меняет сути работы кода, а лишь упрощает его запись. Используйте его разумно, чтобы поддерживать баланс между удобством и ясностью.

---

## |2| **Переменные**

Переменные в JavaScript — это именованные контейнеры для хранения данных. Особенности их объявления и поведения зависят от используемого ключевого слова (директивой): `var`, `let` или `const`.

-   `var`: устаревший способ объявления переменной, избегайте его использования.
-   `let`: используется для переменных, значение которых может изменяться.
-   `const`: для переменных, значение которых не изменяется.

**Пример:**

```javascript
let name = 'Alice'; // Переменная, которая может изменяться
const age = 25; // Переменная, которая не может изменяться
var city = 'London'; // Устаревший способ (не рекомендуется)

console.log(name); // Выведет: Alice
console.log(age); // Выведет: 25
```

### 1. **Объявление переменной**

Для создания переменной в JavaScript используются директивы `var`, `let` и `const`.

Приведённая ниже инструкция создаёт (другими словами, объявляет) переменную с именем `«message»`:

```js
let message;
```

Теперь можно поместить в неё данные (другими словами, определить переменную), используя оператор присваивания `=`:

```js
let message;
message = 'Hello'; // сохранить строку 'Hello' в переменной с именем message
```

Строка сохраняется в области памяти, связанной с переменной. Мы можем получить к ней доступ, используя имя переменной:

```js
let message;
message = 'Hello!';

alert(message); // показывает содержимое переменной
```

Для краткости можно совместить объявление переменной и запись данных в одну строку:

```js
let message = 'Hello!'; // определяем переменную и присваиваем ей значение

alert(message); // Hello!
```

Мы также можем объявить несколько переменных в одной строке:

```
let user = 'John', age = 25, message = 'Hello';
```

> [!NOTE]
>
> Такой способ может показаться короче, но мы не рекомендуем его. Для лучшей читаемости объявляйте каждую переменную на новой строке.

Многострочный вариант немного длиннее, но легче для чтения:

```js
let user = 'John';
let age = 25;
let message = 'Hello';
```

Допускается также определение нескольких переменных в таком вот многострочном стиле:

```js
let user = 'John',
    age = 25,
    message = 'Hello';
```

…Или даже с запятой в начале строки:

```
let user = 'John'
  , age = 25
  , message = 'Hello';
```

В принципе, все эти варианты работают одинаково. Так что это вопрос личного вкуса и эстетики.

#### **1.1. Директива `var` (устаревший способ)**

**Особенности:**

1. **Функциональная область видимости (function scope):**  
   Переменные, объявленные с `var`, доступны внутри всей функции, в которой они объявлены.
2. **Поднятие (hoisting):**  
   Переменная, объявленная через `var`, "поднимается" к началу своей области видимости, но значение остается `undefined` до момента присвоения.
3. **Не ограничена блоком:**  
   Если `var` объявлена внутри блока (`if`, `for`), она все равно доступна за его пределами.

**Пример:**

```javascript
if (true) {
    var x = 10; // доступна за пределами блока
}
console.log(x); // 10
```

**Почему не следует использовать `var`?**

1. **Неявное поднятие (hoisting):**  
   Переменные `var` поднимаются, что может приводить к путанице.

    ```javascript
    console.log(a); // undefined
    var a = 10;
    ```

2. **Неограниченная область видимости:**  
   Переменная `var` доступна за пределами блока, где она объявлена. Это может привести к ошибкам.

    ```javascript
    for (var i = 0; i < 5; i++) {
        console.log(i); // 0, 1, 2, 3, 4
    }
    console.log(i); // 5 (ожидали, что i будет недоступна)
    ```

3. **Нет защиты от повторного объявления:**  
   Переменная `var` может быть объявлена несколько раз, что сложно отследить.

    ```javascript
    var x = 10;
    var x = 20; // допустимо, но нежелательно
    console.log(x); // 20
    ```

4. **Проблемы с отладкой:**  
   Поведение `var` может быть непредсказуемым, особенно в сложных функциях с вложенными блоками.

#### **1.2. Директива `let` (современный способ)**

**Особенности:**

1.  **Блочная область видимости (block scope):**  
    Областью видимости переменных, объявленных ключевым словом `let`, является блок, в котором они объявлены, и все его подблоки. В этом работа директива `let` схожа с работой директивы `var`. Основная разница заключается в том, что областью видимости переменной, объявленной директивой `var`, является вся функция, в которой она объявлена

    ```js
    function varTest() {
        var x = 1;
        if (true) {
            var x = 2; // та же переменная!
            console.log(x); // 2
        }
        console.log(x); // 2
    }

    function letTest() {
        let x = 1;
        if (true) {
            let x = 2; // другая переменная
            console.log(x); // 2
        }
        console.log(x); // 1
    }
    ```

    В стандарте ECMAScript 2015 переменные, объявленные директивой `let`, переносятся в начало блока. Но если вы сошлётесь в блоке на переменную, до того как она объявлена директивой `let`, то это приведёт к выбросу исключения `ReferenceError`, потому что переменная находится во "временной мёртвой зоне" с начала блока и до места её объявления. (В отличии от переменной, объявленной через `var`, которая просто будет содержать значение `undefined`)

    ```js
    function do_something() {
        console.log(bar); // undefined
        console.log(foo); // ReferenceError: foo is not defined
        var bar = 1;
        let foo = 2;
    }
    ```

2.  **Повторное объявление**
    Повторное объявление той же переменной в том же блоке или функции приведёт к выбросу исключения `SyntaxError`.

    ```js
    if (x) {
        let foo;
        let foo; // SyntaxError thrown.
    }
    ```

3.  **Поднятие (hoisting) без инициализации:**
    Переменные "поднимаются", но доступ к ним до объявления вызывает ошибку (`ReferenceError`).
4.  **Можно менять значение:**
    Значение переменной, объявленной через `let`, можно изменять.

**Пример:**

```javascript
let x = 10; // Присваиваем значение

if (true) {
    let y = 20; // доступна только внутри блока
    let x = 50; // Присваеваем новое значение?
    console.log(y); // 20
    console.log(x); // 50
}

console.log(y); // Ошибка: y не определена
console.log(x); // 10
```

> [!TIP]
>
> Объяснение, почему было выбрано название "let" можно найти [здесь](https://stackoverflow.com/questions/37916940/why-was-the-name-let-chosen-for-block-scoped-variable-declarations-in-javascri).

#### **1.3. Директива `const` (для неизменяемых переменных)**

**Особенности:**

1. **Блочная область видимости:**  
   Как и `let`, переменные `const` доступны только внутри блока, где они объявлены.
2. **Нельзя переназначать значение:**  
   После присвоения значения переменной `const` его нельзя изменить.
3. **Объекты и массивы:**  
   Структуры данных, объявленные через `const`, можно изменять внутри (например, добавлять элементы в массив), но нельзя переназначать переменную.

**Пример:**

```javascript
const z = 30;
z = 40; // Ошибка: нельзя переназначить значение

const arr = [1, 2, 3];
arr = [4, 5, 6]; // Неперехваченная ошибка типа: присвоение постоянной переменной.
arr.push(4); // Это допустимо
console.log(arr); // [1, 2, 3, 4]
```

### 2. **Правила нейминга переменных**

В JavaScript есть два ограничения, касающиеся имён переменных:

-   Имя переменной должно содержать только буквы, цифры или символы `$` и `_`.
-   Первый символ не должен быть цифрой.

Если имя содержит несколько слов, обычно используется `верблюжья нотация` (_camelCase_), то есть, слова следуют одно за другим, где каждое следующее слово начинается с заглавной буквы: `myVeryLongName`.

Самое интересное – знак доллара `'$'` и подчёркивание `'_'` также можно использовать в названиях. Это обычные символы, как и буквы, без какого-либо особого значения.

**Эти имена являются допустимыми:**

```js
let $ = 1; // объявили переменную с именем "$"
let _ = 2; // а теперь переменную с именем "_"

alert($ + _); // 3
```

**Примеры неправильных имён переменных:**

```js
let 1a; // не может начинаться с цифры
let my-name; // дефис '-' не разрешён в имени
```

> [!NOTE]
>
> **Нелатинские буквы разрешены, но не рекомендуются**
>
> Можно использовать любой язык, включая кириллицу или даже иероглифы, например:
>
> ```js
> let имя = '...';
> let 我 = '...';
> ```
>
> Технически здесь нет ошибки, такие имена разрешены, но есть международная традиция использовать английский язык в именах переменных. Даже если мы пишем небольшой скрипт, у него может быть долгая жизнь впереди. Людям из других стран, возможно, придётся прочесть его не один раз.

> [!WARNING]
>
> **Регистр имеет значение**
>
> Переменные с именами `apple` и `APPLE` – это две разные переменные.

> [!CAUTION]
>
> **Зарезервированные имена**
>
> Существует список [зарезервированных слов](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Lexical_grammar#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%B5_%D1%81%D0%BB%D0%BE%D0%B2%D0%B0), которые нельзя использовать в качестве имён переменных, потому что они используются самим языком.
>
> Например: `let`, `class`, `return` и `function` зарезервированы.
>
> Приведённый ниже код даёт синтаксическую ошибку:
>
> ```js
> let let = 5; // нельзя назвать переменную "let", ошибка!
> let return = 5; // также нельзя назвать переменную "return", ошибка!
> ```

> [!CAUTION]
>
> **Создание переменной без использования `use strict`**
>
> Обычно нам нужно определить переменную перед её использованием. Но в старые времена было технически возможно создать переменную простым присвоением значения без использования `let`. Это все ещё работает, если мы не включаем `use strict` в наших файлах, чтобы обеспечить совместимость со старыми скриптами.
>
> ```js
> // заметка: "use strict" в этом примере не используется
>
> num = 5; // если переменная "num" раньше не существовала, она создаётся
>
> alert(num); // 5
> ```
>
> Это плохая практика, которая приводит к ошибке в строгом режиме:
>
> ```js
> 'use strict';
>
> num = 5; // ошибка: num is not defined
> ```

### 3. **Константы**

Широко распространена практика использования констант в качестве псевдонимов для трудно запоминаемых значений, которые известны до начала исполнения скрипта.

Названия таких констант пишутся с использованием заглавных букв и подчёркивания.

Например, сделаем константы для различных цветов в «шестнадцатеричном формате»:

```js
const COLOR_RED = '#F00';
const COLOR_GREEN = '#0F0';
const COLOR_BLUE = '#00F';
const COLOR_ORANGE = '#FF7F00';

// ...когда нам нужно выбрать цвет
let color = COLOR_ORANGE;
alert(color); // #FF7F00
```

> [!TIP]
>
> **Преимущества:**
>
> `COLOR_ORANGE` гораздо легче запомнить, чем `"#FF7F00"`.
> Гораздо легче допустить ошибку при вводе `"#FF7F00"`, чем при вводе `COLOR_ORANGE`.
> При чтении кода `COLOR_ORANGE` намного понятнее, чем `#FF7F00`.

**Когда мы должны использовать для констант заглавные буквы, а когда называть их нормально?**

Название «константа» просто означает, что значение переменной никогда не меняется. Но есть константы, которые известны до выполнения (например, шестнадцатеричное значение для красного цвета), а есть константы, которые вычисляются во время выполнения сценария, но не изменяются после их первоначального назначения.

**Пример:**

```js
const pageLoadTime = /* время, потраченное на загрузку веб-страницы */;
```

Значение `pageLoadTime` неизвестно до загрузки страницы, поэтому её имя записано обычными, а не прописными буквами. Но это всё ещё константа, потому что она не изменяется после назначения.

Другими словами, константы с именами, записанными заглавными буквами, используются только как псевдонимы для **«жёстко закодированных»** значений.

### 4. **Семантические названия переменных**

В разговоре о переменных необходимо упомянуть, что есть ещё одна чрезвычайно важная вещь.

Название переменной должно иметь ясный и понятный смысл, говорить о том, какие данные в ней хранятся.

Именование переменных – это один из самых важных и сложных навыков в программировании. Быстрый взгляд на имена переменных может показать, какой код был написан новичком, а какой – опытным разработчиком.

В реальном проекте большая часть времени тратится на изменение и расширение существующей кодовой базы, а не на написание чего-то совершенно нового с нуля. Когда мы возвращаемся к коду после какого-то промежутка времени, гораздо легче найти информацию, которая хорошо размечена. Или, другими словами, когда переменные имеют хорошие имена.

Пожалуйста, потратьте время на обдумывание правильного имени переменной перед её объявлением. Делайте так, и будете вознаграждены.

> [!TIP]
>
> **Несколько хороших правил:**
>
> -   Используйте легко читаемые имена, такие как `userName` или `shoppingCart`.
> -   Избегайте использования аббревиатур или коротких имён, таких как `a`, `b`, `c`, за исключением тех случаев, когда вы точно знаете, что так нужно.
> -   Делайте имена максимально описательными и лаконичными. Примеры плохих имён: `data` и `value`. Такие имена ничего не говорят. Их можно использовать только в том случае, если из контекста кода очевидно, какие данные хранит переменная.
> -   Договоритесь с вашей командой об используемых терминах. Если посетитель сайта называется `«user»`, тогда мы должны называть связанные с ним переменные `currentUser` или `newUser`, а не, к примеру, `currentVisitor` или `newManInTown`.

Звучит просто? Действительно, это так, но на практике для создания описательных и кратких имён переменных зачастую требуется подумать.

> [!IMPORTANT]
>
> **Повторно использовать или создавать новую переменную?**
>
> Есть ленивые программисты, которые вместо объявления новых переменных повторно используют существующие.
>
> В результате их переменные похожи на коробки, в которые люди бросают разные предметы, не меняя на них этикетки. Что сейчас находится внутри коробки? Кто знает? Нам необходимо подойти поближе и проверить.
>
> Такие программисты немного экономят на объявлении переменных, но теряют в десять раз больше при отладке.
>
> Дополнительная переменная – это добро, а не зло.
>
> Современные JavaScript-минификаторы и браузеры оптимизируют код достаточно хорошо, поэтому он не создаёт проблем с производительностью. Использование разных переменных для разных значений может даже помочь движку оптимизировать ваш код.

### **Рекомендации**

-   Используйте **`let`** для переменных, значение которых может изменяться.
-   Используйте **`const`** для значений, которые не должны изменяться после их определения.
-   Избегайте использования **`var`**, чтобы избежать возможных ошибок и путаницы.

**Пример правильного использования:**

```javascript
const pi = 3.14159; // Константа
let radius = 5; // Переменная, которую можно изменить

let area = pi * radius ** 2;
console.log('Площадь круга:', area);
```

---

## |3| **Строгий режим `strict mode`**

**`strict mode`** (строгий режим) — это специальный режим выполнения кода в JavaScript, который вводит более строгие правила интерпретации и выполнения. Он помогает писать более безопасный и предсказуемый код, устраняя некоторые "тихие" ошибки, улучшая производительность и предотвращая использование устаревших или потенциально небезопасных функций.

### 1. **Способы включения строгого режима**

#### **1.1. Включение для всего файла**

Добавьте строку `"use strict";` в начало файла. Это активирует строгий режим для всего скрипта.

```javascript
'use strict';

x = 10; // Ошибка: x не объявлен
```

#### **1.2. Включение для функции**

Вы можете активировать строгий режим только для определённой функции, добавив `"use strict";` в её начало.

```javascript
function myFunction() {
    'use strict';
    y = 20; // Ошибка: y не объявлен
}
myFunction();
```

### 2. **Основные изменения и ограничения в строгом режиме**

#### **2.1. Ошибка при использовании необъявленных переменных**

В обычном режиме присваивание значения необъявленной переменной создаёт её глобально. В строгом режиме это вызывает ошибку.

```javascript
'use strict';
x = 10; // Ошибка: x не объявлен
```

#### **2.2. Запрет на удаление переменных, функций и объектов**

В строгом режиме нельзя удалять переменные или функции с помощью оператора `delete`.

```javascript
'use strict';
let x = 10;
delete x; // Ошибка: нельзя удалить переменную

function myFunc() {}
delete myFunc; // Ошибка: нельзя удалить функцию
```

#### **2.3. Запрет на дублирование имен параметров функций**

В строгом режиме нельзя использовать одинаковые имена для параметров функций.

```javascript
'use strict';
function myFunc(a, a) {
    // Ошибка
    return a;
}
```

#### **2.4. Использование зарезервированных слов запрещено**

Некоторые ключевые слова зарезервированы для будущих версий JavaScript. В строгом режиме их нельзя использовать в качестве переменных или имен функций.

```javascript
'use strict';
let public = 10; // Ошибка: "public" зарезервировано
```

#### **2.5. Ограничения на `this`**

В строгом режиме значение `this` в функции, вызванной без контекста, равно `undefined`, а не глобальному объекту.

```javascript
'use strict';
function myFunc() {
    console.log(this); // undefined
}
myFunc();
```

#### **2.6. Запрет на запись в `read-only` свойства**

Нельзя изменять свойства объектов, которые имеют атрибут `writable: false`.

```javascript
'use strict';
const obj = Object.freeze({ name: 'John' });
obj.name = 'Doe'; // Ошибка
```

#### **2.7. Запрет на добавление свойств к `non-extensible` объектам**

Если объект сделан "недополняемым" с помощью `Object.preventExtensions`, то в строгом режиме нельзя добавлять новые свойства.

```javascript
'use strict';
const obj = Object.preventExtensions({ name: 'John' });
obj.age = 30; // Ошибка
```

#### **2.8. Устранение "тихих" ошибок**

Некоторые операции, которые в обычном режиме игнорируются или выполняются без ошибок, в строгом режиме вызывают явные ошибки.

### **Преимущества использования строгого режима**

1. **Ловит ошибки на ранней стадии**: Многие потенциально проблемные операции становятся явными.
2. **Улучшает производительность**: Некоторые оптимизации могут быть выполнены, так как строгий режим устраняет "опасные" конструкции.
3. **Запрет на использование устаревших функций**: Например, `with` и `arguments.caller`.

### **Ограничения строгого режима**

1. **Совместимость**: Некоторые старые браузеры могут не поддерживать строгий режим. Однако современные браузеры поддерживают его полностью.
2. **Не распространяется на встроенные скрипты**: Если скрипт вставлен через `eval`, строгий режим должен быть явно включён внутри него.

### **Полный пример**

```javascript
'use strict';

function calculate(a, b) {
    // Нельзя использовать одинаковые имена параметров
    // function(a, a) {} // Ошибка

    let sum = a + b; // Переменная должна быть объявлена
    return sum;
}

try {
    undeclaredVar = 10; // Ошибка: переменная не объявлена
} catch (e) {
    console.error(e.message);
}

console.log(calculate(5, 10)); // 15
```

### **Когда использовать `strict mode`**

1. **Всегда**: Включение строгого режима помогает избежать множества потенциальных ошибок.
2. **Частично**: Если нужно только для конкретных функций, чтобы не ломать старый код.

Использование строгого режима — это практика, которая повышает качество кода и облегчает отладку.

---

## |4| **Область видимости**

**Область видимости** — это контекст, в котором определены переменные, функции и объекты. Она определяет, откуда переменные доступны и управляет их временем жизни. В JavaScript область видимости играет ключевую роль в организации и работе кода.

В JavaScript контекст (_context_) и область видимости (_scope_) — это разные концепции, которые важно понимать для работы с кодом.

### 1. **Глобальная область видимости (Global Scope)**

-   Все переменные и функции, объявленные вне функций и блоков, принадлежат глобальной области.
-   Они доступны из любого места в коде.

**Пример:**

```javascript
let globalVar = 'Я глобальная переменная';

function printGlobal() {
    console.log(globalVar); // Доступна
}

printGlobal();
console.log(globalVar); // Доступна
```

### 2. **Функциональная область видимости (Function Scope)**

-   Переменные, объявленные с помощью `var`, `let` или `const` внутри функции, доступны только внутри этой функции.
-   Это изолированная область, не доступная извне.

**Пример:**

```javascript
function example() {
    let localVar = 'Я локальная переменная';
    console.log(localVar); // Доступна здесь
}

example();
// console.log(localVar); // Ошибка: localVar не определена
```

### 3. **Блочная область видимости (Block Scope)**

-   Переменные, объявленные с помощью `let` и `const`, существуют только внутри блока `{ ... }`. Таким образом, переменные `let` и `const` не будут доступны за пределами блока, и произойдет ошибка **ReferenceError**.
-   Это более строгая область видимости, чем у `var`.

**Пример:**

```javascript
if (true) {
    let blockVar = 'Я в блоке';
    console.log(blockVar); // Доступна
}

// console.log(blockVar); // Ошибка: blockVar не определена
```

```js
{
    let foo = function () {
        return 'Внутри блока';
    };
}

console.log(foo()); // ReferenceError: foo is not defined
```

Следует подчеркнуть, что использование `var` может привести к неожиданному поведению, особенно в крупных проектах. Переменные, объявленные с помощью `var`, игнорируют блочную область:

```js
{
    var foo = function () {
        return 'Внутри блока';
    };
}

console.log(foo()); // 'Внутри блока'
```

```javascript
if (true) {
    var blockIgnored = 'Я игнорирую блок';
}

console.log(blockIgnored); // Доступна
```

### 4. **Лексическая область видимости (Lexical Scope)**

-   Область видимости определяется местоположением функции в коде.
-   Функция имеет доступ к переменным, объявленным в области, в которой она была определена, даже если вызывается из другой области. Это свойство особенно важно для работы с замыканиями, поскольку они позволяют функциям сохранять доступ к своей лексической области видимости, даже когда вызываются за её пределами.

**Пример:**

```javascript
let globalVar = 'Глобальная';

function outer() {
    let outerVar = 'Я снаружи';

    function inner() {
        var innerVar = 'Я внутри';
        console.log(globalVar); // Доступна
        console.log(innerVar); // Доступна
        console.log(outerVar); // Доступна
    }

    inner();
    console.log(innerVar); // ReferenceError: outerVar is not defined
}

outer();
console.log(innerVar); // ReferenceError: outerVar is not defined
console.log(outerVar); // ReferenceError: outerVar is not defined
```

> [!TIP]
>
> **Преимущества лексической области видимости**
>
> -   **Простота и предсказуемость**:
>     Код легче понять и предсказать его поведение.
>
> -   **Инкапсуляция**:
>     Переменные и функции могут быть скрыты в локальных областях видимости, что снижает риск конфликтов имён и улучшает безопасность кода.
>
> -   **Мощные замыкания**:
>     Позволяют создавать функции с устойчивыми состояниями, что полезно для работы с асинхронными операциями и функциями обратного вызова.

### 5. **Область видимости модуля (Module Scope)**

Область видимости модуля связана с использованием JavaScript-модулей (`ESModules`), где каждая единица кода имеет свою локальную область видимости. Это позволяет изолировать переменные и функции, предотвращая их доступ извне модуля, если они не экспортированы.

**Пример с использованием `ESModules`:**

```javascript
// module.js
const privateVar = 'Приватная переменная';
export const publicVar = 'Публичная переменная';

export function getPublicVar() {
    return publicVar;
}

// main.js
import { publicVar, getPublicVar } from './module.js';
console.log(publicVar); // 'Публичная переменная'
console.log(getPublicVar()); // 'Публичная переменная'
// console.log(privateVar); // Ошибка: privateVar не определена
```

Для сравнения, в старом стандарте **CommonJS** используется другой подход к организации модульной области видимости. Например:

```javascript
// module.js
const privateVar = 'Приватная переменная';
const publicVar = 'Публичная переменная';

module.exports = {
    publicVar,
    getPublicVar: () => publicVar,
};

// main.js
const { publicVar, getPublicVar } = require('./module.js');
console.log(publicVar); // 'Публичная переменная'
console.log(getPublicVar()); // 'Публичная переменная'
```

Таким образом, использование модульной области видимости помогает поддерживать чистоту и модульность кода, что важно для масштабируемых приложений.

-   В модулях JavaScript (`import/export`) каждое подключаемое или экспортируемое значение имеет свою область видимости.
-   Переменные модуля недоступны глобально.

**Пример:**

```javascript
// module.js
const moduleVar = 'Я внутри модуля';
export default moduleVar;

// main.js
import moduleVar from './module.js';
console.log(moduleVar); // "Я внутри модуля"
```

### 6. **Замыкания и область видимости**

Замыкание (**closure**) — это функция, которая запоминает свою лексическую область видимости, даже если она вызывается за её пределами. Замыкания позволяют функциям сохранять доступ к переменным и функциям, определённым в их области видимости, даже после того, как внешняя функция завершила своё выполнение.

**Пример:**

```javascript
function outer() {
    let count = 0;

    return function inner() {
        count++;
        console.log(count);
    };
}

const counter = outer();
counter(); // 1
counter(); // 2
```

Функция `inner` запоминает значение переменной `count`, даже когда `outer` завершила выполнение. Это свойство замыканий делает их полезными для создания приватных данных или инкапсуляции логики, позволяя функции сохранять состояние между вызовами.

### **Практическое использование областей видимости**

1. **Избегайте глобальных переменных** — это делает код менее предсказуемым. Используйте модули или функции для ограничения областей видимости.
2. **Понимайте лексическую область видимости** — она помогает писать понятный код, избегая конфликтов переменных.
3. **Не забывайте о замыканиях** — они мощный инструмент, но их неправильное использование может привести к утечкам памяти.

> [!NOTE]
>
> Область видимости — основа понимания JavaScript, и знание её работы поможет вам избежать многих ошибок и создавать более понятный и поддерживаемый код.

---

## |5| **Hoisting (поднятие)**

**Hoisting** (поднятие) — это механизм JavaScript, при котором объявления переменных, функций или классов перемещаются в верхнюю часть их области видимости **во время компиляции** (до выполнения кода). Это позволяет использовать переменные или функции до их фактического объявления в коде.

### 1. **Наглядный пример с псевдокодом**

В JavaScript переменные и функции поднимаются (`hoisted`) в начало своей области видимости. Этот процесс можно представить визуально для лучшего понимания.

```plaintext
1. Объявления переменных и функций идентифицируются на этапе компиляции.
2. Все объявления перемещаются вверх текущей области видимости.
3. Инициализация остаётся на месте.
```

Переменные и функции поднимаются по-разному:

-   **`var`**: Переменная поднимается и инициализируется со значением `undefined`.
-   **`let`** и **`const`**: Переменные поднимаются, но недоступны до фактической инициализации (временная мёртвая зона).
-   **Функции** поднимаются целиком, включая их тело.

Для лучшего понимания рассмотрим на примере кода до обработки hoisting:

```javascript
console.log(a);
var a = 5;
test();
function test() {
    console.log(b);
    let b = 10;
}
```

Как это интерпретируется движком JavaScript:

1.  Объявления переменных и функций поднимаются:

    ```js
    var a; // Получает значение undefined
    function test() {
        let b; // Переменная b поднимается, но остаётся в "временной мёртвой зоне"
    }
    ```

2.  Инициализация переменных и вызов функций остаются на своих местах:

    ```js
    console.log(a); // undefined (a поднимается, но ещё не инициализирована)
    a = 5; // Инициализация переменной a
    test(); // Вызов функции test
    ```

3.  Тело функции `test`:

    ```js
    function test() {
        console.log(b); // Ошибка: Cannot access 'b' before initialization
        let b = 10; // Инициализация переменной b
    }
    ```

**Полная интерпретация**
Объединив шаги выше, получим:

```javascript
var a; // Переменная a поднимается

function test() {
    // Функция test поднимается целиком
    let b; // Переменная b поднимается, но остаётся в "временной мёртвой зоне"
    console.log(b); // Ошибка: Cannot access 'b' before initialization
    b = 10; // Инициализация переменной b
}

console.log(a); // undefined
a = 5; // Инициализация переменной a
test(); // Вызов функции test
```

**Объяснение:**

1.  **Поднятие переменной `a`:**
    Переменная `a` объявляется и поднимается в верхнюю часть области видимости. На момент вызова `console.log(a)`, переменная уже существует, но ещё не инициализирована, поэтому выводится `undefined`.

2.  **Поднятие функции `test`:**
    Функция `test` объявляется и поднимается целиком, включая её тело. Это позволяет вызывать функцию `test` до её фактического определения в коде.

3.  **Вызов `test`:**
    Внутри функции `test` переменная `b`, объявленная с помощью `let`, поднимается, но остаётся в **"временной мёртвой зоне"** до строки с инициализацией. Поэтому при попытке доступа к `b` до её объявления возникает ошибка **Cannot access 'b' before initialization.**

> [!NOTE]
>
> -   Переменные, объявленные через `var`, `let` и `const`, а также функции и классы поднимаются, но обрабатываются по-разному.
> -   `Hoisting` касается **только объявления**, но не инициализации. То есть, значение переменной не поднимается — только её имя.

### 2. **Hoisting переменных**

#### **2.1. Переменные, объявленные с помощью `var`**

Объявление переменной поднимается, но её значение становится `undefined`, пока выполнение не дойдёт до строки с инициализацией.

```javascript
console.log(a); // undefined
var a = 10;
console.log(a); // 10
```

Этот код интерпретируется так:

```javascript
var a;
console.log(a); // undefined
a = 10;
console.log(a); // 10
```

#### **2.2. Переменные, объявленные с помощью `let` и `const`**

Они также поднимаются, но находятся в **"временной мёртвой зоне" (temporal dead zone)** до строки с объявлением.

```javascript
console.log(b); // Ошибка: Cannot access 'b' before initialization
let b = 20;
```

```javascript
console.log(c); // Ошибка: Cannot access 'c' before initialization
const c = 30;
```

### 3. **Hoisting функций**

#### **3.1. Функции, объявленные через `function declaration`**

Полностью поднимаются вместе с телом функции, поэтому их можно вызывать до объявления.

```javascript
console.log(sum(5, 10)); // 15

function sum(a, b) {
    return a + b;
}
```

Этот код интерпретируется так:

```javascript
function sum(a, b) {
    return a + b;
}
console.log(sum(5, 10)); // 15
```

#### **3.2. Функции, объявленные через `function expression`**

Hoisting поднимает только объявление переменной, а не функцию. Поэтому доступ к функции до её объявления вызывает ошибку.

```javascript
console.log(multiply(5, 10)); // Ошибка: multiply is not a function

var multiply = function (a, b) {
    return a * b;
};
```

Этот код интерпретируется так:

```javascript
var multiply;
console.log(multiply(5, 10)); // Ошибка: multiply is not a function
multiply = function (a, b) {
    return a * b;
};
```

#### **3.3. Стрелочные функции (arrow functions)**

Работают аналогично `function expression`. Только объявление переменной поднимается.

```javascript
console.log(divide(10, 2)); // Ошибка: Cannot access 'divide' before initialization

let divide = (a, b) => a / b;
```

### 4. **Hoisting классов**

Классы поднимаются, но остаются в **"временной мёртвой зоне"**, подобно `let` и `const`.

```javascript
const user = new User(); // Ошибка: Cannot access 'User' before initialization

class User {
    constructor(name) {
        this.name = name;
    }
}
```

**Объяснение:**

Класс объявляется, но его нельзя использовать до строки, где он фактически определён. Это поведение связано с особенностями объявления классов через class в ES6.

### 5. **Пример с объяснением**

Рассмотрим сложный пример:

```javascript
console.log(a); // undefined
var a = 5;

function greet() {
    console.log(b); // undefined
    var b = 10;
    console.log(b); // 10
}
greet();

console.log(c); // Ошибка: Cannot access 'c' before initialization
let c = 15;
```

_Объяснение:_

1. Объявление `var a` поднимается, но значение инициализируется позже:

    ```javascript
    var a; // Hoisting
    console.log(a); // undefined
    a = 5;
    ```

2. В функции `greet` переменная `b` поднимается только в её локальной области:

    ```javascript
    function greet() {
        var b; // Hoisting
        console.log(b); // undefined
        b = 10;
        console.log(b); // 10
    }
    ```

3. Переменная `c` объявлена через `let` и находится в "мёртвой зоне" до её инициализации.

### 6. **Проблемы и ограничения Hoisting**

Hoisting (поднятие) может приводить к непредвиденным последствиям при одновременном использовании функций и переменных с одинаковыми именами.

**Пример:**

```javascript
console.log(test); // Вывод: ƒ test() {...}
var test = 10;
function test() {
    console.log('Функция test');
}
console.log(test); // Вывод: 10
```

В этом случае объявление функции `test` поднимается выше, чем объявление переменной `test`. Однако при выполнении кода переменной присваивается значение `10`, что приводит к её переопределению и невозможности вызова функции через имя `test`.

### **Рекомендации**

`Hoisting` — это важная концепция, которую необходимо понимать для правильного написания JavaScript-кода. Используйте `let` и `const`, чтобы избежать неожиданных ошибок, и старайтесь писать код, следуя линейной логике.

1. **Соблюдайте порядок кода.**
    - Объявляйте переменные и функции перед их использованием.
2. **Используйте `let` и `const`**
    - Они делают поведение более предсказуемым.
3. **Проверяйте код линтерами.**
    - Например, ESLint может предупреждать о возможных проблемах с `hoisting`.

---

## |6| **Типы данных**

JavaScript является *слабо типизированным* или *динамическим* языком. Это значит, что вам не нужно определять тип переменной заранее. Тип определится автоматически во время выполнения программы. Также это значит, что вы можете использовать одну переменную для хранения данных различных типов.

```js
var foo = 42; // сейчас foo типа Number
foo = 'bar'; // а теперь foo типа String
foo = true; // foo становится типа Boolean
```

JavaScript позволяет нам работать с примитивными типами данных – строками, числами и т.д., как будто они являются объектами. У них есть и методы. Мы изучим их позже, а сначала разберём, как это всё работает, потому что, конечно, примитивы – не объекты.

### 1. Стандарт ECMAScript определяет 8 типов:

-   6 типов данных являющихся примитивами:
    -   Number (Число): `typeof instance === "number"`
    -   String (Строка): `typeof instance === "string"`
    -   Boolean (Булев, Логический тип): `typeof instance === "boolean"`
    -   Undefined (Неопределённый тип): `typeof instance === "undefined"`
    -   Symbol (в ECMAScript 6): `typeof instance === "symbol"`
    -   BigInt: `typeof instance === "bigint"`
-   Null: `typeof instance === "object"`. Специальный примитив, используемый не только для данных но и в качестве указателя на финальную точку в **Цепочке Прототипов**;
-   Object (Объект): `typeof instance === "object"`. Может хранить множество значений как свойства. Простая структура, используемая не только для хранения данных, но и для создания других структур, где любая структура создаётся с использованием ключевого слова `new`: `new Object`, `new Array`, `new Map`, `new Set`, `new WeakMap`, `new WeakSet`, `new Date` и множество других структур;

> [!IMPORTANT]
>
> Все типы данных в JavaScript, кроме объектов, являются иммутабельными (значения не могут быть модифицированы, а только перезаписаны новым полным значением). Например, в отличии от C, где строку можно посимвольно корректировать, в JavaScript строки пересоздаются только полностью. Значения таких типов называются «примитивными значениями».

### 2. **Примитив как объект**

Вот парадокс, с которым столкнулся создатель JavaScript:

-   Есть много всего, что хотелось бы сделать с примитивами, такими как строка или число. Было бы замечательно, если бы мы могли обращаться к ним при помощи методов.
-   Примитивы должны быть лёгкими и быстрыми насколько это возможно.

Выбранное решение, хотя выглядит оно немного неуклюже:

-   Примитивы остаются примитивами. Одно значение, как и хотелось.
-   Язык позволяет осуществлять доступ к методам и свойствам строк, чисел, булевых значений и символов.

Чтобы это работало, при таком доступе создаётся специальный «объект-обёртка», который предоставляет нужную функциональность, а после удаляется.
Каждый примитив имеет свой собственный «объект-обёртку», которые называются: `String`, `Number`, `Boolean`, `Symbol` и `BigInt`. Таким образом, они имеют разный набор методов.

К примеру, существует метод `str.toUpperCase()`, который возвращает строку в верхнем регистре.

Вот, как он работает:

```js
let str = 'Привет';

alert(str.toUpperCase()); // ПРИВЕТ
```

Очень просто, не правда ли? Вот, что на самом деле происходит в `str.toUpperCase()`:

1. Строка `str` – примитив. В момент обращения к его свойству, создаётся специальный объект, который знает значение строки и имеет такие полезные методы, как `toUpperCase()`.
2. Этот метод запускается и возвращает новую строку (показывается в `alert`).
3. Специальный объект удаляется, оставляя только примитив `str`.

Получается, что примитивы могут предоставлять методы, и в то же время оставаться «лёгкими».

Движок JavaScript сильно оптимизирует этот процесс. Он даже может пропустить создание специального объекта. Однако, он всё же должен придерживаться спецификаций и работать так, как будто он его создаёт.

Число имеет собственный набор методов. Например, `toFixed(n)` округляет число до `n` знаков после запятой.

```js
let num = 1.23456;

alert(num.toFixed(2)); // 1.23
```

Более подробно с различными свойствами и методами мы познакомимся позже.

> [!CAUTION]
>
> **Конструкторы String/Number/Boolean предназначены только для внутреннего пользования**
> Некоторые языки, такие как Java, позволяют явное создание «объектов-обёрток» для примитивов при помощи такого синтаксиса как `new Number(1)` или `new Boolean(false)`.
>
> В JavaScript, это тоже возможно по историческим причинам, но очень не рекомендуется. В некоторых местах последствия могут быть катастрофическими.
>
> **Пример:**
>
> ```js
> alert(typeof 0); // "число"
>
> alert(typeof new Number(0)); // "object"!
> ```
>
> Объекты в `if` всегда дают `true`, так что в нижеприведённом примере будет показан `alert`:
>
> ```js
> let zero = new Number(0);
>
> if (zero) {
>     // zero возвращает "true", так как является объектом
>     alert('zero имеет «истинное» значение?!?');
> }
> ```
>
> С другой стороны, использование функций `String`/`Number`/`Boolean` без оператора `new` – вполне разумно и полезно. Они превращают значение в соответствующий примитивный тип: в строку, в число, в булевый тип.
>
> К примеру, следующее вполне допустимо:
>
> ```js
> let num = Number('123'); // превращает строку в число
> ```

> [!CAUTION]
>
> **null/undefined не имеют методов**
> Особенные примитивы null и undefined являются исключениями. У них нет соответствующих «объектов-обёрток», и они не имеют никаких методов. В некотором смысле, они «самые примитивные».
>
> Попытка доступа к свойствам такого значения возвратит ошибку:
>
> ```js
> alert(null.test); // ошибка
> ```

### 3. Проверка типа структур

Оператор `typeof` возвращает тип аргумента. Это полезно, когда мы хотим обрабатывать значения различных типов по-разному или просто хотим сделать проверку.

У него есть две синтаксические формы:

```plaintext
// Обычный синтаксис
typeof 5; // Выведет "number"
// Синтаксис, напоминающий вызов функции (встречается реже)
typeof(5); // Также выведет "number"
```

Если передается выражение, то нужно заключать его в скобки, т.к. `typeof` имеет более высокий приоритет, чем бинарные операторы:

```js
typeof 50 + ' Квартир'; // Выведет "number Квартир"
typeof (50 + ' Квартир'); // Выведет "string"
```

Другими словами, скобки необходимы для определения типа значения, которое получилось в результате выполнения выражения в них.

Вызов `typeof x` возвращает строку с именем типа:

```js
typeof undefined; // "undefined"
typeof 0; // "number"
typeof 10n; // "bigint"
typeof true; // "boolean"
typeof 'foo'; // "string"
typeof Symbol('id'); // "symbol"
typeof Math; // "object"  (1)
typeof null; // "object"  (2)
typeof alert; // "function"  (3)
```

Последние три строки нуждаются в пояснении:

-   `Math` — это встроенный объект, который предоставляет математические операции и константы.
-   Результатом вызова `typeof null` является "`object`". Это официально признанная ошибка в `typeof`, ведущая начало с времён создания JavaScript и сохранённая для совместимости. Конечно, `null` не является объектом. Это специальное значение с отдельным типом.
-   Вызов `typeof alert` возвращает "`function`", потому что `alert` является функцией. Мы изучим функции в следующих главах, где заодно увидим, что в JavaScript нет специального типа «функция». Функции относятся к объектному типу. Но `typeof` обрабатывает их особым образом, возвращая "`function`". Так тоже повелось от создания JavaScript. Формально это неверно, но может быть удобным на практике.

```javascript
let number = 42; // Число
let text = 'Hello, world!'; // Строка
let isOnline = true; // Логическое значение
let notAssigned; // undefined
let empty = null; // null

console.log(typeof number); // Выведет: number
console.log(typeof text); // Выведет: string
console.log(typeof isOnline); // Выведет: boolean
console.log(typeof notAssigned); // Выведет: undefined
console.log(typeof empty); // Выведет: object (особенность языка)
```

Чаще всего операторы и функции автоматически приводят переданные им значения к нужному типу.

Например, `alert` автоматически преобразует любое значение к строке. Математические операторы преобразуют значения к числам.

Есть также случаи, когда нам нужно явно преобразовать значение в ожидаемый тип.

> [!IMPORTANT]
>
> Необходимо сделать предостережение относительно использования оператора `typeof` для определения типа структур, т.к. все структуры будут возвращать `"object"` при его использовании, так как назначение `typeof` — проверка типа данных, но не структур. Если проверить тип структуры всё же необходимо, то в этом случае желательно использовать оператор [instanceof](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/instanceof), так как именно он отвечает на вопрос о том, какой конструктор был использован для создания структуры.

> [!IMPORTANT]
>
> Стоит отметить два особых случая работы оператора `typeof`: возврат `"object"` для значения `null` и `"function"` для функций: первое принято считать ошибкой языка, сохраненной ради обратной совместимости, второе является условностью, удобной для проверки на принадлежность значения категории функций, где функция - это особый, "вызываемый", объект.

### 4. **Числа (Number)**

Числа в JavaScript представлены одним типом, включая целые и дробные значения. В соответствии со стандартом ECMAScript, существует только один числовой тип, который представляет собой [64-битное число двойной точности согласно стандарту IEEE 754](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%BE_%D0%B4%D0%B2%D0%BE%D0%B9%D0%BD%D0%BE%D0%B9_%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D0%B8). Другими словами, **специального типа для целых чисел в JavaScript нет**. Это означает, что при числовых операциях вы можете получить неточное (округлённое) значение. В дополнение к возможности представлять числа с плавающей запятой, есть несколько символических значений: `+Infinity` (положительная бесконечность), `-Infinity` (отрицательная бесконечность), и `NaN` (не число).

В JavaScript тип `number` не может безопасно работать с числами, большими, чем `(2**53-1)` (т. е. `9007199254740991`) или меньшими, чем `-(2**53-1)` для отрицательных чисел.

Если говорить совсем точно, то, технически, тип number может хранить большие целые числа `(до 1.7976931348623157 * 10**308)`, но за пределами безопасного диапазона целых чисел `±(2**53-1)` будет ошибка точности, так как не все цифры помещаются в фиксированную 64-битную память. Поэтому можно хранить «приблизительное» значение.

Например, эти два числа (прямо за пределами безопасного диапазона) совпадают:

```js
console.log(9007199254740991 + 1); // 9007199254740992
console.log(9007199254740991 + 2); // 9007199254740992
```

То есть все нечетные целые числа, большие чем `(2**53-1)`, вообще не могут храниться в типе `number`.

В большинстве случаев безопасного диапазона чисел от `-(2**53-1)` до `(2**53-1)` вполне достаточно, но иногда нам требуется весь диапазон действительно гигантских целых чисел без каких-либо ограничений или пропущенных значений внутри него. Например, в криптографии или при использовании метки времени (`«timestamp»`) с микросекундами.

> [!CAUTION]
>
> Хотя число в большинстве случаев представляет только своё значение, JavaScript предоставляет [несколько бинарных операций](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators). Они могут использоваться для того, чтобы представлять число как несколько булевых значений, с помощью [битовой маски](https://ru.wikipedia.org/wiki/%D0%91%D0%B8%D1%82%D0%BE%D0%B2%D0%B0%D1%8F_%D0%BC%D0%B0%D1%81%D0%BA%D0%B0). Это считается плохой практикой, так как JavaScript предлагает другие способы представления булевых значений (например, массив элементов с булевыми значениями или объект, содержащий набор булевых свойств). Кроме того, битовые маски часто делают код более трудным для чтения, понимания и дальнейшей поддержки. Эта техника может быть необходима в условиях технических ограничений, таких как объём локального хранилища данных, или в такой экстремальной ситуации, когда каждый бит передаваемый по сети на счету. Данный подход следует использовать как крайнюю меру, когда не остаётся других путей для необходимой оптимизации.
>
> Подробное объяснение с примерами [1.2.2.2 Битовая маска](./1.2.2.2%20Битовая%20маска.md)

#### **4.1. Особенности:**

-   Поддержка операций: `+`, `-`, `*`, `/`, `%`, `**`.
-   Математические операции в JavaScript «безопасны». Мы можем делать что угодно: делить на ноль, обращаться с нечисловыми строками как с числами и т.д. Скрипт никогда не остановится с фатальной ошибкой (не «умрёт»). В худшем случае мы получим `NaN` как результат выполнения.
-   Специальные значения:
    -   `NaN` (Not a Number) — результат недопустимой операции.
    -   `Infinity` и `-Infinity` — бесконечности.
-   Методы: `.parseInt()`, `.parseFloat()`, `.isNaN()`, `.isInteger()`, `.toFixed()`
-   Ноль в JavaScript имеет два представления: -0 и +0. («0» это синоним +0). На практике это имеет малозаметный эффект. Например, выражение `+0 === -0` является истинным. Однако, это может проявиться при делении на ноль:

```js
let a = 42 / +0; // Infinity
let b = 42 / -0; // -Infinity
```

#### **4.2. Способы записи числа**

Представьте, что нам надо записать число 1 миллиард. Самый очевидный путь:

```js
let billion = 1000000000;
```

Мы также можем использовать символ нижнего подчёркивания `_` в качестве разделителя:

```js
let billion = 1_000_000_000;
```

Символ нижнего подчёркивания `_` – это «синтаксический сахар», он делает число более читабельным. Движок JavaScript попросту игнорирует `_` между цифрами, поэтому в примере выше получается точно такой же миллиард, как и в первом случае.

Однако в реальной жизни мы в основном стараемся не писать длинные последовательности нулей, так как можно легко ошибиться. Укороченная запись может выглядеть как `"1млрд"` или `"7.3млрд"` для 7 миллиардов 300 миллионов. Такой принцип работает для всех больших чисел.

В JavaScript, чтобы укоротить запись числа, мы можем добавить к нему букву `"e"` и указать необходимое количество нулей:

```js
let billion = 1e9; // 1 миллиард, буквально: 1 и 9 нулей

alert(7.3e9); // 7.3 миллиарда (7,300,000,000)
```

Другими словами, `"e"` умножает число на 1 с указанным количеством нулей.

```js
1e3 === 1 * 1000; // e3 означает *1000
1.23e6 === 1.23 * 1000000; // e6 означает *1000000
```

А сейчас давайте запишем что-нибудь очень маленькое. К примеру, 1 микросекунду (одна миллионная секунды):

```js
let mcs = 0.000001;
```

В этом случае нам также поможет `"e"`. Если мы хотим избежать записи длинной последовательности из нулей, мы можем сделать так:

```js
let ms = 1e-6; // шесть нулей слева от 1
```

Если мы подсчитаем количество нулей в `0.000001`, их будет `6`. Естественно, верная запись `1e-6`.

Другими словами, отрицательное число после `"e"` подразумевает деление на 1 с указанным количеством нулей:

```js

// 1 делится на 1 с 3 нулями
1e-3 === 1 / 1000 (=0.001)

// 1.23 делится на 1 с 6 нулями
1.23e-6 === 1.23 / 1000000 (=0.00000123)
```

#### **4.3. Шестнадцатеричные, двоичные и восьмеричные числа**

Шестнадцатеричные числа широко используются в JavaScript для представления цветов, кодировки символов и многого другого. Естественно, есть короткий стиль записи: `0x`, после которого указывается число.

**Пример:**

```
alert( 0xff ); // 255
alert( 0xFF ); // 255 (то же самое, регистр не имеет значения)
```

Двоичные и восьмеричные числа используются не так часто, но они также поддерживаются: `0b` для двоичных и `0o` для восьмеричных:

```js
let a = 0b11111111; // двоичная (бинарная) форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255

alert(a == b); // true, с двух сторон число 255
```

Есть только 3 системы счисления с такой поддержкой. Для других систем счисления мы рекомендуем использовать функцию `parseInt`.

#### **4.4. Примеры:**

```javascript
let a = 10; // Целое число
let b = 3.14; // Дробное число
let c = 1 / 0; // Infinity
let d = 'hello' * 2; // NaN
let e = 5 % 3; // 2

console.log(typeof a); // "number"
console.log(c); // Infinity
console.log(d); // NaN
console.log(e); // 2
```

#### **4.5. Приведение типов**

Явное преобразование часто применяется, когда мы ожидаем получить число из строкового контекста, например из текстовых полей форм.
Если строка не может быть явно приведена к числу, то результатом преобразования будет `NaN`.

| value          | result                                                                                                                                                                                                                                  |
| -------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `undefined`    | `NaN`                                                                                                                                                                                                                                   |
| `null`         | `0`                                                                                                                                                                                                                                     |
| `true / false` | `1` / `0`                                                                                                                                                                                                                               |
| `string`       | Пробельные символы (пробелы, знаки табуляции `\t`, знаки новой строки `\n` и т. п.) по краям обрезаются. Далее, если остаётся пустая строка, то получаем `0`, иначе из непустой строки «считывается» число. При ошибке результат `NaN`. |

-   Используйте `Number(value)`, унарный `+`, или методы парсинга (`parseInt`, `parseFloat`).
-   Численное преобразование происходит в математических функциях и выражениях. Например, когда операция деления `/` применяется не к числу

```javascript
let str = '123';
console.log(Number(str)); // 123
console.log(+str); // 123
console.log(parseInt('123px')); // 123

let str = 'Любая строка вместо цифр';
console.log(Number(str)); // NaN

console.log('6' / '2'); // 3, строки преобразуются в числа
```

#### **4.6. `NaN` (Not-a-Number)**

**Описание:**

`NaN` — это результат недопустимых арифметических операций, таких как деление строки на число или применение математических функций к недопустимым данным.

**Особенности:**

1. **Тип:**  
   `NaN` принадлежит к типу `number`.

    ```javascript
    console.log(typeof NaN); // "number"
    ```

2. **Уникальность:**  
   `NaN` не равен самому себе. Это значит, что проверка `NaN === NaN` возвращает `false`.

    ```javascript
    console.log(NaN == NaN); // false
    console.log(NaN === NaN); // false
    ```

3. **Проверка на `NaN`:**  
   Для проверки используйте функцию `isNaN()` или `Number.isNaN()`.

    - `isNaN()`: преобразует аргумент в число перед проверкой.
    - `Number.isNaN()`: проверяет только значения, которые изначально равны `NaN`.

4. **`NaN` влияет на результат**
   Если где-то в математическом выражении есть `NaN`, то оно распространяется на весь результат (есть только одно исключение: `NaN ** 0 === 1`).

**Примеры:**

```javascript
console.log('hello' * 2); // NaN
console.log(0 / 0); // NaN
console.log(Math.sqrt(-1)); // возвращает квадратный корень числа, если число < 0, то NaN
console.log(isNaN('hello')); // true (строка преобразована)
console.log(Number.isNaN('hello')); // false (без преобразования)
```

#### **4.7. `Infinity` и `-Infinity`**

**Описание:**

`Infinity` и `-Infinity` представляют положительную и отрицательную бесконечность. Они возникают, когда число выходит за пределы допустимого диапазона или в результате операций, которые не имеют конечного значения.

**Особенности:**

1. **Тип:**  
   `Infinity` также принадлежит к типу `number`.

    ```javascript
    console.log(typeof Infinity); // "number"
    ```

2. **Предельные значения:**
   Для получения самого большого или самого меньшего доступного значения в пределах `+/-Infinity`, можно использовать константы [`Number.MAX_VALUE`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_VALUE) или [`Number.MIN_VALUE`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_VALUE). А начиная с ECMAScript 2015, вы также можете проверить, находится ли число в безопасном для целых чисел диапазоне, используя метод [`Number.isSafeInteger()`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger), либо константы [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER) и [`Number.MIN_SAFE_INTEGER`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_SAFE_INTEGER). За пределами этого диапазона операции с целыми числами будут небезопасными, и возвращать приближённые значения.
3. **Арифметические операции:**

    - Любое число, умноженное на `Infinity`, остаётся бесконечным.
    - Деление числа на `Infinity` даёт `0`.

    ```javascript
    console.log(1 / Infinity); // 0
    console.log(Infinity * 2); // Infinity
    ```

4. **Проверка на бесконечность:**  
   Используйте метод `isFinite()` или прямое сравнение.

    ```javascript
    console.log(isFinite(42)); // true
    alert(isFinite('15')); // true
    alert(isFinite('str')); // false, потому что специальное значение: NaN
    alert(isFinite(Infinity)); // false, потому что специальное значение: Infinity
    ```

    Иногда `isFinite` используется для проверки, содержится ли в строке число:

    ```js
    let num = +prompt('Введите число:', '');

    // вернёт true всегда, кроме ситуаций, когда аргумент - Infinity/-Infinity или не число
    alert(isFinite(num));
    ```

    Помните, что пустая строка интерпретируется как `0` во всех числовых функциях, включая `isFinite`.

**Пример:**

```javascript
console.log(1 / 0); // Infinity
console.log(-1 / 0); // -Infinity
console.log(Number.MAX_VALUE * 2); // Infinity
console.log(-Number.MAX_VALUE * 2); // -Infinity
console.log(Infinity - Infinity); // NaN
```

#### **4.8. Сравнение `NaN` и `Infinity`**

| Особенность        | `NaN`                                 | `Infinity`                                  |
| ------------------ | ------------------------------------- | ------------------------------------------- |
| **Тип**            | `number`                              | `number`                                    |
| **Возникает при:** | Недопустимых математических операциях | Делении на ноль или переполнении            |
| **Равенство**      | Не равен самому себе (`NaN !== NaN`)  | Равен самому себе (`Infinity === Infinity`) |
| **Проверка**       | `isNaN()` или `Number.isNaN()`        | `isFinite()` для проверки конечности        |
| **Особенности**    | Распространённый источник ошибок      | Часто используется в вычислениях            |

> [!CAUTION]
>
> **Number.isNaN и Number.isFinite**
> Методы `Number.isNaN` и `Number.isFinite` – это более «строгие» версии функций `isNaN` и `isFinite`. Они не преобразуют аргумент в число, а наоборот – первым делом проверяют, является ли аргумент числом (принадлежит ли он к типу number).
>
> `Number.isNaN(value)` возвращает `true` только в том случае, если аргумент принадлежит к типу `number` и является `NaN`. Во всех остальных случаях возвращает `false`.
>
> ```js
> alert(Number.isNaN(NaN)); // true
> alert(Number.isNaN('str' / 2)); // true
>
> // Обратите внимание на разный результат:
> alert(Number.isNaN('str')); // false, так как "str" является строкой, а не числом
> alert(isNaN('str')); // true, так как isNaN сначала преобразует строку "str" в число и в результате преобразования получает NaN
> ```
>
> `Number.isFinite(value)` возвращает `true` только в том случае, если аргумент > принадлежит к типу `number` и не является `NaN/Infinity/-Infinity`. Во всех остальных случаях возвращает `false`.
>
> ```js
> alert(Number.isFinite(123)); // true
> alert(Number.isFinite(Infinity)); // false
> alert(Number.isFinite(2 / 0)); // false
>
> // Обратите внимание на разный результат:
> alert(Number.isFinite('123')); // false, так как "123" является строкой, а не числом
> alert(isFinite('123')); // true, так как isFinite сначала преобразует строку "123" в число 123
> ```
>
> Не стоит считать `Number.isNaN` и `Number.isFinite` более «корректными» версиями функций `isNaN` и `isFinite`. Это дополняющие друг-друга инструменты для разных задач.

> [!NOTE]
>
> **Сравнение Object.is**
> Существует специальный метод `Object.is`, который сравнивает значения примерно как `===`, но более надёжен в двух особых ситуациях:
>
> -   Работает с `NaN`: `Object.is(NaN, NaN) === true`, здесь он хорош.
> -   Значения `0` и `-0` разные: `Object.is(0, -0) === false`, это редко используется, но технически эти значения разные.
>
> Во всех других случаях `Object.is(a, b)` идентичен `a === b`.
>
> Этот способ сравнения часто используется в спецификации JavaScript. Когда внутреннему алгоритму необходимо сравнить 2 значения на предмет точного совпадения, он использует `Object.is`.

#### **4.9. Практическое использование и обработка**

**Работа с `NaN`:**

1. Проверяйте ввод пользователя:

    ```javascript
    let input = 'abc';
    let result = parseInt(input);
    if (isNaN(result)) {
        console.log('Недопустимое значение!');
    }
    ```

2. Избегайте использования `==` для проверки, используйте `isNaN()`:

    ```javascript
    console.log(NaN == NaN); // false
    console.log(isNaN(NaN)); // true
    ```

**Работа с `Infinity`:**

1. Используйте проверки на конечность:

    ```javascript
    let largeNumber = 1e309; // больше, чем максимальное число
    console.log(isFinite(largeNumber)); // false
    ```

2. Обрабатывайте деление на ноль:

    ```javascript
    let num = 5;
    let divisor = 0;
    if (divisor === 0) {
        console.log('Ошибка: деление на ноль!');
    } else {
        console.log(num / divisor);
    }
    ```

#### **4.10. Округление**

Одна из часто используемых операций при работе с числами – это округление.

В JavaScript есть несколько встроенных функций для работы с округлением:

-   **Math.floor** - Округление в меньшую сторону: `3.1` становится `3`, а `-1.1` — `-2`.
-   **Math.ceil** - Округление в большую сторону: `3.1` становится `4`, а `-1.1` — `-1`.
-   **Math.round** - Округление до ближайшего целого: `3.1` становится `3`, `3.6` — `4`, а `-1.1` — `-1`.
-   **Math.trunc** (не поддерживается в Internet Explorer) - Производит удаление дробной части без округления: `3.1` становится `3`, а `-1.1` — `-1`.

Ниже представлена таблица с различиями между функциями округления:

| Number | Math.floor | Math.ceil | Math.round | Math.trunc |
| ------ | ---------- | --------- | ---------- | ---------- |
| 3.1    | 3          | 4         | 3          | 3          |
| 3.6    | 3          | 4         | 4          | 3          |
| -1.1   | -2         | -1        | -1         | -1         |
| -1.6   | -2         | -1        | -2         | -1         |

Эти функции охватывают все возможные способы обработки десятичной части. Что если нам надо округлить число до n-ого количества цифр в дробной части?

Например, у нас есть `1.2345` и мы хотим округлить число до 2-х знаков после запятой, оставить только `1.23`.

Есть два пути решения:

1. **Умножить и разделить.**
   Например, чтобы округлить число до второго знака после запятой, мы можем умножить число на 100, вызвать функцию округления и разделить обратно.

    ```js
    let num = 1.23456;

    alert( Math.round(num \* 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23
    ```

2. **Метод `toFixed`.**
   Метод `toFixed(n)` округляет число до `n` знаков после запятой и возвращает строковое представление результата.

    ```js
    let num = 12.34;
    alert(num.toFixed(1)); // "12.3"
    ```

    Округляет значение до ближайшего числа, как в большую, так и в меньшую сторону, аналогично методу `Math.round`:

    ```js
    let num = 12.36;
    alert(num.toFixed(1)); // "12.4"
    ```

    Обратите внимание, что результатом `toFixed` является строка. Если десятичная часть короче, чем необходима, будут добавлены нули в конец строки:

    ```js
    let num = 12.34;
    alert(num.toFixed(5)); // "12.34000", добавлены нули, чтобы получить 5 знаков после запятой
    ```

    Мы можем преобразовать полученное значение в число, используя унарный оператор `+` или `Number()`, пример с унарным оператором: `+num.toFixed(5)`.

#### **4.11. Неточные вычисления**

Внутри JavaScript число представлено в виде 64-битного формата IEEE-754. Для хранения числа используется 64 бита: 52 из них используется для хранения цифр, 11 для хранения положения десятичной точки и один бит отведён на хранение знака.

Если число слишком большое, оно переполнит 64-битное хранилище, JavaScript вернёт бесконечность:

```js
alert(1e500); // Infinity
```

Наиболее часто встречающаяся ошибка при работе с числами в JavaScript – это потеря точности.

Посмотрите на это (неверное!) сравнение:

```js
alert(0.1 + 0.2 == 0.3); // false
```

Да-да, сумма `0.1` и `0.2` не равна `0.3`.

Странно! Что тогда, если не `0.3`?

```js
alert(0.1 + 0.2); // 0.30000000000000004
```

Ой! Здесь гораздо больше последствий, чем просто некорректное сравнение. Представьте, вы делаете интернет-магазин и посетители формируют заказ из 2-х позиций за $0.10 и $0.20. Итоговый заказ будет $0.30000000000000004. Это будет сюрпризом для всех.

**Но почему это происходит?**

Число хранится в памяти в бинарной форме, как последовательность бит – единиц и нулей. Но дроби, такие как 0.1, 0.2, которые выглядят довольно просто в десятичной системе счисления, на самом деле являются бесконечной дробью в двоичной форме.

```js
alert((0.1).toString(2)); // 0.0001100110011001100110011001100110011001100110011001101
alert((0.2).toString(2)); // 0.001100110011001100110011001100110011001100110011001101
alert((0.1 + 0.2).toString(2)); // 0.0100110011001100110011001100110011001100110011001101
```

Другими словами, что такое 0.1? Это единица делённая на десять — 1/10, одна десятая. В десятичной системе счисления такие числа легко представимы, по сравнению с одной третьей: 1/3, которая становится бесконечной дробью 0.33333(3).

Деление на 10 гарантированно хорошо работает в десятичной системе, но деление на 3 – нет. По той же причине и в двоичной системе счисления, деление на 2 обязательно сработает, а 1/10 становится бесконечной дробью.

В JavaScript нет возможности для хранения точных значений 0.1 или 0.2, используя двоичную систему, точно также, как нет возможности хранить одну третью в десятичной системе счисления.

Числовой формат IEEE-754 решает эту проблему путём округления до ближайшего возможного числа. Правила округления обычно не позволяют нам увидеть эту «крошечную потерю точности», но она существует.

**Пример:**

```js
alert((0.1).toFixed(20)); // 0.10000000000000000555
```

И когда мы суммируем 2 числа, их «неточности» тоже суммируются.

Вот почему 0.1 + 0.2 – это не совсем 0.3.

> [!TIP]
>
> Не только в JavaScript
> Справедливости ради заметим, что ошибка в точности вычислений для чисел с плавающей точкой сохраняется в любом другом языке, где используется формат IEEE 754, включая PHP, Java, C, Perl и Ruby.

Можно ли обойти проблему? Конечно, наиболее надёжный способ — это округлить результат используя метод `toFixed(n)`:

```js
let sum = 0.1 + 0.2;
alert(sum.toFixed(2)); // "0.30"
```

Помните, что метод `toFixed` всегда возвращает строку. Это гарантирует, что результат будет с заданным количеством цифр в десятичной части. Также это удобно для форматирования цен в интернет-магазине $0.30. В других случаях можно использовать унарный оператор `+`, чтобы преобразовать строку в число:

```js
let sum = 0.1 + 0.2;
alert(+sum.toFixed(2)); // 0.3
```

Также можно временно умножить число на 100 (или на большее), чтобы привести его к целому, выполнить математические действия, а после разделить обратно. Суммируя целые числа, мы уменьшаем погрешность, но она всё равно появляется при финальном делении:

```js
alert( (0.1 _ 10 + 0.2 _ 10) / 10 ); // 0.3
alert( (0.28 _ 100 + 0.14 _ 100) / 100); // 0.4200000000000001
```

Таким образом, метод умножения/деления уменьшает погрешность, но полностью её не решает.

Иногда можно попробовать полностью отказаться от дробей. Например, если мы в нашем интернет-магазине начнём использовать центы вместо долларов. Но что будет, если мы применим скидку 30%? На практике у нас не получится полностью избавиться от дроби. Просто используйте округление, чтобы отрезать «хвосты», когда надо.

> [!TIP]
>
> **Забавный пример**
> Попробуйте выполнить его:
>
> ```js
> // Привет! Я – число, растущее само по себе!
> alert(9999999999999999); // покажет 10000000000000000
> ```
>
> Причина та же – потеря точности. Из 64 бит, отведённых на число, сами цифры числа занимают до 52 бит, > остальные 11 бит хранят позицию десятичной точки и один бит – знак. Так что если 52 бит не хватает на цифры, то при записи пропадут младшие разряды.
>
> Интерпретатор не выдаст ошибку, но в результате получится «не совсем то число», что мы и видим в примере выше. Как говорится: «как смог, так записал».

> [!TIP]
>
> **Два нуля**
> Другим забавным следствием внутреннего представления чисел является наличие двух нулей: `0` и `-0`.
>
> Все потому, что знак представлен отдельным битом, так что, любое число может быть положительным и отрицательным, включая нуль.
>
> В большинстве случаев это поведение незаметно, так как операторы в JavaScript воспринимают их одинаковыми.

### 5. **Строки (String)**

В JavaScript любые текстовые данные являются строками. Не существует отдельного типа «символ», который есть в ряде других языков.

Внутренний формат для строк — всегда `UTF-16`, вне зависимости от кодировки страницы.

Строки — последовательность символов, заключенная в одинарные `' '`, двойные `" "`, или обратные кавычки `` `  ` ``.

В JavaScript для представления текстовых данных служит тип [`String`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String). Он представляет собой цепочку «элементов» 16-битных беззнаковых целочисленных значений. Каждый такой элемент занимает свою позицию в строке. Первый элемент имеет индекс 0, следующий — 1, и так далее. Длина строки — это количество элементов в ней.

В отличие от языков подобных C, строки в JavaScript являются иммутабельными. Это означает, что после того, как строковое значение создано, его нельзя модифицировать. Нельзя взять символ посередине и заменить его. Как только строка создана — она такая навсегда. Остаётся лишь создать новую строку путём совершения некой операции над исходной строкой.

```js
let str = 'Hi';

str[0] = 'h'; // ошибка
alert(str[0]); // не работает
```

Можно создать новую строку и записать её в ту же самую переменную вместо старой.

**Пример:**

```js
let str = 'Hi';

str = 'h' + str[1]; // заменяем строку

alert(str); // hi
```

> [!WARNING]
>
> Используйте строки только для текстовых данных. Для составных структур преобразуйте строки в подобающие конструкции.

#### **5.1. Особенности:**

-   Конкатенация через `+` или шаблонные строки.
-   Получить часть исходной строки выборкой отдельных символов, либо применением метода [`String.substr()`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/substr).
-   Объединить две строки в одну, применив оператор (`+`) или метод [`String.concat()`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/concat).
-   Методы: `.length`, `.toUpperCase()`, `.toLowerCase()`, `.includes()`, `.slice()`.

#### **5.2. Кавычки**

В JavaScript есть разные типы кавычек.

Строку можно создать с помощью одинарных, двойных либо обратных кавычек:

```plaintext
let single = 'single-quoted';
let double = "double-quoted";
let backticks = `backticks`;
```

Одинарные и двойные кавычки работают, по сути, одинаково, а если использовать обратные кавычки, то в такую строку мы сможем вставлять произвольные выражения, обернув их в ${…}:

```js
function sum(a, b) {
    return a + b;
}

alert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.
```

Ещё одно преимущество обратных кавычек — они могут занимать более одной строки, вот так:

```js
let guestList = `Guests:

- John
- Pete
- Mary
  `;

alert(guestList); // список гостей, состоящий из нескольких строк
```

Выглядит вполне естественно, не правда ли? Что тут такого? Но если попытаться использовать точно так же одинарные или двойные кавычки, то будет ошибка:

```js
let guestList = "Guests: // Error: Unexpected token ILLEGAL

- John";
```

Одинарные и двойные кавычки в языке с незапамятных времён: тогда потребность в многострочных строках не учитывалась. Что касается обратных кавычек, они появились существенно позже, и поэтому они гибче.

> [!TIP]
>
> Обратные кавычки также позволяют задавать «шаблонную функцию» перед первой обратной кавычкой. Используемый синтаксис: **func`string`**. Автоматически вызываемая функция `func` получает строку и встроенные в неё выражения и может их обработать. Подробнее об этом можно прочитать в документации. Если перед строкой есть выражение, то шаблонная строка называется «теговым шаблоном». Это позволяет использовать свою шаблонизацию для строк, но на практике теговые шаблоны применяются редко.

#### **5.3. Примеры:**

```javascript
let single = 'Hello';
let double = 'World';
let template = `Привет, ${single} ${double}!`;

alert(`результат: ${1 + 2}`); // результат: 3
console.log(template); // Привет, Hello World!
console.log(single.length); // 5
console.log(single.toUpperCase()); // HELLO
```

#### **5.4. Спецсимволы**

Многострочные строки также можно создавать с помощью одинарных и двойных кавычек, используя так называемый «символ перевода строки», который записывается как `\n`:

```js
let guestList = 'Guests:\n * John\n * Pete\n * Mary';

alert(guestList); // список гостей, состоящий из нескольких строк
```

В частности, эти две строки эквивалентны, просто записаны по-разному:

```js
// перевод строки добавлен с помощью символа перевода строки
let str1 = 'Hello\nWorld';

// многострочная строка, созданная с использованием обратных кавычек
let str2 = `Hello
World`;

alert(str1 == str2); // true
```

Есть и другие, реже используемые спецсимволы. Вот список:

| Символ        | Описание                                                                                                                                                                                                |
| ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| \n            | Перевод строки                                                                                                                                                                                          |
| \r            | В текстовых файлах Windows для перевода строки используется комбинация символов `\r\n`, а на других ОС это просто `\n`. Это так по историческим причинам, ПО под Windows обычно понимает и просто `\n`. |
| \\', \\", \\` | Кавычки                                                                                                                                                                                                 |
| \\\           | Обратный слеш                                                                                                                                                                                           |
| \t            | Знак табуляции                                                                                                                                                                                          |
| \b, \f, \v    | Backspace, Form Feed и Vertical Tab — оставлены для обратной совместимости, сейчас не используются.                                                                                                     |

Как вы можете видеть, все спецсимволы начинаются с обратного слеша, `\` — так называемого «символа экранирования».

Он также используется, если необходимо вставить в строку кавычку.

**Пример:**

```plaintext
alert('I\'m the Walrus!'); // I'm the Walrus!
alert("Say \"Hello\""); // Say "Hello"
```

но более красивый вариант использовать в таком случае разнородные кавычки

```js
alert("I'm the Walrus!"); // I'm the Walrus!
alert('Say "Hello"'); // Say "Hello"
```

#### **5.5. Приведение типов**

-   Используйте метод `String(value)` или конкатенацию с пустой строкой.

```javascript
let num = 123;
console.log(String(num)); // "123"
console.log(num + ''); // "123"

let value = true;
console.log(typeof value); // boolean
value = String(value); // теперь value это строка "true
console.log(typeof value); // string
```

#### **5.6. Получение части строки**

В JavaScript получение части строки или выборка отдельных символов может быть выполнена несколькими способами. Рассмотрим их подробнее с примерами.

Получить символ, который занимает позицию `pos`, можно с помощью квадратных скобок: `[pos]`.

1. **Использование метода `charAt`**

    Метод возвращает символ по указанному индексу строки.

    ```javascript
    const str = 'JavaScript';
    const char = str.charAt(4); // Индексация начинается с 0
    console.log(char); // "S"
    ```

2. **Использование метода `at`**

    Получить символ, который занимает позицию `pos` можно используя метод `str.at(pos)`. Первый символ занимает нулевую позицию.

    ```js
    let str = `Hello`;

    // получаем первый символ
    alert(str.at(0)); // H

    // получаем последний символ
    alert(str.at(-1)); // o
    ```

    Как вы можете видеть, преимущество метода `.at(pos)` заключается в том, что он допускает отрицательную позицию. Если `pos` – отрицательное число, то отсчет ведется от конца строки.

    Таким образом, `.at(-1)` означает последний символ, а `.at(-2)` – тот, что перед ним, и т.д.

3. **Обращение к строке как к массиву**

    В современных версиях JavaScript можно использовать синтаксис квадратных скобок для доступа к символу. Квадратные скобки всегда возвращают undefined для отрицательных индексов.

    ```javascript
    const str = 'JavaScript';
    const char = str[4];
    alert(str[-2]); // undefined
    console.log(char); // "S"
    ```

4. **Извлечение подстроки с помощью `substring`**

    Метод возвращает подстроку между двумя индексами.

    ```javascript
    const str = 'JavaScript';
    const substr = str.substring(4, 10); // Индекс начала включается, а конец — нет
    console.log(substr); // "Script"
    ```

5. **Использование метода `substr` (устарел)**

    Метод возвращает часть строки, начиная с указанного индекса и заданной длины. Этот метод устарел, но всё ещё работает.

    ```javascript
    const str = 'JavaScript';
    const substr = str.substr(4, 6); // Начинаем с индекса 4 и берём 6 символов
    console.log(substr); // "Script"
    ```

6. **Извлечение с помощью `slice`**

    Метод похож на `substring`, но поддерживает отрицательные индексы.

    ```javascript
    const str = 'JavaScript';
    const substr = str.slice(4, -1); // С 4-го символа до предпоследнего
    console.log(substr); // "Scrip"
    ```

7. **Доступ к последнему символу строки**

    Для получения последнего символа можно использовать длину строки.

    ```javascript
    const str = 'JavaScript';
    const lastChar = str[str.length - 1];
    console.log(lastChar); // "t"
    ```

8. **Получение нескольких символов с помощью `split`**

    Если нужно получить массив символов, можно использовать `split`.

    ```javascript
    const str = 'JavaScript';
    const chars = str.split(''); // Разбиваем строку на массив символов
    console.log(chars[4]); // "S"
    console.log(chars); // ["J", "a", "v", "a", "S", "c", "r", "i", "p", "t"]
    ```

9. **Получение символов с помощью `for..of`**

    Также можно перебрать строку посимвольно, используя `for..of`:

    ```js
    for (let char of 'Hello') {
        alert(char); // H,e,l,l,o (char — сначала "H", потом "e", потом "l" и т.д.)
    }
    ```

10. **Итог**

    Выбор способа зависит от ваших потребностей:

    - Для извлечения отдельного символа: `charAt` или `[]`.
    - Для извлечения подстроки: `substring`, `slice` или (в редких случаях) `substr`.
    - Для работы с массивами символов: `split`.

### 6. **Логический тип (Boolean)**

Логическое (или булевое) значение - это примитивный тип данных, который может содержать в себе `true` или `false` (истина или ложь). JavaScript использует приведение типа, чтобы привести значение к `true\false`. Есть явные и скрытые методы преобразования значений в их логические аналоги.

```js
let nameFieldChecked = true; // да, поле отмечено
let ageFieldChecked = false; // нет, поле не отмечено
```

Булевые значения также могут быть результатом сравнений:

```js
let isGreater = 4 > 1;

alert(isGreater); // true (результатом сравнения будет "да")
```

**Используется:**

-   В условиях (`if`, `while`).
-   В логических операциях (`&&`, `||`, `!`).

**Приведение типов**

-   `Boolean()` - это глобальная функция, которая конвертирует значение, переданное в него, в логическое. Не стоит использовать его с ключевым словом `new` (`new Boolean`), т.к. это создает сущность Boolean, которая является объектом.
-   Двойное отрицание при помощи оператора `!`. Двойной оператор `!!` действует следующим образом: первый знак `!` приводит значение к логическому и инвертирует его. Например, `!true` равняется `false`. Второй оператор `!` снова инвертирует полученное значение. В нашем примере `!false` приравнивается к `true`.

Значения, приводимые к `false`: `false`, `0`, `""`, `null`, `undefined`, `NaN`. Всё остальное — `true`.

```js
// False
Boolean(false); // false
Boolean(undefined); // false
Boolean(null); // false
Boolean(!!null); // false
Boolean(''); // false
Boolean(NaN); // false
Boolean(0); // false
Boolean(-0); // false
Boolean(0n); // false
// True
Boolean(true); // true
Boolean('hi'); // true
Boolean(1); // true
Boolean([]); // true
Boolean([0]); // true
Boolean([1]); // true
Boolean({}); // true
Boolean({ a: 1 }); // true
```

**Пример:**

```javascript
let isOnline = true;
let hasAccess = false;

console.log(isOnline && hasAccess); // false
console.log(isOnline || hasAccess); // true
console.log(!isOnline); // false
```

### 7. **Тип `null`**

Тип **`null`** — это примитивный тип данных в JavaScript, представляющий **отсутствие какого-либо значения**. Он используется, чтобы явно указать, что переменная или свойство не имеет значения. Оно формирует отдельный тип, который содержит только значение `null`.

В JavaScript `null` не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках.

**Особенности:**

-   Присваивается вручную, чтобы показать отсутствие значения.
-   Все JavaScript-программисты давно привыкли к тому, что `typeof null === 'object'; // true`, хотя фактически null — примитивное значение. Многие знают, что это баг, и лично Брэндан Айк это [признает](http://wiki.ecmascript.org/doku.php?id=harmony:typeof_null). Этот баг, вероятно, никогда не будет исправлен из-за необходимости сохранения обратной совместимости существующего кода с новыми версиями языка.

**Пример:**

```javascript
let user = null;
console.log(user); // null
console.log(typeof user); // "object" (ошибка языка)
```

#### **7.1. Характеристики `null`**

1. **Тип `null` — примитивный**

    - Это один из семи примитивных типов данных в JavaScript.
    - Несмотря на это, вызов `typeof null` возвращает `"object"`, что является исторической ошибкой языка.

    ```javascript
    console.log(typeof null); // "object" (ошибка в спецификации)
    ```

2. **`null` не то же самое, что `undefined`**

    - `null` означает, что значение явно отсутствует.
    - `undefined` означает, что значение переменной не определено.

    **Пример:**

    ```javascript
    let a = null; // Явно указано, что значения нет
    let b; // Значение не задано

    console.log(a); // null
    console.log(b); // undefined
    ```

#### **7.2. Использование `null`**

1. **Инициализация переменных**

    - Используется, чтобы явно указать, что переменная не имеет значения, но будет использоваться позже.

    ```javascript
    let user = null;
    // Позже переменной может быть присвоено значение
    user = 'John';
    ```

2. **Сброс значения**

    - Можно сбросить значение переменной, чтобы указать, что оно больше не нужно.

    ```javascript
    let session = 'active';
    session = null; // Явно указано, что сессия завершена
    ```

3. **Проверка отсутствия данных**

    - Часто используется для проверки, когда значение отсутствует, особенно при работе с объектами или ответами от серверов.

    ```javascript
    const user = { name: null }; // Имя пользователя неизвестно
    if (user.name === null) {
        console.log('Имя не указано.');
    }
    ```

#### **7.3. Сравнение `null` с другими значениями**

1. **Сравнение с `null`**

    - `null` равен самому себе

    ```javascript
    console.log(null === null); // true
    console.log(null == null); // true
    ```

2. **Сравнение с `undefined`**

    - При строгом равенстве (`===`), `null` и `undefined` разные.
    - При нестрогом равенстве (`==`), они считаются равными.

    ```javascript
    console.log(null === undefined); // false
    console.log(null == undefined); // true
    ```

3. **Сравнение с числами**

    - При численных операциях `null` приводится к `0`.

    ```javascript
    console.log(null + 5); // 5
    console.log(null > 0); // false
    console.log(null == 0); // false
    ```

4. **Сравнение с булевыми значениями**

    - `null` неявно приводится к `false` в булевом контексте.

    ```javascript
    if (!null) {
        console.log('null — ложное значение.'); // Будет выполнено
    }
    ```

#### **7.4. Приведение `null` к другим типам**

1. **К числу**

    - `null` становится `0`.

    ```javascript
    console.log(Number(null)); // 0
    ```

2. **К строке**

    - `null` становится строкой `"null"`.

    ```javascript
    console.log(String(null)); // "null"
    ```

3. **К булевому значению**

    - `null` становится `false`.

    ```javascript
    console.log(Boolean(null)); // false
    ```

#### **7.5. Пример: Использование `null` в реальном коде**

Инициализация объектов и проверка значений

```javascript
let user = {
    name: null,
    age: 25,
};

if (user.name === null) {
    console.log('Имя пользователя неизвестно.'); // Выполнится
}

user.name = 'Alice';

if (user.name !== null) {
    console.log(`Имя пользователя: ${user.name}`); // "Имя пользователя: Alice"
}
```

#### **7.6. Частые ошибки и проблемы**

1. **`typeof null` возвращает `"object"`**

    - Историческая ошибка JavaScript, которую нельзя исправить из-за обратной совместимости.

2. **Неправильное использование `null` и `undefined`**

    - Используйте `null` для явного указания отсутствия значения.
    - Оставляйте `undefined` для случаев, когда значение ещё не установлено.

3. **Сравнение с `==`**

    - Лучше всегда использовать строгое сравнение (`===`) для предотвращения неожиданных результатов.

    ```javascript
    console.log(null == undefined); // true (нестрогое равенство)
    console.log(null === undefined); // false (строгое равенство)
    ```

#### **Итог**

-   Тип `null` используется для явного указания отсутствия значения.
-   Он отличается от `undefined` (неопределённости).
-   Приведение `null` к другим типам происходит предсказуемо: `0` для числа, `"null"` для строки, `false` для булевого значения.
-   Важно помнить про особенности `typeof null` и избегать путаницы с `undefined`.

### 8. **Тип `undefined`**

Тип **`undefined`** — это примитивный тип данных в JavaScript, который обозначает отсутствие значения или его неопределённость. Когда переменная объявлена, но ей не присвоено значение, она имеет тип `undefined`.

Оно формирует тип из самого себя так же, как и `null`.

**Особенности:**

-   Появляется автоматически, если переменная или свойство объекта не инициализированы.

**Пример:**

```javascript
let x;
console.log(x); // undefined
console.log(typeof x); // "undefined"
```

Технически мы можем присвоить значение `undefined` любой переменной:

```js
let age = 123;

// изменяем значение на undefined
age = undefined;

alert(age); // "undefined"
```

…Но так делать не рекомендуется. Обычно `null` используется для присвоения переменной «пустого» или «неизвестного» значения, а `undefined` – для проверок, была ли переменная назначена.

#### **8.1. Характеристики `undefined`**

1. **Тип данных**

    - `undefined` является примитивным типом.
    - Переменная имеет значение `undefined`, если она объявлена, но не инициализирована.

    **Пример:**

    ```javascript
    let x;
    console.log(x); // undefined
    ```

2. **Автоматическое присвоение `undefined`**

    - Если переменной не присвоено значение, JavaScript автоматически даёт ей значение `undefined`.

    **Пример:**

    ```javascript
    function example() {}
    console.log(example()); // undefined (функция ничего не возвращает)
    ```

3. **`undefined` и тип данных**

    - Оператор `typeof` возвращает строку `"undefined"` для переменных с этим значением.

    **Пример:**

    ```javascript
    let y;
    console.log(typeof y); // "undefined"
    ```

#### **8.2. Где можно встретить `undefined`**

1. **Неинициализированные переменные**

    - Переменные, объявленные с помощью `var`, `let`, или `const`, но без значения, имеют значение `undefined`.

    **Пример:**

    ```javascript
    let a;
    console.log(a); // undefined
    ```

2. **Функции без `return`**

    - Если функция ничего не возвращает, её результат будет `undefined`.

    **Пример:**

    ```javascript
    function noReturn() {}
    console.log(noReturn()); // undefined
    ```

3. **Обращение к несуществующим свойствам объектов**

    - Если свойства объекта нет, результатом будет `undefined`.

    **Пример:**

    ```javascript
    const obj = {};
    console.log(obj.property); // undefined
    ```

4. **Элементы массива**

    - Если обратиться к несуществующему индексу массива, результатом будет `undefined`.

    **Пример:**

    ```javascript
    const arr = [1, 2, 3];
    console.log(arr[5]); // undefined
    ```

5. **Аргументы функции**

    - Если аргумент функции не передан, его значение будет `undefined`.

    **Пример:**

    ```javascript
    function greet(name) {
        console.log(name); // undefined, если не передать аргумент
    }
    greet();
    ```

#### **8.3. Разница между `undefined` и `null`**

| **Критерий**   | **`undefined`**                            | **`null`**                |
| -------------- | ------------------------------------------ | ------------------------- |
| **Тип данных** | Примитивный                                | Примитивный               |
| **Означает**   | Переменная объявлена, но не имеет значения | Явное отсутствие значения |
| **Назначение** | Присваивается автоматически                | Устанавливается явно      |
| **Пример**     | `let x; // undefined`                      | `let x = null; // null`   |

#### **8.4. Как избежать `undefined`**

1. **Инициализировать переменные**

    - Задавайте значения переменным при объявлении.

    **Пример:**

    ```javascript
    let x = 0;
    console.log(x); // 0
    ```

2. **Проверять аргументы функций**

    - Используйте значения по умолчанию для аргументов функций.

    **Пример:**

    ```javascript
    function greet(name = 'Гость') {
        console.log(`Привет, ${name}!`);
    }
    greet(); // "Привет, Гость!"
    ```

3. **Проверять наличие свойств**

    - Перед доступом к свойствам объекта используйте операторы проверки.

    **Пример:**

    ```javascript
    const obj = {};
    if ('property' in obj) {
        console.log(obj.property);
    } else {
        console.log('Свойства не существует');
    }
    ```

#### **8.5. Приведение `undefined` к другим типам**

1. **К числу**

    - Приводится к `NaN` (Not-a-Number).

    **Пример:**

    ```javascript
    console.log(Number(undefined)); // NaN
    ```

2. **К строке**

    - Приводится к строке `"undefined"`.

    **Пример:**

    ```javascript
    console.log(String(undefined)); // "undefined"
    ```

3. **К булевому значению**

    - Приводится к `false`.

    **Пример:**

    ```javascript
    console.log(Boolean(undefined)); // false
    ```

#### **8.6. Проверка на `undefined`**

1. **Сравнение с `undefined`**

    - Используйте строгое сравнение для проверки. Подходит только для объявленных переменных, если переменная не объявлена, то будет ошибка.

    **Пример:**

    ```javascript
    let x;
    if (x === undefined) {
        console.log('Переменная не инициализирована');
    }
    ```

2. **С помощью `typeof`**

    - Подходит для проверки переменных, которые могут не быть объявлены.

    **Пример:**

    ```javascript
    if (typeof someVar === 'undefined') {
        console.log('Переменная не определена');
    }
    ```

#### **8.7. Частые ошибки и проблемы**

1. **Использование неинициализированных переменных**

    - Может привести к неожиданному поведению.

    **Пример:**

    ```javascript
    let x;
    console.log(x + 1); // NaN
    ```

2. **Недостаточная проверка аргументов**

    - Если не проверять аргументы функций, это может привести к ошибкам.

    **Пример:**

    ```javascript
    function multiply(a, b) {
        return a * b;
    }

    console.log(multiply(5)); // NaN
    ```

3. **Путаница с `null`**
    - Убедитесь, что вы используете `undefined` для отсутствия значения, которое ещё не задано, и `null` для явного отсутствия значения.

#### **Итог**

-   Тип **`undefined`** указывает, что значение не определено или отсутствует.
-   Оно появляется в неинициализированных переменных, несуществующих свойствах объектов, пропущенных аргументах функций и других местах.
-   Избегайте использования `undefined` вручную. Вместо этого используйте `null` для явного указания отсутствия значения и проверяйте значения переменных, свойств и аргументов перед использованием.

### 9. **Символы (Symbol)**

Уникальные идентификаторы. Используются для создания уникальных свойств объектов. Символы являются нововведением JavaScript начиная с ECMAScript 2015. Символ — это **уникальное** и **иммутабельное** примитивное значение, которое может быть использовано как ключ для свойства объекта

**Особенности:**

-   Не равны друг другу, даже если имеют одинаковое описание.

**Пример:**

```javascript
let sym1 = Symbol('id');
let sym2 = Symbol('id');

console.log(sym1 === sym2); // false
console.log(typeof sym1); // "symbol"
```

### 10. **BigInt**

Тип данных для работы с большими числами, которые выходят за пределы `Number`.

> [!IMPORTANT]
>
> **Поддержка**
>
> В данный момент BigInt поддерживается только в браузерах Firefox, Chrome, Edge и Safari, но не поддерживается в IE.

Чтобы создать значение типа `BigInt`, необходимо добавить n в конец числового литерала или вызвать функцию `BigInt()`, которая создаст число типа `BigInt` из переданного аргумента. Аргументом может быть число, строка и др.

**Особенности:**

-   Добавляется суффикс `n` к числу.
-   Не смешивается с `Number`.

**Пример:**

```javascript
let big = 123456789012345678901234567890n;
let small = 10;
const sameBigint = BigInt('1234567890123456789012345678901234567890');
const bigintFromNumber = BigInt(10); // то же самое, что и 10n

console.log(big + 1n); // 123456789012345678901234567891n
// console.log(big + small); // Ошибка: нельзя смешивать BigInt и Number
```

#### **10.1. Математические операторы**

`BigInt` можно использовать как обычные числа, к примеру:

```js
alert(1n + 2n); // 3

alert(5n / 2n); // 2
```

Обратите внимание: операция деления `5/2` возвращает округлённый результат, без дробной части. Все операции с числами типа `bigint` возвращают `bigint`.

В математических операциях мы не можем смешивать `bigint` и обычные числа:

```js
alert(1n + 2); // Error: Cannot mix BigInt and other types
```

Мы должны явно их конвертировать: используя либо `BigInt()`, либо `Number()`, например:

```js
let bigint = 1n;
let number = 2;

// конвертируем number в bigint
alert(bigint + BigInt(number)); // 3

// конвертируем `bigint` в number
alert(Number(bigint) + number); // 3
```

Конвертирование `bigint` в число всегда происходит неявно и без генерации ошибок, но если значение `bigint` слишком велико и не подходит под тип `number`, то дополнительные биты будут отброшены, так что следует быть осторожными с такими преобразованиями.

> [!IMPORTANT]
>
> К `BigInt` числам нельзя применить унарный оператор `+`
>
> Унарный оператор `+value` является хорошо известным способом конвертировать произвольное значение `value` в число.
>
> Данный оператор не поддерживается при работе с `BigInt` числами:
>
> ```js
> let bigint = 1n;
>
> alert(+bigint); // Ошибка!
> ```
>
> Мы должны использовать `Number()` для преобразования `bigint` к `number`.

#### **10.2. Операции сравнения**

Операции сравнения, такие как `<`, `>`, работают с `bigint` и обычными числами как обычно:

```js
alert(2n > 1n); // true

alert(2n > 1); // true
```

Пожалуйста, обратите внимание, что обычные и `bigint` числа принадлежат к разным типам, они могут быть равны только при нестрогом сравнении `==`:

```js
alert(1 == 1n); // true

alert(1 === 1n); // false
```

#### **10.3. Логические операции**

В `if` или любом другом логическом операторе `bigint` число ведёт себя как обычное число.

К примеру, в `if bigint 0n` преобразуется в `false`, другие значения преобразуются в `true`:

```js
if (0n) {
    // никогда не выполнится
}
```

Логические операторы `||`, `&&` и другие также работают с `bigint` числами как с обычными числами:

```js
alert(1n || 2); // 1

alert(0n || 2); // 2
```

#### **10.4. Полифилы**

Создание полифила для `BigInt` – достаточно непростая задача. Причина в том, что многие операторы в JavaScript, такие как `+`, `-` и др., ведут себя по-разному с `bigint` по сравнению с обычными числами.

К примеру, деление `bigint` числа всегда возвращает `bigint` (округлённое при необходимости).

Чтобы эмулировать такое поведение, полифил должен будет проанализировать код и заменить все такие операторы на свои вызовы. Такая реализация будет тяжеловесной, не очень хорошей с точки зрения производительности.

Вот почему на данный момент нет хорошо реализованного полифила.

Существует обратное решение, предложеное разработчиками библиотеки **JSBI**.

Эта библиотека реализует большие числа, используя собственные методы. Мы можем использовать их вместо встроенных `BigInt`:

| Операция           | Встроенный      | BigInt JSBI             |
| ------------------ | --------------- | ----------------------- |
| Создание из number | a = BigInt(789) | a = JSBI.BigInt(789)    |
| Сложение           | c = a + b       | c = JSBI.add(a, b)      |
| Вычитание          | c = a - b       | c = JSBI.subtract(a, b) |

…А затем использовать полифил (плагин **Babel**) для замены вызовов **JSBI** на встроенные `Bigint` для браузеров, которые их поддерживают.

Другими словами, данный подход предлагает использовать **JSBI** вместо встроенных `BigInt`. **JSBI** внутри себя работает с числами как с `BigInt`, эмулирует их с соблюдением всех требований спецификации. Таким образом, мы можем выполнять JSBI-код в интерпретаторах, которые не поддерживают `Bigint`, а для тех, которые поддерживают – полифил преобразует вызовы в обычные `Bigint`.

### 11. **Отличие `Number` от `BigInt`**

`Number` и `BigInt` — это числовые типы данных в JavaScript, но они имеют различия в назначении, представлении, возможностях и ограничениях.

#### **11.1. Диапазон значений**

1. **Number**

    - Основан на формате **IEEE 754 (64-битный)**, использует 53 бита для представления значащих цифр.
    - Диапазон:
        - Максимум: `±2**53−1` - `(9,007,199,254,740,991)`.
        - Числа за пределами этого диапазона теряют точность.

2. **BigInt**

    - Поддерживает произвольную длину числа.
    - Может представлять числа за пределами диапазона `Number` без потери точности.

    **Пример:**

    ```javascript
    let big = 1234567890123456789012345678901234567890n; // BigInt
    let num = 12345678901234567890; // Number (потеря точности)

    console.log(big); // 1234567890123456789012345678901234567890n
    console.log(num); // 12345678901234567168 (потеря точности)
    ```

#### **11.2. Тип данных**

-   `Number`: используется для чисел с плавающей точкой (дробные и целые).
-   `BigInt`: используется только для целых чисел.

**Пример:**

```javascript
let num = 1.23; // Допустимо для Number
let big = 10n; // Допустимо для BigInt
// let invalid = 1.23n; // Ошибка: BigInt не поддерживает дробные числа
```

#### **11.3. Операции и совместимость**

-   **Смешивание `Number` и `BigInt` недопустимо:**  
     Операции между `Number` и `BigInt` вызовут ошибку.
    ```javascript
    let big = 10n;
    let num = 5;
    // console.log(big + num); // Ошибка: нельзя смешивать BigInt и Number
    ```
-   **Приведение типов:**  
     Чтобы выполнить операции, нужно явно преобразовать тип.

    ```javascript
    let big = 10n;
    let num = 5;

    console.log(big + BigInt(num)); // 15n
    console.log(Number(big) + num); // 15
    ```

#### **11.4. Производительность**

-   `BigInt` работает медленнее, чем `Number`, из-за необходимости обработки произвольной длины числа.
-   Используйте `BigInt`, только если требуется точность для больших чисел.

#### **11.5. Специальные значения**

-   `Number` имеет значения `Infinity`, `-Infinity`, и `NaN`.
-   `BigInt` не поддерживает такие значения.

**Пример:**

```javascript
console.log(1 / 0); // Infinity (Number)
console.log(BigInt(1) / 0n); // Ошибка: деление на ноль
```

#### **11.6. Когда использовать BigInt?**

-   Если вы работаете с числами больше 253−12^{53} - 1.
-   Для вычислений, требующих высокой точности (например, криптография, работа с длинными идентификаторами).

#### **11.7. Сравнение с учетом особенностей**

| Особенность          | `Number`                       | `BigInt`                 |
| -------------------- | ------------------------------ | ------------------------ |
| Тип                  | Число с плавающей точкой       | Только целые числа       |
| Диапазон             | ±253−12^{53} - 1               | Ограничен только памятью |
| Потеря точности      | Да (за пределами диапазона)    | Нет                      |
| Специальные значения | `Infinity`, `-Infinity`, `NaN` | Не поддерживает          |
| Производительность   | Быстрее                        | Медленнее                |

### 12. **Объекты (Object)**

Объект (`Object`) — это один из ключевых типов данных в JavaScript, который используется для хранения коллекций данных и более сложных сущностей. Объекты создаются как наборы пар "ключ-значение", где ключами могут быть строки или символы, а значениями — любые данные.

**Пример:**

```javascript
let user = {
    name: 'Alice',
    age: 30,
};

console.log(user.name); // Alice
console.log(typeof user); // "object"
```

#### **12.1. Создание объектов**

1. **Литерал объекта**

    Самый простой способ создать объект — использовать фигурные скобки `{}`.

    ```javascript
    let person = {
        name: 'John',
        age: 30,
        isEmployed: true,
    };
    ```

2. **Конструктор `Object`**

    Используется редко, но иногда полезен.

    ```javascript
    let person = new Object();
    person.name = 'John';
    person.age = 30;
    ```

3. **С помощью `Object.create(proto)`**

    Создаёт объект с указанным прототипом.

    ```javascript
    let proto = { greet: () => console.log('Hello!') };
    let obj = Object.create(proto);
    obj.name = 'Alice';
    console.log(obj.greet()); // "Hello!"
    ```

#### **12.2. Доступ к свойствам**

1. **Точечная нотация**

    Используется, когда имя свойства известно и соответствует правилам идентификаторов.

    ```javascript
    console.log(person.name); // "John"
    ```

2. **Квадратные скобки**

    Позволяет работать с динамическими или невалидными именами свойств (например, с пробелами или символами).

    ```javascript
    console.log(person['name']); // "John"

    let key = 'age';
    console.log(person[key]); // 30
    ```

#### **12.3. Добавление, обновление и удаление свойств**

1. **Добавление и обновление**

    Можно просто присвоить значение свойству.

    ```javascript
    person.city = 'New York'; // добавление
    person.age = 31; // обновление
    console.log(person); // {name: "John", age: 31, isEmployed: true, city: "New York"}
    ```

2. **Удаление**

    Используйте оператор `delete`.

    ```javascript
    delete person.city;
    console.log(person); // {name: "John", age: 31, isEmployed: true}
    ```

#### **12.4. Перебор свойств объекта**

1. **`for...in`**

    Перебирает все перечисляемые свойства объекта.

    ```javascript
    for (let key in person) {
        console.log(`${key}: ${person[key]}`);
    }
    // name: John
    // age: 30
    // isEmployed: true
    ```

2. **`Object.keys()`**

    Возвращает массив ключей.

    ```javascript
    console.log(Object.keys(person)); // ["name", "age", "isEmployed"]
    ```

3. **`Object.values()`**

    Возвращает массив значений.

    ```javascript
    console.log(Object.values(person)); // ["John", 30, true]
    ```

4. **`Object.entries()`**

    Возвращает массив пар `[ключ, значение]`.

    ```javascript
    console.log(Object.entries(person)); // [["name", "John"], ["age", 30], ["isEmployed", true]]
    ```

#### **12.5. Копирование объектов**

1. **Поверхностное копирование с `Object.assign()`**

    ```javascript
    let clone = Object.assign({}, person);
    console.log(clone); // {name: "John", age: 30, isEmployed: true}
    ```

2. **Поверхностное копирование с оператором распространения (`...`)**

    ```javascript
    let clone = { ...person };
    console.log(clone); // {name: "John", age: 30, isEmployed: true}
    ```

3. **Глубокое копирование**

    Для вложенных объектов используйте `structuredClone()` или библиотеки вроде Lodash.

    ```javascript
    let deepClone = structuredClone(person);
    ```

#### **12.6. Методы объекта**

Объекты могут содержать методы — функции, которые являются свойствами объекта.

**Пример:**

```javascript
let person = {
    name: 'John',
    age: 30,
    greet() {
        console.log(`Hello, my name is ${this.name}`);
    },
};

person.greet(); // "Hello, my name is John"
```

#### **12.7. Специальные возможности и методы `Object`**

1. **`Object.freeze(obj)`**

    Замораживает объект: невозможно добавить, удалить или изменить свойства.

    ```javascript
    let frozen = Object.freeze({ name: 'John' });
    frozen.name = 'Alice'; // Ошибка в строгом режиме
    ```

2. **`Object.seal(obj)`**

    Запрещает добавление и удаление свойств, но изменение существующих разрешено.

    ```javascript
    let sealed = Object.seal({ name: 'John' });
    sealed.name = 'Alice'; // Работает
    delete sealed.name; // Ошибка в строгом режиме
    ```

3. **`Object.isFrozen(obj)` и `Object.isSealed(obj)`**

    Проверяют, заморожен или запечатан объект.

    ```javascript
    console.log(Object.isFrozen(frozen)); // true
    console.log(Object.isSealed(sealed)); // true
    ```

4. **`Object.getOwnPropertyDescriptors(obj)`**

    Возвращает описание всех свойств объекта.

    ```javascript
    console.log(Object.getOwnPropertyDescriptors(person));
    /*
    {
    name: {value: "John", writable: true, enumerable: true, configurable: true},
    age: {value: 30, writable: true, enumerable: true, configurable: true}
    }
    */
    ```

5. **`Object.hasOwn(obj, key)`**

    Проверяет, является ли свойство собственным (не из прототипа).

    ```javascript
    console.log(Object.hasOwn(person, 'name')); // true
    ```

#### **12.8. Прототипы и наследование**

Объекты могут наследовать свойства и методы через прототипы.

**Пример:**

```javascript
let animal = {
    eats: true,
    walk() {
        console.log('Animal walks');
    },
};

let rabbit = Object.create(animal);
rabbit.jumps = true;

console.log(rabbit.eats); // true (унаследовано)
rabbit.walk(); // "Animal walks"
```

#### **12.9. Пример практической работы с объектом**

```javascript
let car = {
    brand: 'Toyota',
    model: 'Camry',
    year: 2020,
    getInfo() {
        return `${this.brand} ${this.model}, ${this.year}`;
    },
};

console.log(car.getInfo()); // "Toyota Camry, 2020"

car.owner = 'John';
console.log(Object.keys(car)); // ["brand", "model", "year", "getInfo", "owner"]

delete car.year;
console.log(car); // {brand: "Toyota", model: "Camry", getInfo: [Function: getInfo], owner: "John"}
```

## **Практика**

### 1. **Область видимости и Hoisting**

#### Задача 1:

Глобальная и локальная область видимости
Что будет выведено в консоль? Объясните почему. Рассмотрите сценарий, где в одной области используется несколько переменных с одинаковыми именами, чтобы понять, как работает механизм поиска переменных в стеке областей видимости.
Что будет выведено в консоль? Объясните почему.

```js
let x = 10;

function example() {
    let x = 20;
    console.log(x);
}

example();
console.log(x);
```

#### Задача 2:

Область видимости в цикле
Что будет выведено в консоль?

```js
for (let i = 0; i < 3; i++) {
    console.log(i);
}

console.log(i); // ?
```

#### Задача 3:

Блоковая область видимости
Определите, что будет выведено в консоль:

```js
{
    let a = 5;
    const b = 10;
    var c = 15;
}

console.log(typeof a);
console.log(typeof b);
console.log(typeof c);
```

#### Задача 4:

Область видимости переменной `var`
Какой результат будет у этого кода?

```js
function testVarScope() {
    if (true) {
        var x = 5;
    }
    console.log(x);
}

testVarScope();
```

#### Задача 5:

Вложенные функции и области видимости
Какой результат будет у этого кода?

```js
function outer() {
    let outerVar = 'Я снаружи';

    function inner() {
        let innerVar = 'Я внутри';
        console.log(outerVar); // ?
        console.log(innerVar); // ?
    }

    inner();
    console.log(innerVar); // ?
}

outer();
```

### 2. **Hoisting**

#### **Задача 1:**

Поднятие переменных `var`
Что выведет этот код?

```js
console.log(a);
var a = 5;
```

#### **Задача 2:**

Поднятие функции
Объясните, что произойдёт:

```js
hello();

function hello() {
    console.log('Привет, мир!');
}
```

#### **Задача 3:**

Поднятие переменной `let`
Чем отличается выполнение этого кода от `var`?

```js
console.log(b);
let b = 10;
```

#### **Задача 4:**

Поднятие объявлений и инициализации
Что будет выведено?

```js
console.log(x);
var x = 5;
x = 10;
console.log(x);
```

#### **Задача 5:**

Поднятие функций и выражений
Какая ошибка произойдёт? Почему?

```js
greet();

var greet = function () {
    console.log('Привет!');
};
```

### 3. **Обработка строк**

#### **Сделать первый символ заглавным**

Напишите функцию `ucFirst(str)`, возвращающую строку `str` с заглавным первым символом. Например:

```js
ucFirst('вася') == 'Вася';
```

#### **Проверка на спам**

Напишите функцию `checkSpam(str)`, возвращающую `true`, если `str` содержит `'viagra'` или `'XXX'`, а иначе `false`.

Функция должна быть нечувствительна к регистру:

```js
checkSpam('buy ViAgRA now') == true;
checkSpam('free xxxxx') == true;
checkSpam('innocent rabbit') == false;
```

#### **Усечение строки**

Создайте функцию `truncate(str, maxlength)`, которая проверяет длину строки `str` и, если она превосходит `maxlength`, заменяет конец `str` на `"…"`, так, чтобы её длина стала равна `maxlength`.

Результатом функции должна быть та же строка, если усечение не требуется, либо, если необходимо, усечённая строка.

**Пример:**

```js
truncate("Вот, что мне хотелось бы сказать на эту тему:", 20) = "Вот, что мне хотело…"

truncate("Всем привет!", 20) = "Всем привет!"
```

#### **Выделить число**

Есть стоимость в виде строки `"$120"`. То есть сначала идёт знак валюты, а затем – число.

Создайте функцию `extractCurrencyValue(str)`, которая будет из такой строки выделять числовое значение и возвращать его.

**Пример:**

```js
alert(extractCurrencyValue('$120') === 120); // true
```

---
