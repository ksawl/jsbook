# **1.2. Подключение CSS, селекторы и свойства**

> [Home](../readme.md)
> || [A1](./0%20Index.md)

---

**Cascading Style Sheets (CSS)** — Каскадная Таблица Стилей, это язык описания визуального оформления документа, используется для стилизации HTML-документов. С его помощью можно задавать визуальное представление элементов на веб-странице, таких как цвет, шрифт, отступы, расположение и многое другое. Он отделяет структуру документа от его визуального представления, что позволяет централизованно управлять стилями, улучшать поддержку и обеспечивать единообразный дизайн.

CSS базируется на принципах, определяющих приоритетность применения стилей, это каскадность,наследование и специфичность. Эти принципы позволяют разработчикам создавать гибкие системы оформления, где одни правила могут быть переопределены другими в зависимости от источника, порядка подключения и дополнительных директив. Таким образом разработчик может понижать уровень абстракции применения стилей, переопределяя стили от общих к конкретным.

## |1| **Подключение CSS к HTML**

CSS можно подключить к HTML-документу несколькими способами: встроенные стили, внутренние стили с помощью тега `<style>`, и внешние файлы стилей `.css`. При одновременном использовании нескольких источников стилей действуют правила каскада, определяющие, какой стиль имеет приоритет.

### 1. **Каскадность - приоритеты подключения CSS**

Каскадные таблицы стилей (CSS) названы так потому, что правила стилизации в CSS применяются к элементам веб-страницы по принципу **каскада**.

**Каскадность (cascading)** — это один из фундаментальных принципов CSS. Этот принцип позволяет управлять **порядком применения стилей**, когда для одного и того же элемента могут быть определены разные стили из **различных источников**.

Название "каскадность" (англ. _cascade_) происходит от идеи, что стили "каскадом", по очереди, накладываются друг на друга. Этот принцип помогает браузерам определить, какие стили должны применяться при возникновении конфликтующих правил в конкретных ситуациях. Существует четко определённый порядок определения итоговых значений свойств.

Основная идея заключается в следующем:

-   **Множественные источники стилей** могут определять значения для одного и того же свойства элемента.
-   **Браузер объединяет** все эти правила и выбирает то, которое будет применено, руководствуясь заранее установленными принципами.

#### **1.1. Основные принципы каскадности**

Каскадность — это система, позволяющая объединять стили, заданные из разных источников (например, inline-стили, встроенные стили в документе и внешние таблицы стилей), и определять итоговое значение CSS-свойства для конкретного элемента. Она основана на трёх основных принципах:

1. **Источник стилей** (origin).
2. **Важность** (importance).
3. **Порядок объявления** (order of appearance).

Каскадность позволяет создавать гибкие и легко управляемые стили, которые могут переопределяться или наследоваться в зависимости от контекста.

#### **1.2. Приоритеты источников стилей**

Источник стилей определяет, откуда берутся CSS-правила и способ подключения влияет на приоритетность правил. Приоритет имеет значение в случаях переопределения или конфликта правил. CSS использует несколько уровней приоритета для определения, какие стили должны применяться, когда есть конфликт между правилами. Если несколько стилей влияют на один и тот же элемент, применяются стили с более высоким приоритетом. Рассмотрим источники стилей в порядке возрастания приоритета.

1. **Стили браузера (user agent stylesheet)**
   Имеют самый низкий приоритет. Каждый браузер имеет встроенный набор стилей, которые применяются к HTML-элементам, если для них не заданы другие стили.
   Например, заголовки (`<h1>`-`<h6>`) имеют жирный шрифт и разные размеры по умолчанию.

2. **Пользовательские стили:**  
   Иногда пользователи могут задавать собственные стили (например, через настройки браузера или пользовательские файлы CSS), которые будут применяться к странице.

3. **Авторские стили:**  
   Это стили, определённые разработчиками сайта. Они могут быть представлены в виде:

    1. **Внешние стили**
       Имеют наименьший приоритет, но они могут быть переопределены внутренними или встроенными стилями.

        Правила из внешнего файла применяются согласно общим правилам специфичности CSS. Они имеют более низкий приоритет, чем inline-стили, и, как правило, равны встроенным стилям (если селекторы идентичны). Однако **порядок подключения файлов** и **порядок объявления правил** в файле определяют, какое правило будет применено в случае конфликта.

    2. **Внутренние стили**
       Имеют средний приоритет и переопределяют стили из внешних файлов в том случае, если у них выше приоритет по подключению (порядок объявления в файле) или по специфичности.

    3. **Встроенные стили**
       Имеют наивысший приоритет и переопределяют любые другие стили (внутренние или внешние).

        Inline-стили имеют высокий уровень специфичности. Они переопределяют стили, заданные во внешних или встроенных таблицах стилей, за исключением случаев, когда другие правила используют директиву `!important`. Таким образом, при конфликте правил стили, прописанные в атрибуте `style`, будут иметь приоритет над другими источниками, если только внешние стили не содержат `!important`.

Каждый из этих источников участвует в процессе каскадирования. В конечном итоге браузер собирает все доступные декларации и решает, какие из них применить к элементу.

**Пример приоритетов источников**

```css
/* file: `styles.css` */
h1 {
    color: blue; /* Внешний стиль заголовка */
}
p {
    color: blue; /* Внешний стиль параграфа */
}
```

```html
<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="UTF-8" />
        <title>Пример приоритетов CSS</title>
        <style>
            h1 {
                color: green; /* Внутренний стиль заголовка */
            }
        </style>
        <link rel="stylesheet" href="styles.css" />
        <style>
            p {
                color: green; /* Внутренний стиль параграфа */
            }
        </style>
    </head>
    <body>
        <h1>Заголовок</h1>
        <p>Это параграф с внутренним стилем.</p>
        <p style="color: red;">Это параграф с встроенным стилем.</p>
    </body>
</html>
```

_Объяснение:_

-   Внешний файл `styles.css` содержит стили для `<p>` и для `h1`
-   Внутренние стили, определенные в тегах `<style>`, задают цвет `green` для параграфов и для заголовков, но очередность объявления разная.
-   К параграфу без встроенного стиля применится стиль из внутреннего объявления и задаст цвет `green`.
-   Встроенный стиль в теге `<p>` переопределяет все остальные стили и задает цвет `red`.
-   А для заголовка применится стиль из внешнего файла по приоритету порядка объявления и задаст цвет `blue`.

#### **1.3. Важность (importance)**

Правило с `!important` имеет самый высокий приоритет, независимо от специфичности, за исключением случаев, когда другое правило также содержит `!important` — тогда применяется правило с большей специфичностью.

#### **1.4. Каскадность и порядок применяемости**

CSS позволяет комбинировать стили из нескольких источников, и конечный вид элемента определяется результатом их каскадирования. При объединении правил браузер выполняет следующие шаги:

1. **Последовательность загрузки источников:**
    - Браузер сначала применяет базовые (дефолтные) стили, затем пользовательские стили (если они заданы), а после этого – авторские стили в порядке их приоритетности (внешние, встроенные, inline) применяются в указанном порядке.
    - Из всех источников (браузерные стили, пользовательские и авторские стили) собираются все определения для каждого свойства конкретного элемента.
    - Стили браузера > Стили пользователя > Авторские стили.
2. **Порядок подключения внешних файлов:**
    - Порядок, в котором стили подключены к HTML-документу, также влияет на их приоритет. Если одно и то же правило определено в нескольких местах, то правило, определенное последним, имеет более высокий приоритет, то есть применяется последнее объявленное правило. Это называется **"принципом последнего объявления"**.
    - Таким образом браузер определяет все стили, которые могут быть применены к элементу, учитывая их источник и порядок подключения.
3. **Inline-стили:**
    - Стили, прописанные непосредственно в атрибуте `style` элемента, считаются «наивысшим уровнем», если не участвует дополнительная директива `!important`. Такие стили применяются после всех внешних и встроенных правил, что позволяет задать окончательное оформление для конкретного элемента.
4. **Директива `!important`:**
    - Если какое-либо правило помечено директивой `!important`, оно «поднимается» над обычными правилами, позволяя принудительно задать итоговое значение свойства, поднимая его приоритет над другими правилами, даже если правило объявлено раньше или поступило из другого, более "низкого" источника.

Таким образом, итоговое оформление элемента определяется комбинацией источника стилей, порядка их подключения, а также наличия или отсутствия директивы `!important`. Этот механизм позволяет создавать гибкие и легко изменяемые системы оформления.

### 2. **Внешние файлы CSS**

Внешние документы CSS хранятся в отдельных файлах с расширением `.css` и подключаются к HTML-документу с помощью тега `<link>`, который также размещается в разделе `<head>`.

Рекомендованный способ для большинства проектов. Этот метод является наиболее гибким и масштабируемым. Используются для стилизации нескольких страниц. Поддерживают принцип разделения структуры (HTML) и стилей (CSS).

**Синтаксис:**

```html
<link rel="stylesheet" href="путь_к_файлу.css" />
```

**Пример:**

1. Создайте файл `styles.css`:

```css
/* file: `styles.css` */
p {
    color: red;
    font-size: 20px;
}
```

2. Подключите его в HTML:

```html
<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="UTF-8" />
        <title>Пример</title>
        <link rel="stylesheet" href="styles.css" />
    </head>
    <body>
        <p>Этот текст красный и имеет размер 20px.</p>
    </body>
</html>
```

**Преимущества:**

-   Удобны для поддержки, изменения стилей и масштабирования, так как один файл может использоваться на множестве страниц. Позволяют централизованно управлять стилями всего веб-сайта.
-   Уменьшают размер HTML-документа.
-   Позволяют разделить структуру документа и стили, что соответствует принципу «разделяй и властвуй».
-   Кэширование внешних файлов браузерами повышает производительность загрузки сайта.

**Недостатки:**

-   Требует создания отдельного файла.
-   Дополнительный HTTP-запрос может увеличить время загрузки страницы, если оптимизация (например, минификация и объединение файлов) не реализована.
-   При динамической генерации контента может потребоваться дополнительная логика для корректного подключения внешних стилей.

### 3. **Внутренние стили с использованием тега `<style>`**

Внутренние стили задаются внутри тега `<style>`, который размещается в разделе `<head>` HTML-документа. Используются для стилизации одной страницы. Удобны для небольших проектов или тестирования.

**Синтаксис:**

```html
<style>
    селектор {
        свойство: значение;
    }
</style>
```

**Пример:**

```html
<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="UTF-8" />
        <title>Пример внутренних стилей</title>
        <style>
            body {
                font-family: Arial, sans-serif;
            }
            h1 {
                color: blue;
                text-align: center;
            }
            p {
                font-size: 18px;
                color: red;
            }
        </style>
    </head>
    <body>
        <h1>Заголовок с внутренними стилями</h1>
        <p>Это параграф с внутренними стилями.</p>
    </body>
</html>
```

**Преимущества:**

-   Все стили находятся в одном месте, что упрощает просмотр и модификацию правил для текущей страницы.
-   Легче обновлять и поддерживать стили по сравнению с встроенными стилями.
-   Удобно при работе над небольшими проектами или при быстром прототипировании.

**Недостатки:**

-   В случае большого объёма стилей HTML-файл может значительно увеличиться, что затрудняет поддержку.
-   Повторное использование стилей на нескольких страницах требует копирования кода, что нарушает принцип **DRY** (Don’t Repeat Yourself).
-   Приоритет встроенных стилей ниже, чем inline-стилей, но выше, чем у внешних файлов, если не учитывать порядок подключения.

### 4. **Встроенные стили (Inline Styles)**

Встроенные стили задаются непосредственно в теге HTML-элемента с использованием атрибута `style`. Этот метод применяется, когда нужно задать стили для конкретного элемента. Удобны для быстрого добавления стилей конкретному элементу, но не рекомендуются для массового использования, так как усложняют поддержку кода.

**Синтаксис:**

```html
<элемент style="свойство: значение;">
```

**Пример:**

```html
<p style="color: blue; font-size: 16px;">
    Этот текст синий и имеет размер 16px.
</p>
```

**Преимущества:**

-   Быстро и легко применять стили к конкретным элементам.
-   Подходит для тестирования и временных изменений.
-   Высокий приоритет (переопределяет другие стили).
-   Подходят для динамического изменения стилей через JavaScript (например, `element.style`).

**Недостатки:**

-   Не подходят для глобального применения стилей.
-   Затрудняют повторное использование стилей.
-   Нарушает принцип разделения структуры (HTML) и стилей (CSS).
-   Усложняют поддержку и масштабирование проекта, поскольку стили прописаны прямо в HTML-коде и применяются к отдельному элементу.
-   Имеют самый высокий приоритет, что может затруднить переопределение стилей в случае необходимости.

### 5. **Директива `!important`**

> [!WARNING]
>
> Директива `!important` — это не "волшебная палочка", а инструмент, который следует применять осознанно и только тогда, когда это действительно необходимо.

Директива `!important` — это специальное ключевое слово в CSS, которое можно добавить к правилу стиля, чтобы повысить его приоритет. Позволяет переопределить стандартные правила приоритета и специфичности. Когда правило объявлено с `!important`, оно получает наивысший приоритет в каскаде по сравнению с другими правилами, даже если селекторы имеют более высокую специфичность или правила объявлены позже. Однако её использование требует осторожности, так как злоупотребление `!important` может привести к сложностям в поддержке кода.

**Синтаксис:**

```css
свойство: значение !important;
```

**Пример:**

```css
p {
    color: red !important;
}
```

_Объяснение:_

В этом примере текст всех элементов `<p>` будет красным, даже если другие стили пытаются изменить цвет.

#### **6.1. Иерархия приоритетов с `!important`**

Директива `!important` изменяет обычный порядок, делая правило приоритетным независимо от специфичности селектора и порядка объявления. Однако если несколько правил с `!important` конкурируют, то применяется правило с более высокой специфичностью, а при равной специфичности — последнее объявленное.

> [!WARNING]
>
> `!important` переопределяет все стандартные приоритеты и специфичность. Если правило содержит `!important`, оно будет применено, даже если другие стили имеют более высокий приоритет.

1. **Inline-стили с `!important`**  
   Inline-стили имеют очень высокую специфичность, и если они содержат `!important`, они почти всегда побеждают.
2. **Правила с `!important` из внешних или встроенных стилей**  
   При сравнении двух правил, оба из которых имеют `!important`, их приоритет определяется:

    - **Источником стилей:**
        - Встроенные стили с `!important` > Внутренние стили с `!important` > Внешние стили с `!important`.
    - **Специфичностью селекторов:**
        - Если источники одинаковы, применяется правило с более высокой специфичностью.
        - ID > Классы/атрибуты/псевдоклассы > Элементы/псевдоэлементы.
    - **Порядком объявления:**
        - Если два правила имеют одинаковую специфичность, применяется последнее объявленное правило.

    ```css
    p {
        color: red !important; /* Применяется */
    }

    p {
        color: blue !important; /* Переопределяет предыдущее */
    }
    ```

3. **Правила без `!important`**  
   Они уступают всем правилам с директивой `!important`, даже если их специфичность выше.

#### **6.2. Примеры использования `!important`**

**Пример 1: Переопределение встроенных стилей**

```html
<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="UTF-8" />
        <title>Пример с !important</title>
        <link rel="stylesheet" href="styles.css" />
        <style>
            p {
                color: green !important;
            }
        </style>
    </head>
    <body>
        <p style="color: red;">
            Этот текст будет зеленым, несмотря на inline-стиль.
        </p>
    </body>
</html>
```

_Объяснение:_

1. Правило в блоке `<style>` имеет директиву `!important`, поэтому его значение цвета (зелёный) применяется независимо от значения, указанного в атрибуте `style` элемента `<p>`.
2. **Итог:** Текст отображается зелёным.

**Пример 2: Переопределение специфичности**

```html
<div id="content">
    <p class="text">Этот текст зеленый.</p>
</div>
```

```css
#content p {
    color: blue;
}

.text {
    color: green !important;
}
```

_Объяснение:_

Текст будет **зеленым**, так как `!important` переопределяет стиль, заданный через **ID**.

**Пример 3: Переопределение порядка объявления**

```css
p {
    color: red;
}

p {
    color: blue;
}
```

_Объяснение:_

Текст будет **синим**, так как второе правило переопределяет первое.

**Если добавить `!important`:**

```css
p {
    color: red !important;
}

p {
    color: blue;
}
```

_Объяснение:_

Текст будет **красным**, так как `!important` имеет приоритет.

#### **6.3. Когда использовать `!important`?**

`!important` следует использовать только в исключительных случаях, когда:

1. **Необходимо переопределить стили из внешних библиотек** (например, Bootstrap).
2. **Нужно быстро исправить проблему в существующем коде** (временное решение).
3. **Работа с инлайновыми стилями**,
   которые нельзя изменить (например, стили, генерируемые JavaScript).
4. **В крайних случаях**
   Директива `!important` следует применять только в ситуациях, когда нет возможности изменить исходную структуру селекторов или порядок подключения стилей (например, переопределение стилей сторонних библиотек).
5. **В целях отладки**
   Для быстрого тестирования можно временно использовать `!important`, но в финальном коде его применение должно быть минимизировано.

**Пример использования с библиотеками:**

```css
/* Переопределение стилей Bootstrap */
.btn {
    background-color: purple !important;
}
```

#### **6.4. Проблемы злоупотребления `!important`**

1. **Потеря гибкости**
   Переопределение стилей с помощью `!important` может привести к тому, что другие разработчики не смогут изменить стили без использования `!important`.
2. **Конфликты стилей**
   Если несколько правил используют `!important`, их приоритет определяется порядком объявления, что может привести к неожиданным результатам.
3. **Поддержка и масштабируемость**
   Чрезмерное использование `!important` затрудняет поддержку кода. Если каждое правило помечено как важное, каскад перестает работать корректно, и становится сложно понять, какие стили действительно применяются. Это усложняет внесение изменений в будущем, поскольку любое правило может оказаться переопределено.
4. **Повышение специфичности**
   Вместо `!important` лучше использовать более специфичные селекторы или изменить порядок подключения CSS-файлов, чтобы добиться нужного результата.

#### **6.5. Как избежать злоупотребления `!important`?**

1. **Увеличьте специфичность селекторов**
   Уточняйте селекторы, добавляя дополнительные классы или идентификаторы. Используйте более специфичные селекторы вместо `!important`.

    ```css
    /* Вместо */
    .menu {
        color: black;
    }
    /* Используйте */
    header .menu {
        color: black;
    }
    ```

2. **Используйте каскадность CSS**
   Подключите свои стили после стилей сторонних библиотек, чтобы они имели приоритет.
3. **Рефакторинг кода**
   Убедитесь, что стили не конфликтуют, и удалите лишние `!important`:

    - **Браузерные инструменты разработчика**  
      Современные браузеры (Chrome DevTools, Firefox Developer Tools) показывают, какие правила применяются к элементу, включая директивы `!important`. Это позволяет быстро обнаружить, какие стили были переопределены.
    - **Поиск по коду**  
      Используйте поиск по коду (например, через IDE или текстовый редактор), чтобы найти все вхождения `!important` и оценить, насколько их использование оправдано.

4. **Использование CSS-переменных**  
   В некоторых случаях переменные позволяют централизованно управлять значениями и избежать необходимости переопределять стили с `!important`.
5. **Минимизируйте применение:**  
   Старайтесь использовать `!important` только тогда, когда другие методы не дают желаемого результата. Это позволит сохранить чистоту и предсказуемость CSS-кода.
6. **Документируйте использование:**  
   Если применение `!important` неизбежно, оставляйте комментарии, поясняющие причины его использования. Это поможет другим разработчикам понять логику и избежать конфликтов в будущем.

### 7. **Заключение**

Механизм каскадности CSS представляет собой упорядоченную систему объединения стилей, в которой итоговое значение свойства элемента определяется по нескольким ключевым принципам:

-   **Порядок источников стилей** (от базовых браузерных до inline-стилей).
-   **Порядок подключения и расположение деклараций** в HTML-документе.
-   **Использование директивы `!important`** для принудительного переопределения правил.

CSS стили могут быть определены и применены к элементам различными способами, такими как встроенные стили, внутренние стили и внешние файлы стилей. При применении стилей учитываются следующие факторы:

-   **Встроенные стили:**
    -   Используются для стилизации конкретных элементов.
    -   Имеют наивысший приоритет.
    -   Затрудняют поддержку проекта.
    -   Избегайте использования встроенных стилей, если это возможно.
-   **Внутренние стили:**
    -   Определяются внутри тега `<style>`.
    -   Позволяют разместить стили в одном месте для всего документа.
    -   Подходят для стилизации одной страницы и небольших проектов.
-   **Внешние стили:**
    -   Подключаются через файл `.css`.
    -   Подходят для многократного использования и больших проектов для удобства поддержки и масштабирования.
    -   Позволяют централизовать стили, использовать кэширование и соблюдать принципы разделения структуры и представления.
    -   Порядок подключения внешних файлов `.css` также имеет значение: стили, подключенные позже, могут переопределять стили, подключенные ранее.
-   **Приоритеты:**
    -   Стили браузера > Внешние стили > Внутренние стили > Встроенные стили.
-   **Специфичность:**
    -   Определяет, какие стили будут применены при конфликте правил.
-   **Пересмотрите архитектуру стилей:**
    -   Если возникает необходимость часто использовать `!important`, возможно, стоит пересмотреть архитектуру и организацию CSS, улучшить селекторы и изменить порядок подключения файлов.

Понимание каскадности позволяет разработчикам эффективно управлять стилями и избегать конфликтов. Однако важно помнить, что каскадность — это только один из аспектов CSS, и её следует рассматривать в сочетании с другими принципами, такими как специфичность и наследование.

Благодаря каскадности разработчики могут комбинировать стили из различных источников, добиваясь требуемого визуального оформления при минимуме дублирования кода и обеспечивая возможность гибкого переопределения правил. Правильное понимание работы механизма каскадности является фундаментом для создания эффективных, масштабируемых и поддерживаемых CSS-систем.

---

## |2| **Базовые селекторы**

В CSS селекторы используются для определения элементов, к которым будут применяться стили.

Специфичность селекторов (_specificity_) в CSS — это механизм, который определяет, какие стилевые правила будут применены к элементу, если несколько селекторов претендуют на изменение одних и тех же свойств.

Каждый из этих селекторов имеет собственный «вес» в системе специфичности, то есть числовой показатель, который определяет, какое правило будет иметь преимущество, если несколько селекторов нацелены на один и тот же элемент.

Рассмотрим принципы работы с базовыми селекторами и их специфичность: `*`, `tag`, `.class`, `#id`.

### 1. **Универсальный селектор (`*`)**

Универсальный селектор `*` выбирает **все элементы** на странице или внутри указанного контекста. Он применяется, когда необходимо задать правило для каждого элемента независимо от его типа, класса или идентификатора. Это самый общий селектор с наименьшей специфичностью.

Часто используется для обнуления отступов или установки общих базовых стилей для всех элементов.

**Синтаксис:**

```css
* {
    свойство: значение;
}
```

**Пример:**

```css
* {
    margin: 0;
    padding: 0;
}
```

_Объяснение:_

В этом примере все элементы на странице будут иметь нулевые отступы и поля.

**Специфичность:**

-   **Вес:** (0, 0, 0, 0) `0` баллов (не влияет на специфичность других селекторов).
-   **Особенность:** Стили, заданные через `*`, имеют самый низкий приоритет.
-   **Переопределение:** Легко переопределяется любым другим селектором.

### 2. **Селектор по тегу (`tag`)**

Селекторы тегов выбирают элементы по их имени тега. Они имеют низкую специфичность и часто используются для стилизации всех элементов определенного типа (например, всех абзацев `<p>` или заголовков `<h1>`).

Используются для задания общих стилей для определённых HTML-элементов.

**Синтаксис:**

```css
tag {
    свойство: значение;
}
```

**Пример:**

```css
p {
    font-size: 16px;
    line-height: 1.5;
}
```

_Объяснение:_

В этом примере все элементы `<p>` будут иметь шрифт размера 16 пикселей и межстрочный интервал 1.5.

**Специфичность:**

-   **Вес:** (0, 0, 0, 1) `1` балл.
-   **Пример конфликта:**

    ```css
    * {
        color: red;
    } /* Универсальный селектор (вес 0) */
    p {
        color: blue;
    } /* Селектор по тегу (вес 1) */
    ```

    _Объяснение:_

    Текст в `<p>` будет синим, так как селектор по тегу имеет более высокую специфичность.

### 3. **Селектор по классу (`.class`)**

Селекторы классов выбирают элементы по значению атрибута `class`.

Применяются для группировки элементов с общими стилевыми характеристиками, что позволяет задавать им единый набор свойств.

**Синтаксис:**

```css
.class {
    свойство: значение;
}
```

**Пример:**

```css
.button {
    background-color: blue;
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 5px;
}
```

```html
<div class="button">Press me</div>
```

_Объяснение:_

Этот стиль применяется ко всем элементам, которые имеют класс `button`, задавая фон, цвет текста, отступы и стили границ.

**Специфичность:**

-   **Вес:** (0, 0, 1, 0) `10` баллов.
-   **Пример конфликта:**

    ```css
    p {
        color: blue;
    } /* Вес 1 */
    .text {
        color: green;
    } /* Вес 10 */
    ```

    ```html
    <p>Синий текст</p>
    <p class="text">Зеленый текст</p>
    ```

    _Объяснение:_

    Если элемент `<p>` имеет класс `text`, текст будет зеленым.

### 4. **Селектор по ID (`#id`)**

Селекторы идентификаторов выбирают элементы по значению атрибута `id`. Они имеют самую высокую специфичность среди базовых селекторов.

Используются для точного выбора конкретного элемента, поскольку значение `id` должно быть уникальным в пределах документа.

**Синтаксис:**

```css
#id {
    свойство: значение;
}
```

**Пример:**

```css
#header {
    background-color: #f8f8f8;
    padding: 20px;
    text-align: center;
}
```

```html
<div id="header">Header</div>
```

_Объяснение:_

Этот стиль применяется к элементу с идентификатором `header`, задавая фон, отступы и выравнивание текста.

**Специфичность:**

-   **Вес:** (0, 1, 0, 0) `100` баллов.
-   **Особенность:**
    -   ID должен быть уникальным в пределах страницы.
    -   Селектор по ID имеет наивысшую специфичность среди базовых селекторов.
-   **Пример конфликта:**

    ```css
    .text {
        color: green;
    } /* Вес 10 */
    #title {
        color: red;
    } /* Вес 100 */
    ```

    ```html
    <p id="title" class="text">Красный текст</p>
    ```

    _Объяснение:_

    Если элемент с `id="title"` имеет класс `text`, текст будет красным.

### 5. **Специфичность селекторов и порядок применения стилей**

**Специфичность** (_specificity_) — это численное значение, которое определяет приоритет, если несколько правил CSS конфликтуют на уровне селекторов. Специфичность селектора определяется его сложностью. Чем сложнее селектор, тем выше его специфичность.

Каждый селектор имеет определённую «весовую» характеристику. Inline-стили имеют наивысшую специфичность, затем следуют идентификаторы (ID), классы, псевдоклассы, атрибуты, затем элементные селекторы.

При равной специфичности последнее объявленное правило перезаписывает предыдущее.

**Специфичность селекторов**

Специфичность - это метод, используемый CSS для определения, какие стили будут применяться к элементу, если он подпадает под несколько правил. Специфичность основана на правилах селекторов и вычисляется по следующей системе баллов:

-   **Универсальный селектор `*`:** Имеет наименьшую специфичность (0, 0, 0, 0) 0 баллов.
-   **Селекторы тегов, элементы и псевдоэлементы (например, div, p):** Имеют низкую специфичность (0, 0, 0, 1). 1 балл
-   **Селекторы классов, атрибутов и псевдоклассов (например, .class, [type="text"], :hover):** Имеют среднюю специфичность (0, 0, 1, 0). 10 баллов.
-   **Селекторы идентификаторов (например, #id):** 100 баллов
-   **Встроенные стили (например, style="..."):** 1000 баллов

| Селектор      | Пример    | Вес (баллы) | Приоритет |
| ------------- | --------- | ----------- | --------- |
| Универсальный | `*`       | 0           | Низший    |
| Тег           | `p`       | 1           | Низкий    |
| Класс         | `.text`   | 10          | Средний   |
| ID            | `#header` | 100         | Высший    |

### 6. **Правила сравнения**

Браузер суммирует баллы всех селекторов и применяет стили с самой высокой специфичностью. Для расчета специфичности селектора необходимо сложить значения всех его составляющих.

1. Селектор с большим весом всегда переопределяет селектор с меньшим весом.
2. При равном весе применяется правило, объявленное **позже** в коде (но это уже связано с каскадностью).

**Например:**

```css
* {
    color: red;
} /* специфичность: 0 */
p {
    color: blue;
} /*специфичность: 1 */
.highlight {
    color: pink;
} /* специфичность: 10 */
#main-title {
    color: green;
} /* специфичность: 100 */
p.highlight {
    color: yellow;
} /* специфичность: 11 (1 + 10) */
#main-title p {
    color: orange;
} /* специфичность: 101 (100 + 1) */
```

```html
<span>Red text</span>

<p>Blue text</p>

<span class="highlight">Pink text</span>

<p class="highlight">Yellow text</p>

<div id="main-title">
    <span>Green text</span>
    <p>Orange text</p>
</div>
```

> [!TIP]
>
> **Важные замечания**
>
> 1. **Вложенность селекторов:**  
>    Комбинация селекторов (например, `div.text`) увеличивает специфичность, но в данном материале мы рассматриваем только одиночные селекторы.
> 2. **Инлайновые стили:**  
>    Стили, заданные через атрибут `style`, имеют специфичность `1000`, но они не относятся к базовым селекторам.
> 3. **`!important`:**  
>    Директива `!important` переопределяет любую специфичность, но её использование не рекомендуется из-за сложности поддержки кода.

### 6. **Примеры использования специфичности**

**Пример 1:**

```css
/* file: `styles.css` */
p {
    color: red; /* Специфичность 1 */
}
```

```html
<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="UTF-8" />
        <title>Пример специфичности селекторов</title>
        <link rel="stylesheet" href="styles.css" />
        <style>
            p {
                color: blue; /* Специфичность 1 */
            }
            .highlight {
                color: green; /* Специфичность 10 */
            }
            #important {
                color: orange; /* Специфичность 100 */
            }
        </style>
    </head>
    <body>
        <p id="important" class="highlight">
            Этот текст имеет уникальный ID и класс.
        </p>
    </body>
</html>
```

_Объяснение:_

Когда элемент подпадает под несколько правил, применяется правило с большей специфичностью.

1. Селектор тега `p` в `styles.css` задает красный цвет (специфичность 1).
2. Селектор тега `p` во встроенном стиле задает синий цвет (специфичность 1).
3. Классовый селектор `.highlight` задает зеленый цвет (специфичность 10).
4. Селектор идентификатора `#important` задает оранжевый цвет (специфичность 100).

Так как селектор идентификатора имеет наибольшую специфичность, текст в элементе `<p id="important" class="highlight">` будет оранжевым.

**Пример 2:**

```css
* {
    color: red;
} /* Вес 0 */
div {
    color: blue;
} /* Вес 1 */
.container {
    color: green;
} /* Вес 10 */
#main {
    color: yellow;
} /* Вес 100 */
```

```html
<div class="container" id="main">Текст</div>
```

_Объяснение:_

Текст будет **желтым**, так как `#main` имеет наивысшую специфичность.

**Пример 3:**

```css
p {
    color: blue;
} /* Вес 1 */
.text {
    color: green;
} /* Вес 10 */
```

```html
<p class="text">Абзац</p>
```

_Объяснение:_

Текст будет **зеленым**, так как класс имеет больший вес, чем тег.

### **Заключение**

Понимание принципов работы базовых селекторов в CSS и их специфичности является важным элементом в разработке качественных стилей, помогает управлять стилями и избегать конфликтов.

-   **Универсальный селектор (`*`)** имеет самый низкий вес и применяется ко всем элементам.
-   **Типовые селекторы (теговые селекторы)** добавляют минимальный вклад, позволяя задавать стили для конкретных HTML-элементов.
-   **Селекторы класса** существенно повышают специфичность, позволяя группировать элементы по общим характеристикам.
-   **Селекторы идентификатора** обладают самым высоким приоритетом, так как предназначены для уникального выбора элементов.

**Рекомендации по использованию базовых селекторов**

-   **Четкое планирование структуры:**  
    Используйте типовые селекторы для общих стилей элементов, а классы – для группировки элементов с общим визуальным оформлением. Селекторы идентификатора применяйте для уникальных элементов, требующих точного управления.
-   **Избегайте избыточного переопределения:**  
    Разумное распределение стилей между селекторами позволяет избежать конфликтов и упрощает поддержку кода. Планируйте использование классов и идентификаторов так, чтобы при комбинировании правил итоговая специфичность была понятна.
-   **Комбинирование селекторов:**  
    При необходимости объединяйте несколько селекторов в одном правиле для повышения точности выбора элементов, учитывая, что итоговая специфичность будет суммой значений отдельных селекторов.

Используя сравнительную таблицу и примеры вычисления специфичности, вы сможете четко определить, какие правила применяются к элементу, и эффективно управлять стилями в ваших проектах.

---

## |3| **Наследование (inheritance)**

**Наследование (inheritance)** — это механизм, при котором некоторые свойства элемента автоматически передаются от родительского элемента к его потомкам. Это означает, что если вы задали определенное свойство для родительского элемента, то это свойство автоматически будет применено и к его потомкам, если для них не задано собственное значение этого свойства. Например, если для контейнера задан цвет текста, то все текстовые элементы внутри него могут по умолчанию унаследовать этот цвет, что упрощает задание единого визуального стиля.

Это помогает уменьшить объем кода, что облегчает поддержку и упрощает оформление однородных блоков текста.

```html
<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="UTF-8" />
        <title>Пример наследования CSS</title>
        <style>
            body {
                font-family: Arial, sans-serif;
                color: blue;
            }
            div {
                font-size: 18px;
            }
        </style>
    </head>
    <body>
        <div>
            <p>Этот текст наследует шрифт и цвет от элемента body.</p>
        </div>
    </body>
</html>
```

_Объяснение:_

Шрифт Arial и синий цвет текста, заданные для элемента `body`, наследуются дочерним элементом `div` и его дочерним элементом `p`.

### 1. **Принципы наследования**

Не все CSS-свойства поддерживают наследование.

1. **Наследуемые свойства:**

    - Применяются к дочерним элементам без явного указания. Это значит, что если вы не задали значение для дочернего элемента, оно будет автоматически унаследовано от родительского.
    - По умолчанию наследуются преимущественно свойства, связанные со шрифтами и текстовым оформлением. К ним относятся: `color`,`font-family`,`font-size`,`font-style`,`font-weight`,`line-height`,`text-align`,`text-indent`,`visibility`.

2. **Ненаследуемые свойства:**
    - Требуют явного задания значения для дочерних элементов.
    - Многие свойства, касающиеся размеров, отступов, фона, границ, позиционирования и т. д., не наследуются. Это позволяет каждому элементу задавать свои размеры и оформление независимо от родительского блока. Примеры: `margin`, `padding`, `border`, `width`.

### 2. **Управление наследованием**

Кроме автоматического наследования, CSS предоставляет специальные значения для управления наследованием и инициализацией свойств.

-   **Принудительное наследование:**  
    Если требуется, чтобы не наследуемое свойство было применено и к потомкам, можно воспользоваться значением `inherit`:

    ```css
    div {
        border: 1px solid red;
    }
    p {
        border: inherit; /* Наследует значение border от родительского элемента */
    }
    ```

-   **Отмена наследования:**  
    С помощью значения `initial` можно сбросить свойство к его начальному значению, определённому спецификацией, или использовать `unset`.

### 3. **Ключевое слово `inherit`**

Значение `inherit` заставляет элемент явно взять значение указанного свойства у своего родительского элемента, вне зависимости от того, наследуется ли это свойство по умолчанию. То есть, даже если свойство обычно не наследуется, при использовании `inherit` оно будет скопировано от родителя. Работает только если родитель имеет явно заданное значение свойства.

**Сценарии использования:**

-   Используйте `inherit`, когда хотите, чтобы элемент явно получил значение свойства от родительского элемента. Это может быть полезно для согласования стилей между вложенными элементами, особенно если какое-то свойство по умолчанию не наследуется.

-   Сброс значений, заданных в пользовательских агентах (браузерах).

**Пример:**

```css
div {
    color: green;
}
span {
    color: inherit; /* Явное наследование от родительского элемента */
}
```

```html
<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="UTF-8" />
        <title>Пример использования inherit</title>
        <style>
            div {
                color: green;
            }
            span {
                color: inherit; /* Явное наследование от родительского элемента */
            }
        </style>
    </head>
    <body>
        <div>
            <p>Это текст абзаца <span>и выделенная часть текста</span>.</p>
        </div>
    </body>
</html>
```

_Объяснение:_

-   Элемент `span` внутри `div` будет наследовать зеленый цвет текста, заданный для `div`, несмотря на то, что `<span>` по умолчанию не наследует цвет от родителя.

### 4. **Ключевое слово `initial`**

Значение `initial` сбрасывает свойство до его **начального (дефолтного) значения**, определенного стандартом CSS. Это означает, что свойство будет сброшено к тому значению, которое назначено по умолчанию, независимо от того, было ли оно унаследовано от родителя или задано ранее. Игнорирует наследование и значения, заданные в родительских элементах.

**Сценарии использования:**

-   Используйте `initial`, когда необходимо сбросить заданные значения свойств и вернуть их к стандартным настройкам. Это полезно при создании компонентов, которые должны начинаться с чистого листа, без влияния ранее заданных стилей.

**Пример:**

```css
div {
    color: green;
}
p {
    color: initial; /* Сброс до начального значения */
}
```

```html
<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="UTF-8" />
        <title>Пример использования initial</title>
        <style>
            div {
                color: green;
            }
            p {
                color: initial; /* Сброс до начального значения */
            }
        </style>
    </head>
    <body>
        <div>
            <p>
                Этот текст не будет зеленым, а будет иметь начальное значение
                цвета.
            </p>
        </div>
    </body>
</html>
```

_Объяснение:_

-   Текст в элементе `p` внутри `div` не будет зеленым, а будет иметь начальное значение цвета, обычно это черный цвет.

### 5. **Ключевое слово `unset`**

Значение `unset` служит для «отмены» ранее заданного значения свойства. Оно действует следующим образом:

-   Если свойство обычно **наследуется**, то `unset` ведёт себя так же, как и `inherit` — элемент получает значение от родителя.
-   Если свойство **не наследуется** по умолчанию, то `unset` действует как `initial` — свойство сбрасывается к своему первоначальному значению.

**Сценарии использования:**

-   Универсальное решение для сброса стилей.
-   Применяйте `unset` для создания универсальных стилей, когда вы не уверены, наследуется ли свойство по умолчанию, или когда хотите, чтобы элемент получил «естественное» поведение для данного свойства без учета предыдущих установок.

**Пример:**

```css
div {
    color: green;
    font-size: 20px;
}
p {
    color: unset; /* Наследование, так как color наследуемое свойство */
    font-size: unset; /* Начальное значение, так как font-size ненаследуемое свойство */
}
```

```html
<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="UTF-8" />
        <title>Пример использования unset</title>
        <style>
            div {
                color: green;
                font-size: 20px;
            }
            p {
                color: unset; /* Наследование для color */
                font-size: unset; /* Начальное значение для font-size */
            }
        </style>
    </head>
    <body>
        <div>
            <p>
                Этот текст будет зеленым (наследует цвет) и имеет начальный
                размер шрифта.
            </p>
        </div>
    </body>
</html>
```

_Объяснение:_

-   Текст в элементе `p` внутри `div` будет зеленым, так как `color` наследуется.
-   Размер шрифта будет сброшен до начального значения (обычно 16 пикселей), так как `font-size` ненаследуемое свойство.

### **Заключение**

-   **Наследование** позволяет элементам получать значения свойств от своих родителей, что упрощает создание единого стиля для связанных блоков.
-   **`inherit`** используется для явного получения значения свойства от родителя, независимо от того, наследуется оно по умолчанию или нет.
-   **`initial`** сбрасывает свойство к начальному значению, определённому стандартом, что полезно для восстановления стандартных настроек.
-   **`unset`** действует универсально: если свойство обычно наследуется, оно ведёт себя как `inherit`, а если не наследуется — как `initial`.

---

## |4| **Правила нейминга идентификатора**

При создании селекторов для классов и идентификаторов (ID) в CSS необходимо соблюдать определённые правила и ограничения, прописанные в спецификации. Эти правила помогают избежать синтаксических ошибок, обеспечивают корректное применение стилей и способствуют поддерживаемости кода.

### 1. **Общие понятия**

Имена классов и идентификаторов являются так называемыми _идентификаторами_ (identifiers) в CSS. Они используются для точного выбора элементов и могут состоять из букв, цифр, дефисов, нижних подчеркиваний, а также других символов с использованием экранирования.

> [!TIP]
>
> **Главный принцип**
> Имя должно быть таким, чтобы другой разработчик мгновенно понял, за что отвечает элемент.

### 2. **Допустимые символы и структура идентификатора**

#### **2.1. Начало идентификатора**

-   **Начинаться с буквы или нижнего подчеркивания:**  
    Идентификатор может начинаться с латинской буквы (`A–Z` или `a–z`) или символа подчеркивания (`_`).

-   **Начинаться с дефиса:**  
    Идентификатор может начинаться с дефиса (`-`), но при этом рекомендуется, чтобы после него шла буква или подчеркивание, чтобы избежать неоднозначностей. Например, `-header` допустим, а `-1class` может вызвать проблемы.

#### **2.2. Последующие символы**

После первого символа идентификатор может содержать:

-   **Буквы:** латинские (`A–Z`, `a–z`).
-   **Цифры:** от `0` до `9`.
-   **Дефисы:** символ «`-`».
-   **Нижние подчеркивания:** символ «`_`».
-   **Дополнительные символы:** могут быть использованы и другие символы (например, точки, двоеточия), но они должны быть экранированы обратным слешем (`\`), чтобы не конфликтовать с синтаксисом CSS.

#### **2.3. Формальное определение (на основе CSS2)**

Формально идентификатор (`ident`) можно описать так:

-   **ident ::=** `[-]?{nmstart}{nmchar}*`

    где:

    -   **`[-]?`** – необязательный начальный дефис.
    -   **`{nmstart}`** – первый символ, который должен быть буквой (`A–Z` или `a–z`), символом, не входящим в ASCII, или экранированной последовательностью.
    -   **`{nmchar}`** – последующие символы, которые могут быть буквами, цифрами, дефисами или подчеркиваниями (а также символами, не входящими в ASCII, или экранированными последовательностями).

Это означает, что если идентификатор начинается с дефиса, то сразу после него должен следовать допустимый символ (буква или подчеркивание), иначе он может трактоваться неоднозначно.

#### **2.4. Стиль написания**

Используйте **кебаб-кейс** (слова через дефис) для улучшения читаемости:

-   `.user-profile`, `#search-results`.

Альтернативы (менее популярные):

-   **Верблюжий регистр:** `.userProfile`.
-   **Змеиный регистр:** `.user_profile` (редко используется в CSS).

### 3. **Практические рекомендации по неймингу**

#### **3.1. Выбор осмысленных имён**

-   **Понятность и семантика:**  
    Имена классов и ID должны отражать функцию или содержимое элемента. Например, `.header`, `.nav-item`, `#footer` — имена, говорящие о назначении элемента.

    -   ❌ Плохо: `.red`, `#big-text`, `.box`, `.item`.
    -   ✅ Хорошо: `.error-message`, `#main-navigation`, `.product-card`, `.news-item`.

-   **Единообразие:**  
    Придерживайтесь единого стиля именования во всём проекте. Популярны соглашения вроде BEM (Block-Element-Modifier), где имена выглядят, например, так: `.block__element--modifier`.

#### **3.2. Ограничения и недопустимые символы**

-   **Пробелы и спецсимволы:**  
    Пробелы, знаки препинания (кроме дефиса) и многие специальные символы использовать нельзя, если они не экранированы. Например, имя `.my class` недопустимо, так как содержит пробел. Если вам нужно использовать символ, например, точку, его нужно экранировать: `.my\.class`.

-   **Нельзя начинать с цифры:**  
    Идентификатор не должен начинаться с цифры. Например, `#123button` недопустим, если не использовать экранирование.

-   **Использование зарезервированных последовательностей:**  
    Некоторые слова или последовательности, которые могут быть восприняты как управляющие символы в CSS, следует избегать или корректно экранировать.

-   **Не злоупотребляйте ID**

    -   **Избегайте стилизации через ID:** ID имеют **высокую специфичность**, что усложняет переопределение стилей.
    -   **Уникальность:** Каждый ID должен быть единственным на странице. Используйте классы, если элемент не уникален.
    -   **Семантика:** Используйте ID для якорных ссылок или уникальных элементов:
        -   `#main-content`, `#footer`.

-   **Антипаттерны**
    -   **Избыточность:**
        -   ❌ `.navigation-menu` → ✅ `.nav`.
    -   **Привязка к контенту:**
        -   ❌ `.blue-button` (цвет может измениться) → ✅ `.primary-button`.
    -   **Слишком общие имена:**
        -   ❌ `.content` → ✅ `.user-profile-content`.

### 4. **Примеры**

**Допустимые имена:**

-   **Классы:**
    -   `.header`
    -   `.main-content`
    -   `.button_primary`
    -   `.nav-item`
-   **ID:**
    -   `#header`
    -   `#main`
    -   `#footer`
    -   `#sideBar`

**Недопустимые или проблемные имена:**

-   `#123button` – начинается с цифры (недопустимо без экранирования).
-   `.my class` – содержит пробел.
-   `#!important` – содержит спецсимвол «!» без экранирования.

### **Заключение**

Правильное именование классов и ID в CSS требует соблюдения следующих основных правил:

-   Идентификатор должен начинаться с буквы, нижнего подчеркивания или дефиса (при условии, что после дефиса следует буква или подчеркивание).
-   Последующие символы могут включать буквы, цифры, дефисы и подчеркивания; любые другие символы требуют экранирования.
-   Рекомендуется использовать осмысленные, короткие и логичные имена, придерживаясь единого стиля, что существенно упрощает поддержку и масштабирование проекта.

---

## |5| **Единицы измерения и цветовые форматы**

CSS (Cascading Style Sheets) предоставляет широкий выбор единиц измерения и цветовых форматов, которые используются для задания размеров элементов, шрифтов, отступов, цветов текста, фона и других свойств. Понимание этих единиц и форматов позволяет создавать гибкие и адаптивные дизайны.

### 1. **Единицы измерения в CSS**

CSS поддерживает несколько типов единиц измерения, которые делятся на абсолютные и относительные. Абсолютные единицы имеют фиксированный размер, а относительные единицы зависят от контекста. Правильный выбор единиц критичен для адаптивности и точности вёрстки.

#### **1.1. Абсолютные единицы**

Абсолютные единицы задают фиксированные значения, которые не зависят от каких-либо внешних параметров, таких как размер окна браузера или шрифт родительского элемента. Они идеальны для печатных документов, но могут быть менее гибкими для адаптивных дизайнов.

| Единица | Описание                                                                      | Пример                |
| ------- | ----------------------------------------------------------------------------- | --------------------- |
| `px`    | Пиксели. 1px ≈ 1/96 дюйма. **Физический размер зависит от плотности экрана.** | `width: 300px;`       |
| `pt`    | Пункты. 1pt = 1/72 дюйма. Используется в полиграфии.                          | `font-size: 12pt;`    |
| `in`    | Дюймы. 1 дюйм = 2.54 сантиметра.                                              | `margin: 0.5in;`      |
| `cm`    | Сантиметры. 1 сантиметр = 10 миллиметров.                                     | `height: 10cm;`       |
| `mm`    | Миллиметры.                                                                   | `padding: 5mm;`       |
| `pc`    | Пики. 1pc = 12pt. Также используются в полиграфии.                            | `line-height: 1.5pc;` |

**Особенности:**

-   Эти единицы используются реже в адаптивном дизайне, так как фиксированные размеры могут не масштабироваться должным образом на экранах с разными разрешениями.
-   `px` — самая популярная единица для точного позиционирования.
-   `pt`, `in`, `cm`, `mm` — редко используются в вебе, актуальны для медиа-запросов печати (`@media print`).

#### **1.2. Относительные единицы**

Относительные единицы позволяют создавать гибкие и адаптивные дизайны, поскольку их значение определяется относительно других параметров (например, размера родительского элемента или размеров окна браузера) и позволяют создавать гибкие и адаптивные дизайны.

| Единица | Описание                                                                                                                    | Пример               |
| ------- | --------------------------------------------------------------------------------------------------------------------------- | -------------------- |
| `%`     | Проценты. Обычно определяется от размера родительского элемента.                                                            | `width: 50%;`        |
| `em`    | Относится к **размеру шрифта родителя**. 1em = текущий `font-size`.                                                         | `margin: 2em;`       |
| `rem`   | Относится к **размеру шрифта корневого элемента** (`<html>`).                                                               | `font-size: 1.5rem;` |
| `vw`    | 1% ширины окна браузера.                                                                                                    | `width: 100vw;`      |
| `vh`    | 1% высоты окна браузера.                                                                                                    | `height: 50vh;`      |
| `vmin`  | 1% меньшей стороны окна (min(width, height)).                                                                               | `padding: 5vmin;`    |
| `vmax`  | 1% большей стороны окна (max(width, height)).                                                                               | `font-size: 3vmax;`  |
| `ex`    | Высота символа `x` в текущем шрифте.                                                                                        | `line-height: 2ex;`  |
| `ch`    | Относится к ширине символа "0" (ноль) в моноширинном шрифте, полезен для задания ширины, основанной на количестве символов. | `max-width: 60ch;`   |
| `lh`    | Высота строки текущего элемента.                                                                                            | `height: 2lh;`       |

**Особенности:**

-   **`em`:**
    -   Каскадное наследование: если родитель имеет `font-size: 2em`, а дочерний элемент `margin: 1.5em`, итоговый `margin` будет `3em` (относительно корневого элемента).
-   **`rem`:**
    -   Упрощает контроль масштаба. Если корневой элемент имеет `font-size: 16px`, то `1rem = 16px`.
-   **`vw/vh`:**
    -   Полезны для адаптивных элементов, занимающих всю высоту/ширину экрана.
    -   Учитывают область просмотра, включая полосу прокрутки.
-   **`ch`:**
    -   Используется для ограничения ширины текстовых блоков (например, `max-width: 60ch` для удобочитаемости).

**Рекомендации по выбору единиц измерения**

-   **Абсолютные единицы** лучше использовать для печатных документов, когда требуется точное соответствие размерам, или для задания минимальных и максимальных размеров.
-   Для размеров элементов, которые должны быть фиксированными, можно использовать `px`.
-   **Относительные единицы** предпочтительны в адаптивном дизайне, поскольку они позволяют элементам масштабироваться в зависимости от контекста (размер шрифта, размеры окна браузера).
-   Для размеров шрифта рекомендуется использовать `em` или `rem`, так как это обеспечивает масштабируемость и доступность.
-   Для адаптивного дизайна, когда размеры элементов должны меняться в зависимости от размера экрана, используйте `vw`, `vh` или `%`.

### 2. **Цветовые форматы в CSS**

CSS поддерживает несколько цветовых форматов, которые позволяют задавать цвета для элементов. Основные форматы включают ключевые слова, шестнадцатеричные значения, RGB, RGBA, HSL и HSLA. Выбор зависит от задач: прозрачность, читаемость кода, удобство настройки оттенков.

#### **2.1. Основные форматы**

| Формат        | Описание                                                                                                                             | Пример                              |
| ------------- | ------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------- |
| **HEX**       | Шестнадцатеричное представление. Формат: `#RRGGBB` или `#RGB` (сокращённый).                                                         | `color: #ff0000;` (красный)         |
| **RGB**       | Красный, зелёный, синий. Формат: `rgb(red, green, blue)`. Значения: 0–255 или 0%–100%.                                               | `background: rgb(255, 0, 0);`       |
| **RGBA**      | RGB с альфа-каналом Формат: `rgba(red, green, blue, alpha)`, где alpha — значение прозрачности от 0 до 1.                            | `background: rgba(255, 0, 0, 0.5);` |
| **HSL**       | Оттенок (_hue_): (0–360°), насыщенность (_saturation_): (0%–100%), светлота (_lightness_): (0%–100%).                                | `color: hsl(0, 100%, 50%);`         |
| **HSLA**      | HSL с альфа-каналом.                                                                                                                 | `color: hsla(0, 100%, 50%, 0.3);`   |
| **Имя цвета** | Предопределённые имена (например, `red`, `blue`). Всего 147 цветов. Список доступных названий цветов можно найти в спецификации CSS. | `border-color: tomato;`             |

**Особенности:**

-   **HEX:**
    -   Сокращённая запись: `#f00` → `#ff0000`.
    -   Не поддерживает прозрачность.
-   **RGB/RGBA:**
    -   `rgba(255, 0, 0, 0.5)` — красный с прозрачностью 50%.
-   **HSL/HSLA:**
    -   Интуитивнее для настройки оттенков. Например, изменение светлоты (`lightness`) делает цвет темнее или светлее.
    -   `hsl(0, 100%, 50%)` — красный, `hsl(0, 100%, 30%)` — тёмно-красный.

#### **2.2. Расширенные цветовые форматы (CSS Color Level 4+)**

| Формат    | Описание                                                                | Пример                           |
| --------- | ----------------------------------------------------------------------- | -------------------------------- |
| **HWB**   | Hue (тон), Whiteness (белизна), Blackness (чернота).                    | `color: hwb(0 0% 0%);` (красный) |
| **LAB**   | Основан на человеческом восприятии. L — светлота, a и b — цветовые оси. | `color: lab(50 40 -30);`         |
| **LCH**   | Lightness (светлота), Chroma (насыщенность), Hue (тон).                 | `color: lch(50 80 30);`          |
| **OKLAB** | Улучшенная версия LAB для более точных цветов.                          | `color: oklab(0.5 -0.1 0.2);`    |

**Особенности:**

-   **HWB:**
    -   Проще для понимания: `hwb(120deg 20% 10%)` — зелёный с 20% белизны и 10% черноты.
-   **LAB/LCH:**
    -   Охватывают больше цветов, чем sRGB (HEX/RGB).
    -   Поддерживаются в современных браузерах (Chrome 111+, Firefox 113+).
-   **OKLAB:**
    -   Более равномерное восприятие изменений цвета человеком.

#### **2.3. Сравнение форматов**

| Параметр         | HEX    | RGB/RGBA  | HSL/HSLA  | LAB/LCH      |
| ---------------- | ------ | --------- | --------- | ------------ |
| **Прозрачность** | Нет    | Да (RGBA) | Да (HSLA) | Да           |
| **Читаемость**   | Низкая | Средняя   | Высокая   | Высокая      |
| **Гибкость**     | Низкая | Средняя   | Высокая   | Максимальная |
| **Поддержка**    | Все    | Все       | Все       | Современные  |

#### **2.4. Рекомендации по выбору цветового формата**

-   **Шестнадцатеричные коды** удобны для точного задания фиксированных цветов и широко используются в веб-разработке.
-   **RGB/RGBA** полезны, когда необходимо задать цвет с возможностью регулирования прозрачности.
-   **HSL/HSLA** удобны для динамической генерации оттенков и плавных переходов, поскольку изменение одного параметра (например, светлоты или насыщенности) позволяет легко регулировать визуальное восприятие.
-   **Цветовые имена** можно использовать для простых случаев, однако их набор ограничен и их точное соответствие может отличаться в разных браузерах.

### 3. **Примеры использования**

Рассмотрим пример, включающий различные единицы измерения и цветовые форматы:

```css
/* file `styles.css` */
body {
    font-family: Arial, sans-serif;
}

h1 {
    font-size: 2rem; /* Относительная единица rem */
    color: #ff6347; /* Шестнадцатеричный цвет */
    text-align: center;
}

p.highlight {
    font-size: 1.5em; /* Относительная единица em */
    line-height: 1.5;
    color: rgba(255, 0, 0, 0.7); /* Формат RGBA */
}

.box {
    width: 50vw; /* Относительная единица vw */
    height: 100px; /* Абсолютная единица px */
    background-color: hsl(200, 100%, 50%); /* Формат HSL */
    margin: 20px auto; /* Автоматическое центрирование */
    text-align: center;
    color: white;
    line-height: 100px; /* Вертикальное центрирование текста */
}
```

```html
<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="UTF-8" />
        <title>
            Пример использования единиц измерения и цветовых форматов в CSS
        </title>
        <link rel="stylesheet" href="styles.css" />
    </head>
    <body>
        <h1>Заголовок страницы</h1>
        <p class="highlight">
            Это пример текста с различными CSS-свойствами для стилизации текста.
        </p>
        <div class="box">Пример блока с размерами и фоном.</div>
    </body>
</html>
```

### **Заключение**

В CSS единицы измерения и цветовые форматы представляют собой два фундаментальных инструмента для задания внешнего вида элементов.

-   **Единицы измерения:**  
    Абсолютные (px, pt, in, cm, mm, pc) задают фиксированные размеры, тогда как относительные (em, rem, %, vw, vh, vmin, vmax, ex, ch) обеспечивают гибкость и адаптивность дизайна. Выбор единицы зависит от контекста и требований к масштабируемости интерфейса.

-   **Цветовые форматы:**  
    Шестнадцатеричные коды, RGB/RGBA, HSL/HSLA и цветовые имена предоставляют разработчикам широкий спектр возможностей для задания цвета. Каждый формат имеет свои преимущества: точность, возможность задания прозрачности или удобство регулирования оттенка и светлоты.

**Рекомендации**

-   **Для адаптивности:**
    -   Используйте `rem` для размеров шрифтов и `%`/`vw`/`vh` для макетов.
    -   Избегайте `em` для сложных вложенных структур.
-   **Для цветов:**
    -   HEX — для простых цветов без прозрачности.
    -   HSL — если нужно динамически менять тон/светлоту (например, в JavaScript).
    -   LAB/LCH — для дизайнеров, работающих с расширенной палитрой.
-   **Проверяйте поддержку:**
    -   Используйте `@supports` для проверки новых форматов:
    ```css
    @supports (color: lch(0 0 0)) {
        .element {
            color: lch(50 60 120);
        }
    }
    ```

---

## |6| **Подключение шрифтов и основные свойства для текста**

### 1. **Подключение шрифтов**

Правильное подключение шрифтов — ключ к корректному отображению текста. Существует два основных метода: использование **системных шрифтов** и **загрузка кастомных шрифтов**.

#### **1.1. Системные шрифты**

Системные шрифты уже установлены на устройстве пользователя. Для их использования достаточно указать имя шрифта в свойстве `font-family`.

**Пример:**

```css
body {
    font-family: 'Arial', 'Helvetica', sans-serif;
}
```

_Объяснение:_

Браузер будет использовать первый доступный шрифт из списка.

#### **1.2. Кастомные шрифты через `@font-face`**

Чтобы использовать шрифты, которые отсутствуют в системе пользователя, применяется директива `@font-face`. Она позволяет указать URL для загрузки шрифта и задать его семейство, чтобы потом использовать его в стилях.

**Шаги:**

1. Загрузите файлы шрифтов в форматах: `.woff2`, `.woff`, `.ttf`, `.eot`, `otf` - для обеспечения совместимости с разными браузерами.
2. Определите шрифт в CSS:

```css
@font-face {
    font-family: 'MyCustomFont'; /* Название шрифта */
    src: url('path/to/font.woff2') format('woff2'), url('path/to/font.woff')
            format('woff'), url('path/to/font.ttf') format('truetype'); /* Пути к файлам шрифта в разных форматах */
    font-weight: 400; /* Задает вес шрифта, например, 400 для обычного, 700 для жирного */
    font-style: normal; /* Стиль (normal, italic) */
}
```

**Пояснения:**

-   **font-family:** Имя шрифта, под которым он будет доступен в CSS.
-   **src:** Указывает путь к файлу шрифта и его формат. Можно задать несколько вариантов для обеспечения совместимости с разными браузерами.
-   **font-style и font-weight:** Эти параметры помогают браузеру выбрать нужный вариант шрифта, если в наборе имеется несколько вариантов (например, обычный и курсивный).

3. Используйте шрифт в стилях:

```css
body {
    font-family: 'MyCustomFont', sans-serif; /* Используем 'MyCustomFont', если он доступен, иначе sans-serif */
}
```

**Преимущества:**

-   Возможность использовать любые шрифты, а не только стандартные.
-   Гибкость в выборе начертаний и стилей.

**Недостатки:**

-   Увеличение размера страницы за счет загрузки файлов шрифтов.
-   Возможные проблемы с производительностью при загрузке большого количества шрифтов.

> [!NOTE]
>
> **Важно:**
>
> -   Формат `woff2` имеет приоритет из-за лучшего сжатия.
> -   Указывайте `font-weight` и `font-style`, чтобы корректно подгружать разные варианты шрифта.

#### **1.3. Кастомные шрифты через тег `<link>`**

Подключение шрифтов с помощью тега `<link>` с атрибутом `rel="preload"` — это современный метод оптимизации загрузки шрифтов. Он позволяет заранее загрузить шрифт до того, как он потребуется для отображения текста, что снижает задержки при первом рендеринге и предотвращает «мигание» текста (FOIT — Flash of Invisible Text).

**Синтаксис**

```html
<head>
    <link
        rel="preload"
        as="font"
        type="font/woff2"
        href="path/to/font.woff2"
        crossorigin=""
    />
</head>
```

**Ключевые моменты:**

-   **`rel="preload"`:**  
    Указывает браузеру, что этот ресурс должен быть загружен как можно раньше, даже если он ещё не используется в документе.
-   **`as="font"`:**  
    Определяет тип загружаемого ресурса, что позволяет браузеру правильно обрабатывать его (например, применить соответствующие политики кэширования и оптимизации).
-   **`type="font/woff2"`:**  
    Задает MIME-тип ресурса, в данном случае шрифта в формате WOFF2. Это помогает браузеру убедиться, что загружаемый файл соответствует ожидаемому формату.
-   **`href="/static/media/Inter.var.c2fe3cb2b7c746f7966a.woff2"`:**  
    Указывает путь к файлу шрифта.
-   **`crossorigin=""`:**  
    Атрибут необходим для корректной загрузки шрифтов с внешних источников или при использовании кэширования через CDN. Он позволяет браузеру отправлять запросы с нужными заголовками **CORS**, чтобы шрифт мог быть использован в документе.

**Преимущества такого подхода:**

-   **Быстрая загрузка:** Ресурс загружается до того, как начнется его использование в стилях, что уменьшает задержку при рендеринге текста.
-   **Оптимизация производительности:** Позволяет браузеру заранее запустить загрузку и подготовить шрифт к моменту его применения, что особенно важно для критически важных ресурсов, влияющих на первичное отображение страницы.
-   **Управление кэшированием:** С правильными настройками CORS и указанием MIME-типа шрифт может быть эффективно закэширован для последующих посещений.

#### **1.4. Кастомные шрифты через Google Fonts**

Google Fonts — это бесплатный сервис, предоставляющий большую коллекцию шрифтов, готовых к использованию на веб-страницах.

1.  Перейдите на сайт Google Fonts: [https://fonts.google.com/](https://fonts.google.com/)
2.  Выберите понравившийся шрифт.
3.  Скопируйте код ссылки или импорта, предложенный сервисом.
4.  Вставьте код в раздел `<head>` вашего HTML-документа.

```html
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link
    href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap"
    rel="stylesheet"
/>
```

5. Используйте шрифт:

```css
body {
    font-family: 'Roboto', sans-serif;
}
```

**Преимущества:**

-   Простота использования.
-   Большой выбор бесплатных шрифтов.
-   Автоматическая оптимизация для разных браузеров.

**Недостатки:**

-   Зависимость от Google Fonts.
-   Ограниченный выбор по сравнению с загрузкой пользовательских шрифтов.

#### **1.4. Font Squirrel**

Font Squirrel — это сайт, предоставляющий бесплатные шрифты и инструменты для их конвертации в разные форматы.

1.  Перейдите на сайт Font Squirrel: [https://www.fontsquirrel.com/](https://www.fontsquirrel.com/)
2.  Выберите понравившийся шрифт.
3.  Скачайте шрифт в нужном формате или используйте генератор `@font-face` для создания CSS-кода.

**Преимущества:**

-   Большой выбор бесплатных шрифтов.
-   Возможность конвертировать шрифты в разные форматы.

**Недостатки:**

-   Необходимо самостоятельно конвертировать шрифты и подключать их к сайту.

### 2. **Основные свойства для работы с текстом**

CSS (Cascading Style Sheets) предоставляет множество свойств для стилизации текста на веб-страницах. Эти свойства позволяют управлять цветом, размером, выравниванием, декорированием и другими аспектами текста.

#### **2.1. `color` — цвет текста**

Задает цвет текста элемента. Поддерживает форматы:

-   **HEX:** `#FF0000`.
-   **RGB/RGBA:** `rgb(255, 0, 0)`, `rgba(255, 0, 0, 0.5)`.
-   **HSL/HSLA:** `hsl(0, 100%, 50%)`, `hsla(0, 100%, 50%, 0.5)`.
-   **Названия цветов:** `red`, `blue`.

**Пример:**

```css
p {
    color: #ff0000; /* Красный цвет */
}
```

#### **2.2. `font-size` — размер шрифта**

Определяет размер шрифта текста. Единицы измерения:

-   **Абсолютные:** `px` (пиксели), `pt` (пункты).
-   **Относительные:** `em` (от размера родителя), `rem` (от размера корневого элемента), `%` (проценты).

**Пример:**

```css
h1 {
    font-size: 2em; /* Размер шрифта в два раза больше основного */
}
p {
    font-size: 16px; /* Фиксированный размер шрифта в пикселях */
}
```

#### **2.3. `text-align` — выравнивание текста**

Определяет горизонтальное выравнивание текста внутри элемента:

-   `left` (по левому краю),
-   `right` (по правому краю),
-   `center` (по центру),
-   `justify` (по ширине).

**Пример:**

```css
h1 {
    text-align: center; /* Центрирование текста */
}
p {
    text-align: justify; /* Выравнивание текста по ширине */
}
```

#### **2.4. `text-decoration` — оформление текста**

Добавляет декоративные линии:

-   `underline` (подчеркивание),
-   `overline` (линия над текстом),
-   `line-through` (зачеркивание),
-   `blink` (мигающий),
-   `none` (удаление декораций, например, для ссылок).
-   а также возможны комбинации (например, `underline overline`).

**Пример:**

```css
a {
    text-decoration: underline; /* Подчеркнутый текст */
}
del {
    text-decoration: line-through; /* Зачеркнутый текст */
}
```

Современный синтаксис (CSS3):

```css
a {
    text-decoration: underline solid #ff0000 2px; /* Линия: тип, стиль, цвет, толщина */
}
```

#### **2.5. `line-height` — межстрочный интервал**

Задает расстояние между строками. Значения:

-   **Безразмерные числа:** `1.5` (относительно размера шрифта),
-   **Абсолютные:** `px` (пиксели), `pt` (пункты).
-   **Относительные:** `em` (от размера родителя), `rem` (от размера корневого элемента), `%` (проценты).

**Пример:**

```css
p {
    line-height: 1.5; /* Межстрочный интервал 1.5 */
}
```

#### **2.6. `font-family` — семейство шрифтов**

Определяет семейство шрифтов для текста. Правила:

-   Указывайте резервные шрифты через запятую, на случай если первый шрифт недоступен..
-   Названия шрифтов из нескольких слов заключайте в кавычки.
-   Всегда добавляйте **generic family** в конец (например, `serif`, `sans-serif`).

**Пример:**

```css
body {
    font-family: Arial, Helvetica, sans-serif; /* Основной шрифт Arial, запасной Helvetica */
}
```

#### **2.7. `font-weight` — насыщенность шрифта**

Управляет толщиной шрифта. Значения:

-   **Числовые:** `100` (Thin) – `900` (Black).
-   **Ключевые слова:** `normal` (400), `bold` (700).

**Пример:**

```css
h1 {
    font-weight: bold; /* Жирный шрифт */
}
p {
    font-weight: 300; /* Легкий шрифт */
}
```

#### **2.8. `letter-spacing` — межбуквенный интервал**

Регулирует расстояние между символами. Значения:

-   `normal` (по умолчанию),
-   **Абсолютные:** `px` (пиксели), `pt` (пункты).
-   **Относительные:** `%` (проценты).
-   **Отрицательные значения:** `-1px` (уменьшение интервала).

**Пример:**

```css
p {
    letter-spacing: 2px; /* Межбуквенный интервал 2 пикселя */
}
```

#### **2.9. `font` — сокращенное свойство**

Свойство `font` является шорткатом (сокращенным свойством), позволяющим задать сразу несколько свойств шрифта в одном объявлении.

**Синтаксис:**

```css
font: [font-style] [font-variant] [font-weight] [font-size]/[line-height]
    [font-family];
```

**Пример:**

```css
/* Обязательные части: font-size и font-family */
p {
    font: italic small-caps bold 16px/1.5 'Helvetica', sans-serif;
}
```

Здесь:

-   `italic` — font-style,
-   `small-caps` — font-variant,
-   `bold` — font-weight,
-   `16px` — font-size,
-   `1.5` — line-height (указывается после косой черты `/`),
-   `'Helvetica', sans-serif` — font-family.

### 3. **Рекомендации**

-   **Подключение шрифтов:**  
    При использовании `@font-face` убедитесь, что файлы шрифтов доступны и оптимизированы по размеру. Если возможно, используйте форматы WOFF2, которые обеспечивают лучшую компрессию. Подключайте только необходимые начертания (например, 400 и 700). Не злоупотребляйте количеством используемых шрифтов.

-   **Резервные шрифты:**  
    Всегда указывайте запасной шрифт (fallback) в `font-family`, чтобы гарантировать корректное отображение текста на устройствах, где основной шрифт недоступен.

-   **Единообразие текста:**  
    Старайтесь задавать базовые стили текста (например, для body или основных блоков) через внешние файлы CSS, что обеспечит единообразное оформление и упростит поддержку кода.

-   **Сокращённое свойство `font`:**  
    Используйте его для компактного задания нескольких свойств одновременно, но помните, что порядок значений важен и должны быть указаны обязательные части (например, `font-size` и `font-family`).

-   **Отступы и межстрочное расстояние:**  
    Правильно задавайте `line-height` для улучшения читаемости текста, особенно для абзацев с большим объёмом информации. Для основного текста используйте `line-height: 1.5–1.6`. Минимальный `font-size: 16px` для мобильных устройств.

-   **Тестирование и адаптивность:**  
    Проверьте отображение текста на различных устройствах и экранах. Используйте относительные единицы измерения, такие как `rem` или `em`, чтобы текст масштабировался вместе с размером экрана.

### Пример использования

```css
/* file `styles.css` */
@font-face {
    font-family: 'Roboto';
    src: url('roboto.woff2') format('woff2');
}
body {
    font-family: Arial, sans-serif;
    color: #333;
}

h1 {
    font: 700 2.5rem/1.2 'Roboto', sans-serif;
    text-align: center;
}

p {
    font-size: 16px;
    line-height: 1.5;
}

.highlight {
    color: #ff6600;
    font-weight: bold;
    letter-spacing: 1px;
}

.decorated {
    text-decoration: underline;
    font-weight: bold;
}
```

```html
<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="UTF-8" />
        <title>Пример использования текстовых свойств CSS</title>
        <link rel="stylesheet" href="styles.css" />
    </head>
    <body>
        <h1>Заголовок страницы</h1>
        <p class="highlight">
            Это пример текста с различными CSS-свойствами для стилизации текста.
        </p>
        <p class="decorated">Подчеркнутый и жирный текст</p>
    </body>
</html>
```

_Объяснение:_

-   Подключен внешний шрифт `Roboto` из файла `woff2`
-   Элемент `body` имеет основной шрифт Arial и цвет текста `#333`.
-   Заголовок `h1` имеет подключенный шрифт `Roboto 700` размер шрифта `2,5rem`, межстрочный интервал 1,2 и центрирован.
-   Параграфы `p` имеют размер шрифта `16px` и межстрочный интервал `1.5`.
-   Класс `highlight` задает оранжевый цвет текста, жирный шрифт и межбуквенный интервал `1px`.
-   Класс `decorated` задает подчеркнутый текст и жирный шрифт.

### Заключение

Правильное использование свойств текста и шрифтов позволяет создавать эстетичные, читаемые и адаптивные интерфейсы. Соблюдайте принципы оптимизации и всегда тестируйте отображение на разных устройствах.

---

## |7| **Базовая работа с фоновыми изображениями**

Фоновые изображения и цвета — ключевые инструменты для оформления элементов веб-страницы. Они позволяют задавать сложные визуальные эффекты, текстуры, градиенты и паттерны. CSS предоставляет набор свойств для управления фоном, позволяющий задавать его внешний вид, повторение, размер и позиционирование, их можно комбинировать или использовать отдельно. Это не только улучшает эстетическое восприятие, но и помогает создавать адаптивные и функциональные интерфейсы.

### 1. **Основные свойства**

#### **1.1. `background-color` — цвет фона**

Свойство `background-color` задает однотонный цвет фона элемента. Оно применяется, когда требуется заливка цветом, либо как базовый фон, на который накладываются другие фоновые изображения.

**Синтаксис:**

```css
background-color: <цвет>;
```

**Форматы цвета:**

-   **Ключевые слова:** `red`, `blue`, `transparent` (прозрачный).
-   **HEX:** `#ff0000`, `#f00` (сокращенная запись).
-   **RGB/RGBA:** `rgb(255, 0, 0)`, `rgba(255, 0, 0, 0.5)` (с прозрачностью).
-   **HSL/HSLA:** `hsl(0, 100%, 50%)`, `hsla(0, 100%, 50%, 0.3)`.

**Пример:**

```css
div {
    background-color: #ff6347; /* Красно-оранжевый цвет */
}
```

**Особенности:**

-   Цвет фона отображается под изображением, если оно задано через `background-image`.
-   Используйте `background-color` как базовый слой, особенно когда фоновое изображение может иметь прозрачные участки (PNG).
-   Для плавных переходов цвета можно применять CSS градиенты, которые тоже являются разновидностью фонового цвета.

#### **1.2. `background-image` — фоновое изображение**

Свойство `background-image` отвечает за установку фонового изображения или градиента для элемента. Оно принимает в качестве значения URL изображения или CSS-функции (например, градиенты).

**Синтаксис:**

```css
background-image: <изображение>;
```

**Типы значений:**

1. **Изображение через `url()`:**
   Изображение указывается с помощью функции `url()`, внутри которой прописывается путь к изображению или ключевое слово `none` (для отмены изображения).

    ```css
    background-image: url('path/to/image.jpg');
    ```

2. **Градиенты:**
    - Линейный градиент:
    ```css
    background-image: linear-gradient(to right, #ff0000, #0000ff);
    ```
    - Радиальный градиент:
    ```css
    background-image: radial-gradient(circle, #ff0000, #0000ff);
    ```

**Пример:**

```css
/* Установка фонового изображения */
div {
    background-image: url('background.jpg');
}
/* Использование градиента в качестве фонового изображения */
.header {
    background-image: linear-gradient(to right, #ff7e5f, #feb47b);
}
```

**Особенности:**

-   Градиенты генерируются кодом и не требуют загрузки файлов.
-   Можно задавать несколько фоновых изображений, разделяя значения запятыми (они будут накладываться друг на друга):
    ```css
    .multi-bg {
        background-image: url('image1.png'), url('image2.png');
    }
    ```
-   Фоновое изображение по умолчанию располагается поверх `background-color`, если они оба заданы.

#### **1.3. `background-size` — размер фонового изображения**

Свойство `background-size` управляет масштабированием фонового изображения. Оно позволяет адаптировать изображение к размеру элемента, сохраняя пропорции или изменяя их по необходимости.

**Синтаксис:**

```css
background-size: <значение>;
```

**Основные значения:**
| Значение | Описание |
|---------------|-------------------------------------------------------------------------|
| `auto` | Исходный размер изображения (по умолчанию). |
| `cover` | Изображение масштабируется, чтобы полностью покрыть элемент, сохраняя свои пропорции (без пробелов). Может обрезать края. |
| `contain` | Изображение масштабируется, чтобы поместиться внутри элемента, сохраняя свои пропорции (без обрезки). Могут появиться пустые области. |
| `<ширина> <высота>` | Задает размер в пикселях (`500px 300px`), процентах (`100% 50%`) или других единицах. |

**Пример:**

```css
div {
    background-image: url('background.jpg');
    background-size: cover; /* Изображение покроет весь элемент */
}
.hero {
    background-size: cover; /* Заполнить весь блок */
}

.icon {
    background-size: 32px 32px; /* Фиксированный размер */
}
```

**Особенности:**

-   Если задано одно значение (например, `background-size: 200px`), второе (высота) автоматически становится `auto`.
-   Для сохранения пропорций используйте `auto`:
    ```css
    background-size: 200px auto; /* Ширина 200px, высота пропорциональна */
    ```
-   Используйте `cover` для создания эффектных полноэкранных баннеров.
-   Применяйте `contain` для логотипов или изображений, когда важно показать всё содержимое, даже если остаются пустые области.
-   При работе с фиксированными размерами следите за адаптивностью: можно задавать размеры в относительных единицах.

#### **1.4. `background-repeat` — повторение фона**

Свойство `background-repeat` определяет, как фоновое изображение повторяется (или не повторяется) внутри элемента, если его размеры меньше элемента.

**Синтаксис:**

```css
background-repeat: <значение>;
```

**Основные значения:**
| Значение | Описание |
|---------------|-------------------------------------------------------------------------|
| `repeat` | Изображение повторяется по горизонтали и вертикали (по умолчанию). |
| `no-repeat` | Изображение не повторяется. |
| `repeat-x` | Повторение только по горизонтали. |
| `repeat-y` | Повторение только по вертикали. |
| `space` | Изображения повторяются с равномерными промежутками между ними, без обрезания. |
| `round` | Изображения повторяются с изменением масштаба так, чтобы их количество полностью поместилось в контейнер без промежутков. |

**Пример:**

```css
/* Фоновое изображение повторяется по умолчанию */
.pattern {
    background-image: url('pattern.png');
    background-repeat: repeat;
}

/* Повторение изображения только по горизонтали */
.header {
    background-image: url('header-bg.png');
    background-repeat: repeat-x;
}

/* Изображение не повторяется */
.hero {
    background-image: url('hero.jpg');
    background-repeat: no-repeat;
}
```

**Особенности:**

-   `space` и `round` не поддерживаются в старых браузерах (IE).
-   Для декоративных узоров часто используется `repeat` или `repeat-x`/`repeat-y`.
-   Если требуется единичное изображение (например, логотип на фоне), задайте `no-repeat` и дополнительно используйте `background-position` для точного позиционирования.

#### **1.5. `background-position` - положение фона**

Свойство `background-position` управляет начальным положением фонового изображения в пределах области, определяемой элементом. Оно позволяет точно указать, где должно располагаться изображение относительно границ элемента.

**Синтаксис**

```css
background-position: <горизонтальное положение> <вертикальное положение>;
```

**Значение:**

| Тип значения           | Примеры                                    | Описание                                                                                                   |
| ---------------------- | ------------------------------------------ | ---------------------------------------------------------------------------------------------------------- |
| **Ключевые слова**     | `top`, `bottom`, `left`, `right`, `center` | Позиционируют изображение по краям или центру элемента.                                                    |
| **Проценты**           | `50% 20%`                                  | Отсчитываются от левого верхнего угла элемента. `0% 0%` — левый верхний угол, `100% 100%` — правый нижний. |
| **Абсолютные единицы** | `20px 40px`                                | Отступ от левого верхнего угла в `px`, `em`, `rem` и т.д.                                                  |
| **Комбинации**         | `right top`, `center bottom`               | Сочетание ключевых слов.                                                                                   |

**Пример:**

```css
body {
    background-image: url('image.jpg');
    background-position: center; /* Изображение центрируется */
}
.header {
    background-position: right 20px bottom 10px; /* 20px от правого края, 10px от нижнего */
}
.card {
    background-position: 80% 30%; /* 80% по горизонтали, 30% по вертикали */
}
```

**Особенности:**

1.  **Одно значение:**  
    Если указано одно значение, оно интерпретируется как горизонтальное положение, а вертикальное по умолчанию считается `center`.

    ```css
    .box {
        background-position: 30%; /* эквивалентно `background-position: 30% center;`. */
    }
    ```

2.  **Комбинирование:**  
    При использовании двух значений, первое значение всегда отвечает за горизонтальное положение, второе — за вертикальное. Значения разделяются пробелом.
    Пример:

    ```css
    .box {
        background-position: right top; /* изображение располагается в правом верхнем углу. */
    }
    ```

3.  **Отрицательные значения:**
    Можно использовать отрицательные значения, чтобы "выдвинуть" изображение за пределы элемента:

    ```css
    .box {
        background-position: -50px -20px; /* Сдвиг влево и вверх */
    }
    ```

4.  **Влияние на отображение:**

        -   В сочетании с такими свойствами, как `background-size: cover;`, `background-position` определяет, какая часть изображения будет видна при масштабировании изображения, чтобы оно полностью покрывало область элемента.
        -   Если изображение меньше контейнера, `background-position` определяет, в какой точке элемента оно будет закреплено.
        -   Для **неповторяющихся изображений** (`background-repeat: no-repeat`) позиция особенно важна.

5.  **Выбор значения `background-position`:**

    -   Определите, какую часть изображения вы хотите видеть в первую очередь.
    -   Используйте проценты для динамического позиционирования, чтобы изображение корректно масштабировалось с изменением размера элемента.
    -   При работе с `background-size: cover` или `contain` используйте `background-position` для фокусировки на нужной части изображения.

#### **1.6. `background-attachment` - прокрутка фона**

Свойство `background-attachment` определяет, как ведет себя фоновое изображение при прокрутке страницы или содержимого элемента. Определяет, будет ли фон фиксированным или скроллиться вместе с контентом.

**Значение:**

| Значение | Описание                                                                                                                                                                                                                                                     |
| -------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `scroll` | **Фон скроллится** вместе с содержимым страницы (значение по умолчанию). При прокрутке страницы изображение перемещается, как обычный элемент фона.                                                                                                          |
| `fixed`  | **Фон фиксируется** относительно окна браузера. Не двигается при прокрутке. Это означает, что при прокрутке страницы изображение остается на одном и том же месте, создавая эффект параллакса.                                                               |
| `local`  | **Фон скроллится** вместе с содержимым элемента, к которому оно применено (если у элемента есть своя прокрутка). При прокрутке содержимого внутри элемента изображение будет перемещаться вместе с ним, но оставаться на месте относительно самого элемента. |

**Пример:**

```css
body {
    background-image: url('background.jpg');
    background-attachment: fixed; /* Фоновое изображение остается на месте */
}
```

**`scroll` (по умолчанию) - Фон двигается вместе с элементом при прокрутке страницы.**

```css
.section {
    background-image: url('image.jpg');
    background-attachment: scroll;
}
```

**`fixed` - Фон остается неподвижным при прокрутке, создавая эффект параллакса.**

```css
.parallax {
    background-image: url('image.jpg');
    background-attachment: fixed;
    background-size: cover;
}
```

**`local` - Фон скроллится вместе с содержимым внутри элемента.**

```css
.scrollable-content {
    background-image: url('pattern.png');
    background-attachment: local;
    overflow: auto;
    height: 200px;
}
```

```html
<div class="scrollable-content">Контент с прокруткой...</div>
```

**Особенности**

1.  **Fixed-фон:**  
    Использование `fixed` часто применяется для создания эффектных визуальных решений, когда требуется, чтобы фон оставался неподвижным, а контент прокручивался поверх него. Это может создать иллюзию глубины и используется для реализации параллакс-эффекта.

    -   Позиция изображения рассчитывается относительно **окна браузера**, а не элемента.
    -   Может не работать на мобильных устройствах из-за ограничений производительности.

2.  **Local-фон:**  
    Значение `local` применяется, когда требуется, чтобы фоновое изображение реагировало на прокрутку содержимого элемента, но оставалось фиксированным относительно внутренней области этого элемента. Это бывает полезно в случаях, когда элемент имеет собственную полосу прокрутки.

    -   Полезно для элементов с внутренней прокруткой (например, блоки с `overflow: auto`).

3.  **Поведение при множественных фоновых изображениях:**  
    Если для одного элемента заданы несколько фоновых изображений, можно указать несколько значений для `background-attachment`, разделенных запятыми, чтобы каждое изображение имело своё поведение (например, одно фиксированное, другое — прокручиваемое).

#### **1.7. Сокращенное свойство `background`**

Свойство `background` является сокращенным свойством (шорткатом), которое позволяет задать несколько фоновых свойств в одном объявлении.

**Синтаксис:**

Порядок значений в сокращенном свойстве не жестко фиксирован, но обычно он выглядит следующим образом:

```css
background: <color> <image> <position>/<size> <repeat> <attachment>;
```

**Порядок значений** (необязательно указывать все):

1. `background-color`
2. `background-image`
3. `background-position` (через `/`)
4. `background-size`
5. `background-repeat`
6. `background-attachment`

**Пример:**

```css
div {
    background: #ff6347 url('background.jpg') center center / cover no-repeat;
}
```

_Объяснение:_

-   `#ff6347` задает цвет фона.
-   `url('background.jpg')` указывает фоновое изображение.
-   `center center` выравнивает изображение по центру.
-   `cover` масштабирует изображение, чтобы оно покрывало весь элемент.
-   `no-repeat` запрещает повторение изображения.

**Особенности:**

-   Используйте сокращённое свойство для компактного задания нескольких параметров, когда все они должны применяться к одному элементу.
-   Если не указать какое-либо свойство, будет использовано значение по умолчанию.
-   Нельзя пропускать `/` между `position` и `size`.
-   Если требуется изменить только один параметр, можно использовать отдельные свойства, чтобы не перезаписывать все остальные настройки.

### 2. **Комбинирование свойств**

#### **Фоновое изображение с градиентом**

```css
.element {
    background-image: linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5)),
        url('image.jpg');
    background-size: cover;
    background-position: center;
}
```

_Объяснение:_

Градиент накладывается поверх изображения, создавая затемнение.

#### **Паттерн с повторением**

```css
body {
    background-image: url('texture.png');
    background-repeat: repeat;
    background-color: #f0f0f0; /* Фон, если изображение не загрузится */
}
```

#### **Фиксированный фон с позиционированием**

```css
.hero {
    background-image: url('sky.jpg');
    background-position: center top; /* Центрирование по горизонтали, верхний край */
    background-attachment: fixed;
    background-size: cover;
}
```

-   Фон фиксируется и центрируется, создавая статичный эффект при прокрутке.

#### **Пример использования**

Рассмотрим пример применения всех вышеописанных свойств для работы с фоновыми изображениями:

```css
/* file `styles.css` */
body {
    font-family: Arial, sans-serif;
    background-color: #f0f0f0; /* Цвет фона для всего документа */
}

.box {
    width: 300px;
    height: 200px;
    margin: 50px auto;
    background: #ff6347 url('background.jpg') no-repeat center center / cover;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
}
```

```html
<!DOCTYPE html>
<html lang="ru">
    <head>
        <meta charset="UTF-8" />
        <title>Пример работы с фоновыми изображениями в CSS</title>
        <link rel="stylesheet" href="styles.css" />
    </head>
    <body>
        <div class="box">Пример блока с фоновым изображением и цветом.</div>
    </body>
</html>
```

_Объяснение:_

-   Элемент `body` имеет светло-серый цвет фона.
-   Элемент `div` с классом `box` имеет следующие стили:
    -   Ширина и высота заданы как `300px` и `200px` соответственно.
    -   Центрирование блока с использованием отступов и автомаржинов.
    -   Сокращенное свойство `background` задает красно-оранжевый цвет, фоновое изображение, запрет на повторение изображения, центрирование и масштабирование изображения для покрытия всего элемента.
    -   Цвет текста задан как белый.
    -   Flexbox используется для центрирования текста внутри блока.

### 3. **Советы по оптимизации**

1. **Используйте современные форматы изображений:**
   При использовании фоновых изображений важно оптимизировать их размер и формат для быстрой загрузки страницы. Применяйте современные форматы изображений (например, WebP) и используйте адаптивные методы (например, media queries).

    - **WebP** — лучшее сжатие с сохранением качества.
    - **AVIF** — поддержка прозрачности и анимации.
    - Для старых браузеров добавляйте резервные форматы:
        ```css
        background-image: url('image.avif'), url('image.jpg');
        ```

2. **Заменяйте изображения градиентами:**
   Для простых фонов используйте CSS-градиенты вместо изображений.

    ```css
    .button {
        background: linear-gradient(to bottom, #4caf50, #45a049);
    }
    ```

3. **Учитывайте размеры изображений:**
   Прежде чем задавать стили, продумайте, какой эффект вы хотите достичь: единотонный фон, декоративное повторяющееся изображение или полноэкранное изображение с адаптацией.

    - Для `background-size: cover` используйте изображения с высоким разрешением.
    - Для паттернов выбирайте небольшие файлы с повторяющимся узором.

4. **Для параллакс-эффектов:**

    - Используйте `background-attachment: fixed` вместе с `background-size: cover`.
    - Избегайте тяжелых изображений — это замедлит прокрутку.

5. **Проверяйте на мобильных устройствах:**

    - Свойство `fixed` может не работать корректно или вызывать лаги.
    - Используйте медиа-запросы для отключения эффекта на малых экранах:
        ```css
        @media (max-width: 768px) {
            .parallax {
                background-attachment: scroll;
            }
        }
        ```

6. **Избегайте конфликтов:**
   Если `background-attachment: fixed` не работает, убедитесь, что у элемента нет свойств `transform` или `filter`, которые создают новый контекст наложения.

7. **Сочетание слоев:**  
   Используйте `background-color` как базовый слой, который будет виден там, где фоновое изображение отсутствует или имеет прозрачные участки.

8. **Адаптивность:**  
   Для фоновых изображений, особенно в полноэкранных баннерах, часто используется `background-size: cover` — это обеспечивает корректное заполнение элемента вне зависимости от его размеров.

9. **Сокращённое свойство:**  
   Использование `background` позволяет писать компактный и чистый код. Однако, если требуется гибкая настройка отдельных параметров, лучше использовать длинную форму.

### 4. **Поддержка браузеров**

-   Все основные свойства (`background-color`, `background-image`, `background-size`, `background-repeat`) поддерживаются всеми современными браузерами.
-   **`background-size`:**
    -   В IE8 и ниже используйте полифиллы или альтернативные решения.
-   **`background-repeat`:**
    -   Значения `space` и `round` не работают в IE.
-   **`background-position`:**
    -   Поддерживается всеми браузерами, включая IE9+.
    -   Процентные значения и ключевые слова работают везде.
-   **`background-attachment`:**
    -   `fixed` и `scroll` поддерживаются всеми браузерами.
    -   `local` работает в Chrome 4+, Firefox 25+, Safari 5+, Edge 12+.
    -   В iOS Safari `fixed` может игнорироваться для элементов с `overflow: scroll`.

### **Заключение**

-   **`background-color`** — базовый фон элемента.
-   **`background-image`** — добавляет изображения или градиенты.
-   **`background-size`** — контролирует масштабирование.
-   **`background-repeat`** — управляет повторением.
-   **`background-position`** — инструмент для точного позиционирования фонового изображения.
-   **`background-attachment`** — определяет, как фон взаимодействует с прокруткой.
-   **`background`** — сокращенная запись для удобства.

**Рекомендации**

-   Используйте оптимизированные изображения для уменьшения размера страницы и улучшения производительности.
-   Экспериментируйте с различными значениями свойств для достижения желаемого эффекта.
-   Используйте `background` для краткой записи свойств фона.
-   Учитывайте особенности разных браузеров при работе с фоновыми изображениями.

Правильное комбинирование этих свойств позволяет создавать адаптивные и визуально привлекательные фоны. Используйте современные форматы изображений и CSS-градиенты для оптимизации производительности.

---

## **Практика**

### **Общие требования**:

1.  Код должен быть валидным (проверьте через [W3C Validator](https://validator.w3.org/)).
2.  Используйте комментарии в CSS для разделения секций.
3.  Убедитесь, что стили не конфликтуют между собой.
4.  Все элементы отображаются согласно заданным стилям.
5.  Шрифты загружаются корректно.
6.  Фоновые изображения адаптивны (проверьте на разных разрешениях).
7.  Нет нарушений в нейминге классов и ID.

### **Задание 1: Создание личного портфолио**

#### **1.1. Требования:**

1. **Подключение CSS к HTML:**

    - Создайте HTML-документ с корректной структурой (DOCTYPE, `<html>`, `<head>`, `<body>`).
    - Подключите внешнюю таблицу стилей через тег `<link>`.
    - Добавьте встроенный блок `<style>` в `<head>`, который будет содержать отдельные стили для специфических элементов.
    - Используйте inline-стили для одного-двух элементов, чтобы продемонстрировать их применение.

2. **Базовые селекторы:**

    - Определите стили с помощью универсального селектора `*`, типовых селекторов (например, для `<h1>`, `<p>`), селекторов классов и идентификаторов.
    - Используйте переопределение стилей для элементов с помощью селектора идентификатора.

3. **Наследование (inheritance):**

    - Задайте родительскому элементу (например, контейнеру или `<body>`) свойства текста (цвет, шрифт), чтобы дочерние элементы автоматически получили их.
    - В одном из блоков используйте значение `inherit` для явного наследования свойства.

4. **Правила нейминга:**

    - Придерживайтесь единообразного стиля именования. Придумайте осмысленные имена для классов и ID, соответствующие функционалу разделов портфолио (например, `.portfolio__header`, `#about-me`).

5. **Единицы измерения и цветовые форматы:**

    - Используйте абсолютные (px) и относительные единицы (em, rem, %) для задания размеров, отступов и шрифтов.
    - Задайте цвета для текста и фона, используя как шестнадцатеричные коды, так и функции rgb/rgba или hsl/hsla.

6. **Подключение шрифтов и основные свойства для текста:**

    - Подключите внешний шрифт с помощью сервиса (например, Google Fonts) или с помощью `@font-face`.
    - Примените свойства текста: `font-size`, `font-family`, `font-weight`, `line-height`, `text-align`, `letter-spacing` и т.д. для разных разделов страницы (заголовки, абзацы, ссылки).

7. **Базовая работа с фоновыми изображениями:**
    - Задайте для одного из разделов фоновое изображение с использованием `background-image`.
    - Определите параметры: `background-position`, `background-repeat`, `background-size` и `background-attachment`.
    - При необходимости добавьте базовый цвет фона через `background-color`, чтобы он сочетался с изображением.

#### **1.2. Варианты контента (на выбор)**

**Вариант 1: Личное портфолио веб-разработчика**

-   **Содержание:**
    -   Главная страница с кратким описанием опыта и специализации (HTML, CSS, JavaScript).
    -   Раздел «Проекты», где представлены несколько завершённых проектов с описаниями, ссылками на демо и GitHub.
    -   Страница «Обо мне», где рассказывается о профессиональном пути, навыках и образовании.
-   **Особенности:**
    -   Применение резиновой верстки.
    -   Упор на минималистичный дизайн, чистую типографику.

**Вариант 2: Личное портфолио графического дизайнера**

-   **Содержание:**
    -   Главная страница с большим баннером, отражающим творческий стиль дизайнера, и логотипом.
    -   Галерея работ с крупными изображениями.
    -   Раздел с описанием творческого процесса, используемых инструментов (Photoshop, Illustrator) и достижений.
    -   Блог с публикациями о трендах дизайна, обзорами проектов и советами по визуальному оформлению.
-   **Особенности:**
    -   Яркая цветовая палитра, экспериментальные типографические решения.
    -   Четкое разграничение разделов с использованием уникальных фоновых изображений и градиентов.

**Вариант 3: Личное портфолио фотографа**

-   **Содержание:**
    -   Страница-портфолио с крупными фотографиями, отсортированными по жанрам (портрет, пейзаж, архитектура и т.д.).
    -   Раздел «Обо мне», где описывается опыт, техника съемки, оборудование и награды.
    -   Контактная информация для заказа фотосессии или сотрудничества.
-   **Особенности:**
    -   Использование минималистичного дизайна для акцента на самих фотографиях, нейтральные фоновые цвета и простая навигация.
    -   Резиновая верстка.

---

### **Задание 2: Одностраничное лендинг-представление продукта**

#### **2.1. Требования:**

1. **Подключение CSS к HTML:**

    - Создайте структуру HTML с разделами (например, `<header>`, `<section>`, `<footer>`).
    - Подключите внешний файл стилей и продемонстрируйте также использование встроенного `<style>` для специфичных блоков.

2. **Базовые селекторы:**

    - Используйте типовые селекторы для оформления стандартных элементов.
    - Примените классовые селекторы для стилизации повторяющихся блоков (например, карточек продукта).
    - Добавьте уникальные стили с помощью селекторов идентификатора для ключевых элементов.

3. **Наследование:**

    - Установите стили для родительского контейнера (например, базовый цвет текста, шрифт) и продемонстрируйте, что дочерние элементы наследуют их.
    - Примените ключевое слово `inherit` для некоторых свойств в элементах, где требуется явное наследование.

4. **Правила нейминга:**

    - Придерживайтесь единой системы именования (например, модификаторы для кнопок: `.btn`, `.btn--primary`).
    - Убедитесь, что имена классов и ID отражают функциональность (например, `#main-banner`, `.feature-item`).

5. **Единицы измерения и цветовые форматы:**

    - Используйте процентные и относительные единицы для задания ширины блоков и отступов.
    - Примените различные форматы задания цветов: hex, rgba для прозрачности, hsl для настройки оттенка.

6. **Подключение шрифтов и основные свойства для текста:**

    - Подключите один или два шрифта (например, для заголовков и основного текста) с использованием сервиса или `@font-face`.
    - Задайте стили для текста, используя свойства `font`, `text-decoration` (например, для ссылок убрать подчёркивание) и `text-align` (для центровки заголовков).

7. **Базовая работа с фоновыми изображениями:**
    - Для главного баннера используйте фоновое изображение с параметрами `background-size: cover` и `background-position: center`.
    - Добавьте эффект фиксированного фона с помощью `background-attachment: fixed` для создания параллакс-эффекта.
    - Используйте `background-repeat: no-repeat` для предотвращения повторения изображения.

#### **2.2. Варианты контента (на выбор)**

**Вариант 1: Лендинг для мобильного приложения**

-   **Содержание:**
    -   Главный баннер с изображением смартфона, демонстрирующим интерфейс приложения.
    -   Блок с описанием основных функций приложения, преимуществами и отзывами пользователей.
    -   Кнопки для скачивания приложения (App Store, Google Play).
-   **Особенности:**
    -   Применение резинового дизайна, использование ярких акцентных цветов.
    -   Четкое разделение блоков с помощью фоновых изображений и градиентов.

**Вариант 2: Лендинг для SaaS-сервиса**

-   **Содержание:**
    -   Заголовок и краткое описание сервиса с акцентом на решение бизнес-задач.
    -   Блок с функционалом сервиса, его преимуществами и кейсами использования.
    -   Раздел с отзывами клиентов и логотипами компаний-партнеров.
-   **Особенности:**
    -   Профессиональный минималистичный дизайн, использование нейтральных тонов с яркими акцентами.

**Вариант 3: Лендинг для физического продукта (например, электронного гаджета)**

-   **Содержание:**
    -   Большой визуальный баннер с фотографией продукта в действии.
    -   Раздел с описанием характеристик продукта, его инновационных особенностей и технических данных.
    -   Сравнительная таблица с конкурентами и преимущества продукта.
-   **Особенности:**
    -   Использование высококачественных изображений и инфографики.
    -   Четкое разделение контента с помощью фона, который меняется в зависимости от блока.

---
