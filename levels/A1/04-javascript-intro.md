# **2.1. Что такое JavaScript**

> [Home](../../readme.md)
> || [A1](./index.md)

---

## |1| **Стандарт ECMAScript (ES)**

**[ECMAScript](https://ru.wikipedia.org/wiki/ECMAScript) (ES)** — это стандарт, определяющий спецификацию языка программирования, который лежит в основе JavaScript. Этот стандарт разрабатывается и поддерживается организацией **ECMA International** в рамках технического комитета **TC39**.

JavaScript, JScript (Microsoft), и ActionScript (Adobe) — реализации ECMAScript.

**Зачем нужен ECMAScript?**

1. **Единый стандарт**:
   Все реализации JavaScript следуют одной спецификации.
2. **Новые возможности**:
   Развитие языка с добавлением современных функций.
3. **Совместимость**:
   Старые возможности сохраняются, чтобы код оставался работоспособным.

### 1. **Как работает стандарт ECMAScript (ES)?**

1. **Разработка и обновление стандарта**

- За разработку отвечает комитет **TC39** (Technical Committee 39), который собирается несколько раз в год.
- Работает по открытому процессу, предложенные изменения проходят несколько стадий обсуждения(от идеи до утверждения).
- Ежегодно публикуются новые версии (ES6 в 2015 году, затем ES2016, ES2017 и т. д.).

2. **Структура стандарта**

- Описывает **синтаксис** (например, `let`, `const`, стрелочные функции).
- Определяет **встроенные объекты** (`Array`, `Object`, `Promise` и т. д.).
- Регламентирует **исполнение кода** (например, механизм **Event Loop**).
- Описывает **модули** (`import/export`).

3. **Внедрение в браузеры и движки**

- Воплощается в **движках JavaScript** (V8, SpiderMonkey, JavaScriptCore).
- Не все браузеры сразу поддерживают новые фичи, поэтому используют **транспилеры** (Babel) и **полифилы**.

4. **Как проверить версию ES?**

- В браузере: `console.log(ECMAScript.version)` (неофициальный способ).
- Через сайты типа [caniuse.com](https://caniuse.com/) или документацию TC39.

ECMAScript задает основу для всех JS-реализаций, обеспечивая совместимость и развитие языка.

### 2. **История ECMAScript**

| **Версия** | **Год** | **Ключевые особенности**                                                                                 |
| ---------- | ------- | -------------------------------------------------------------------------------------------------------- |
| **ES1**    | 1997    | Первый стандарт, базовая спецификация JavaScript.                                                        |
| **ES2**    | 1998    | Минимальные изменения, добавлены требования для совместимости.                                           |
| **ES3**    | 1999    | Добавлены регулярные выражения, инструкции `try/catch`, более сложные строки (с экранированием).         |
| **ES4**    | Отменён | Планы были слишком амбициозны, проект не был реализован.                                                 |
| **ES5**    | 2009    | Добавлены `strict mode`, методы работы с массивами, `JSON.parse`, `Object.defineProperty`.               |
| **ES6**    | 2015    | Самое большое обновление: `let`, `const`, классы, стрелочные функции, модули, промисы, шаблонные строки. |
| **ES7**    | 2016    | Методы `Array.prototype.includes`, оператор `**` (возведение в степень).                                 |
| **ES8**    | 2017    | Асинхронные функции (`async/await`), методы работы с объектами.                                          |
| **ES9**    | 2018    | Оператор rest/spread для объектов, асинхронные итераторы.                                                |
| **ES10**   | 2019    | Методы `flat` и `flatMap` для массивов, `Object.fromEntries`.                                            |
| **ES11**   | 2020    | `Nullish coalescing (??)`, `Optional chaining (?.)`, глобальный объект `globalThis`.                     |
| **ES12**   | 2021    | Логические операторы присваивания `&&=`.                                                                 |

### 3. **Работа с современными стандартами**

#### **3.1. Проверка поддержки браузерами**

Процесс определения, поддерживает ли браузер конкретные HTML, CSS или JavaScript-функции.

**Способы проверки:**

1. **Can I Use** ([caniuse.com](https://caniuse.com)) — база данных поддержки веб-технологий в разных браузерах.
2. **MDN Web Docs** ([developer.mozilla.org](https://developer.mozilla.org)) — документация с указанием поддержки браузеров.
3. **Feature Detection (Обнаружение возможностей)**
   - Использование `if ('property' in object)` в JS.
   - `CSS.supports('property', 'value')` для проверки CSS-свойств.
4. **Modernizr** — библиотека для автоматического определения поддержки веб-функций.
5. **User-Agent и `navigator`** — менее надежный метод, так как user-agent можно подделать.

Если браузер не поддерживает функцию, используют **полифилы** или **транспилеры** для совместимости.

#### **3.2. Использование транспилеров**

Процесс преобразования кода с одного языка или версии в другую, чаще всего для обеспечения совместимости с более старыми средами.

**Зачем нужны транспилеры?**

- Поддержка новых возможностей JavaScript в старых браузерах.
- Преобразование современных стандартов (ES6+) в более старые (ES5).
- Использование языков, компилируемых в JavaScript (TypeScript, CoffeeScript).

**Популярные транспилеры:**

- **Babel** — преобразует современный JS в ES5.
- **TypeScript Compiler (tsc)** — компилирует TypeScript в JS.
- **SWC, esbuild** — быстрые альтернативы Babel.

Транспилеры часто используются вместе с бандлерами (Webpack, Rollup, Parcel) для автоматической компиляции кода перед его использованием в продакшене.

#### **3.3. Полифилы (polyfills)**

Фрагменты кода (обычно написанные на JavaScript), которые добавляют поддержку новых возможностей в старые браузеры, которые их не поддерживают.

Проще говоря, это «заплатки», которые имитируют поведение современных функций или API, чтобы код работал одинаково во всех браузерах.

Например, если старый браузер не поддерживает `fetch()`, можно подключить полифил, который добавит аналогичную функциональность, используя `XMLHttpRequest`. Один из вариантов, библиотека **core-js** добавляет поддержку отсутствующих функций.

#### **3.4. Бандлеры (Bundlers)**

Инструменты, которые объединяют (собирают) файлы проекта в один или несколько оптимизированных файлов для быстрой и эффективной загрузки в браузере.

**Основные функции бандлеров:**

- **Объединение файлов** (JS, CSS, изображения, шрифты и т. д.)
- **Минификация** (удаление пробелов, сокращение кода)
- **Оптимизация и дедупликация** (удаление дубликатов, tree shaking)
- **Загрузка модулей** (поддержка `import/export`, CommonJS, AMD)
- **Поддержка транспилеров** (Babel, TypeScript)
- **Разделение кода (Code Splitting)** для улучшения загрузки

**Популярные бандлеры:**

- **Webpack** — мощный, гибкий, но сложный в настройке
- **Parcel** — минимальная настройка, высокая скорость
- **Vite** — быстрый, ориентирован на современные проекты
- **Rollup** — эффективен для библиотек и модульных сборок
- **esbuild** — сверхбыстрая сборка благодаря Go

Бандлеры используются в современных фронтенд-проектах для оптимизации кода и улучшения производительности.

---

## |2| **Подключение JavaScript к HTML**

JavaScript можно подключить к HTML несколькими способами: через встроенный код (_inline_), внутренний код (внутри `<script>`), и внешний файл.

### 1. **Встроенный (inline) JavaScript**

Код JavaScript можно писать прямо в атрибутах HTML-элементов, таких как `onclick`, `onmouseover` и т. д. Этот способ считается устаревшим и редко используется, так как затрудняет поддержку и отладку кода.

**Пример:**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Inline JavaScript</title>
  </head>
  <body>
    <button onclick="alert('Hello, World!')">Click me</button>
  </body>
</html>
```

### 2. **Внутренний (embedded) JavaScript**

Код JavaScript можно размещать в любое место HTML-документа в тегах `<script>`. Этот способ подходит для небольших скриптов.

Тег `<script>` содержит JavaScript-код, который автоматически выполнится, когда браузер его обработает.

**Пример:**

```html
<!DOCTYPE html>
<html>
  <body>
    <p>Перед скриптом...</p>
    <script>
      alert("Привет, мир!");
    </script>
    <p>...После скрипта.</p>
  </body>
</html>
```

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Embedded JavaScript</title>
    <script>
      function greet() {
        alert("Hello, World!");
      }
    </script>
  </head>
  <body>
    <button onclick="greet()">Click me</button>
  </body>
</html>
```

### 3. **Внешний JavaScript**

Если у вас много JavaScript-кода, вы можете поместить его в отдельный файл.
Наиболее рекомендуемый способ — выносить код JavaScript в отдельный файл с расширением `.js` и подключать его через тег `<script>` с атрибутом `src`. Это упрощает поддержку, улучшает структуру кода и позволяет повторно использовать скрипты в нескольких страницах.

```html
<script src="/path/to/script.js"></script>
```

Здесь `/path/to/script.js` – это абсолютный путь от корневой папки до необходимого файла. Корневой папкой может быть корень диска или корень сайта, в зависимости от условий работы сайта. Также можно указать относительный путь от текущей страницы. Например, `src="script.js"` или `src="./script.js"` будет означать, что файл `"script.js"` находится в текущей папке.

Можно указать и полный URL-адрес. Например:

```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js"></script>
```

Для подключения нескольких скриптов используйте несколько тегов:

```html
<script src="/js/script1.js"></script>
<script src="/js/script2.js"></script>
…
```

> [!TIP]
>
> **На заметку:**
>
> Как правило, только простейшие скрипты помещаются в HTML. Более сложные выделяются в отдельные файлы.
>
> Польза отдельных файлов в том, что браузер загрузит скрипт отдельно и сможет хранить его в [кеше](https://en.wikipedia.org/wiki/Web_cache). Другие страницы, которые подключают тот же скрипт, смогут брать его из кеша вместо повторной загрузки из сети. И таким образом файл будет загружаться с сервера только один раз. Это сокращает расход трафика и ускоряет загрузку страниц.
>
> Если атрибут `src` установлен, содержимое тега `script` будет игнорироваться. В одном теге `<script>` нельзя использовать одновременно атрибут `src` и код внутри.
>
> Нижеприведённый пример не работает:
>
> ```html
> <script src="file.js">
>   alert(1); // содержимое игнорируется, так как есть атрибут src
> </script>
> ```
>
> Нужно выбрать: либо внешний скрипт `<script src="…">`, либо обычный код внутри тега `<script>`.
>
> Вышеприведённый пример можно разделить на два скрипта:
>
> ```html
> <script src="file.js"></script>
> <script>
>   alert(1);
> </script>
> ```

**Пример внешнего файла:**

```javascript
/* file script.js */
document.getElementById("greetButton").addEventListener("click", () => {
  alert("Hello, World!");
});
```

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>External JavaScript</title>
    <script src="script.js" defer></script>
  </head>
  <body>
    <button id="greetButton">Click me</button>
  </body>
</html>
```

### 4. **Атрибуты тега `<script>`**

Тег `<script>` поддерживает несколько атрибутов, которые управляют подключением JavaScript.

#### **4.1. Атрибут `src`**

Используется для подключения внешнего файла JavaScript.

```html
<script src="script.js"></script>
```

#### **4.2. Атрибут `defer`**

Откладывает выполнение скрипта до полной загрузки HTML-документа. Скрипты с этим атрибутом выполняются в порядке их подключения.

```html
<script src="script.js" defer></script>
```

#### **4.3. Атрибут `async`**

Позволяет загружать скрипт асинхронно, не блокируя обработку HTML. Скрипты с `async` выполняются сразу после загрузки и могут выполняться вне порядка подключения.

```html
<script src="script.js" async></script>
```

#### **4.4. Разница между `async` и `defer`**

Атрибуты `defer` и `async` управляют тем, как браузер загружает и выполняет внешние JavaScript-файлы. Они полезны для оптимизации загрузки страницы и повышения производительности.

1.  **Без `defer` или `async`**

    - **Порядок загрузки**
      Сразу при обнаружении в HTML
    - **Порядок выполнения**
      Скрипт загружается и выполняется **сразу**, блокируя обработку HTML-документа до завершения выполнения скрипта.
    - **Когда использовать?**
      Для небольших скриптов, которые нужны сразу.
    - **Пример**
      Скрипт загружается и выполняется сразу, блокируя обработку HTML.

      ```html
      <!DOCTYPE html>
      <html lang="en">
        <head>
          <title>Without Attributes</title>
        </head>
        <body>
          <!-- Загружает и выполняет script.js, блокируя страницу -->
          <script src="script.js"></script>
          <p>This text will load after the script finishes.</p>
        </body>
      </html>
      ```

2.  **С `defer`**

    - **Порядок загрузки**
      Загружается параллельно с HTML
    - **Порядок выполнения**
      Только после полной загрузки и обработки HTML-документа
    - **Когда использовать?**
      - Когда ваш скрипт зависит от HTML-разметки (например, для работы с DOM).
      - Если скриптов несколько, и важно их выполнение в определённом порядке.
    - **Пример**
      Скрипт загружается параллельно с HTML и выполняется после полной загрузки документа.

      ```html
      <!DOCTYPE html>
      <html lang="en">
        <head>
          <title>With Defer</title>
          <!-- Скрипт выполняется после загрузки HTML -->
          <script src="script.js" defer></script>
        </head>
        <body>
          <p>This text loads before the script executes.</p>
        </body>
      </html>
      ```

3.  **С `async`**

    - **Порядок загрузки**
      Загружается параллельно с HTML
    - **Порядок выполнения**
      Выполняется сразу после загрузки, независимо от того, завершилась ли загрузка HTML-документа
    - **Когда использовать?**
      - Для скриптов, которые не зависят от DOM (например, загрузка аналитики, рекламы, виджетов).
      - Когда порядок выполнения скриптов не важен.
    - **Пример**
      Скрипт загружается параллельно с HTML и выполняется сразу после загрузки.

      ```html
      <!DOCTYPE html>
      <html lang="en">
        <head>
          <title>With Async</title>
          <!-- Скрипт выполняется, как только загружается -->
          <script src="script.js" async></script>
        </head>
        <body>
          <p>This text may load before or after the script executes.</p>
        </body>
      </html>
      ```

4.  **Совместное использование**

    - **Когда использовать?**
      Атрибуты `defer` и `async` нельзя использовать одновременно в одном теге `<script>`. Если оба указаны, браузер игнорирует `async`, и работает только `defer`.
    - **Пример**
      ```html
      <!DOCTYPE html>
      <html lang="en">
        <head>
          <title>Defer vs Async</title>
          <!-- Выполнится после загрузки HTML -->
          <script src="script1.js" defer></script>
          <!-- Выполнится сразу после загрузки -->
          <script src="script2.js" async></script>
        </head>
        <body>
          <h1>Check Console</h1>
        </body>
      </html>
      ```

#### **4.5. Атрибут `type`**

Атрибут `type` в теге `<script>` указывает тип содержимого скрипта. Обычно он используется для определения языка или формата скрипта, который интерпретируется браузером.

##### **1. Значение по умолчанию: `type="text/javascript"`**

Старый стандарт HTML, HTML4, требовал наличия этого атрибута в теге `<script>`. Обычно он имел значение `type="text/javascript"`. На текущий момент этого больше не требуется. Начиная с HTML5, это значение стало **по умолчанию**, и атрибут `type` можно опустить.

```html
<!-- Явное указание типа (устарело) -->
<script type="text/javascript">
  console.log("Hello, world!");
</script>

<!-- Современный подход -->
<script>
  console.log("Hello, world!");
</script>
```

##### **2. Значение `module`**

При использовании JavaScript-модулей (ES6) нужно указывать `type="module"`. Это позволяет использовать механизмы модулей, такие как `import` и `export`.

```html
<script type="module">
  import { greet } from "./greet.js";
  greet();
</script>
```

**Особенности `type="module"`:**

- Скрипты выполняются в строгом режиме (`strict mode`) по умолчанию.
- Каждый модуль имеет свою собственную область видимости.
- Скрипты загружаются асинхронно (аналогично `defer`).
- Модули могут импортировать и экспортировать функции, переменные и классы.

##### **3. Использование для не-JavaScript контента**

1. **Пример: `type="application/json"`**

Если нужно включить в HTML данные в формате JSON, их можно разместить в теге `<script>` с атрибутом `type="application/json"`.

```html
<script type="application/json" id="data">
  {
    "name": "John",
    "age": 30
  }
</script>

<script>
  // Чтение JSON-данных из элемента <script>
  const jsonData = JSON.parse(document.getElementById("data").textContent);
  console.log(jsonData.name); // "John"
</script>
```

2. **Пример: `type="text/template"`**

Иногда используется для хранения HTML-шаблонов, которые будут обработаны JavaScript.

```html
<script type="text/template" id="template">
  <h1>{{title}}</h1>
  <p>{{description}}</p>
</script>

<script>
  const template = document.getElementById("template").textContent;
  console.log(template);
  // Вывод: <h1>{{title}}</h1><p>{{description}}</p>
</script>
```

##### **4. Особенности работы с атрибутом `type`**

1. **Неизвестные значения `type`:**
   Если указать `type`, который браузер не поддерживает, содержимое тега `<script>` игнорируется. Это может быть полезно, например, для серверных языков или специальных форматов.

   ```html
   <script type="text/special-format">
     // Этот код не будет выполняться браузером.
   </script>
   ```

2. **Совместимость с другими языками:**
   Теоретически, можно использовать `<script>` для встраивания других языков, если они поддерживаются браузером или инструментами.

   ```html
   <script type="text/vbscript">
     MsgBox "Hello from VBScript!"
   </script>
   ```

##### **5. Рекомендации**

1. **Используйте `type="module"` для современных приложений.**
   Это позволяет работать с модульной архитектурой JavaScript.
2. **Не указывайте `type="text/javascript"` для обычных скриптов.**
   Это лишнее, так как JavaScript по умолчанию интерпретируется как `text/javascript`.
3. **Используйте другие типы (`application/json`, `text/template`) для нестандартного контента.**
   Это делает код структурированным и легко доступным для обработки через JavaScript.

##### **6. Полный пример**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Script Type Example</title>
  </head>
  <body>
    <!-- JSON-данные -->
    <script type="application/json" id="json-data">
      { "message": "Hello, JSON!" }
    </script>

    <!-- HTML-шаблон -->
    <script type="text/template" id="html-template">
      <h1>{{title}}</h1>
      <p>{{content}}</p>
    </script>

    <!-- Модульный скрипт -->
    <script type="module">
      import { greet } from "./greet.js";
      greet();
    </script>

    <!-- Обычный скрипт -->
    <script>
      const jsonData = JSON.parse(
        document.getElementById("json-data").textContent
      );
      console.log(jsonData.message); // "Hello, JSON!"
    </script>
  </body>
</html>
```

#### **4.6. Атрибут `language`**

Этот атрибут должен был задавать язык, на котором написан скрипт. Но так как в браузере JavaScript является языком по умолчанию, в этом атрибуте уже нет необходимости.

#### **4.7. Обёртывание скрипта в HTML-комментарии.**

В очень древних книгах и руководствах вы сможете найти комментарии внутри тега `<script>`, например, такие:

```html
<script type="text/javascript">
  <!--     ... //-->
</script>
```

Этот комментарий скрывал код JavaScript в старых браузерах, которые не знали, как обрабатывать тег `<script>`. Поскольку все браузеры, выпущенные за последние 15 лет, не содержат данной проблемы, такие комментарии уже не нужны. Если они есть, то это признак, что перед нами очень древний код.

### 5. **Место размещения `<script>`**

#### **5.1. Внутри `<head>`**

Если скрипт нужно загрузить до отображения страницы (например, для настройки глобальных переменных), используйте атрибут `defer`:

```html
<head>
  <script src="script.js" defer></script>
</head>
```

#### **5.2. Перед закрывающим тегом `</body>`**

Такой подход гарантирует, что весь HTML будет загружен до выполнения скрипта.

```html
<body>
  <!-- Содержимое страницы -->
  <script src="script.js"></script>
</body>
```

### **6. Пример с несколькими скриптами**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Multiple Scripts</title>
    <script src="first.js" defer></script>
    <script src="second.js" defer></script>
  </head>
  <body>
    <h1>Multiple Scripts Example</h1>
  </body>
</html>
```

### **7. Пример взаимодействия JavaScript и HTML**

#### **HTML:**

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>JavaScript Interaction</title>
    <script src="script.js" defer></script>
  </head>
  <body>
    <h1 id="header">Welcome!</h1>
    <button id="changeText">Change Text</button>
  </body>
</html>
```

#### **JavaScript (`script.js`):**

```javascript
document.getElementById("changeText").addEventListener("click", () => {
  const header = document.getElementById("header");
  header.textContent = "Hello, JavaScript!";
  header.style.color = "blue";
});
```

### **Рекомендации:**

1. **Используйте `defer` для внешних скриптов** — это гарантирует, что скрипты не будут блокировать загрузку HTML.
2. **Избегайте использования inline JavaScript** — это затрудняет поддержку и противоречит принципам безопасности.
3. **Храните скрипты в отдельных файлах** — это делает код более читаемым и управляемым.
4. **Проверяйте совместимость кода** — если требуется поддержка старых браузеров, избегайте новейших возможностей, не поддерживаемых ими.
