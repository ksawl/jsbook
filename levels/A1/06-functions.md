# **3.1. Функции**

> [Home](../../readme.md)
> || [A1](./index.md)

---

## |1| **Объявление и вызов функций**

### 1. **Что такое функция?**

Функция — это блок кода, предназначенный для выполнения определенной задачи. Функции позволяют структурировать код, делать его более читаемым и многократно использовать один и тот же блок кода без необходимости его дублирования.

**Примеры использования функций:**

- Выполнение арифметических операций.
- Работа с массивами и объектами.
- Асинхронные операции, такие как запросы к серверу.

### 2. **Зачем использовать функции?**

Функции упрощают поддержку и расширяемость кода. Вот некоторые причины, почему функции полезны:

- **Повторное использование кода**: Один раз написав функцию, можно использовать ее многократно.
- **Улучшение читаемости**: Функции помогают разделить код на логические блоки.
- **Изоляция логики**: Функции изолируют логику и переменные, что снижает вероятность конфликтов имен.

### 3. **Объявление функций**

Для создания функций мы можем использовать объявление функции.

Пример объявления функции:

```js
function showMessage() {
  alert("Всем привет!");
}
```

Вначале идёт ключевое слово `function`, после него имя функции, затем список параметров в круглых скобках через запятую (в вышеприведённом примере он пустой) и, наконец, код функции, также называемый «телом функции», внутри фигурных скобок.

```js
function имя(параметры) {
...тело...
}
```

Наша новая функция может быть вызвана по своему имени: `showMessage()`.

Например:

```js
function showMessage() {
  alert("Всем привет!");
}

showMessage();
showMessage();
```

Вызов `showMessage()` выполняет код функции. Здесь мы увидим сообщение дважды.

Этот пример явно демонстрирует одно из главных предназначений функций: избавление от дублирования кода.

Если понадобится поменять сообщение или способ его вывода – достаточно изменить его в одном месте: в функции, которая его выводит.

#### **Function Declaration (Декларация или объявление функции)**

Это традиционный способ объявления функции в JavaScript. Функции, объявленные таким способом, поднимаются в начало своей области видимости (hoisting).

**Синтаксис:**

```javascript
function имяФункции(параметры) {
  // тело функции
  return результат;
}
```

**Пример:**

```javascript
function greet(name) {
  return `Привет, ${name}!`;
}

console.log(greet("Мир")); // Вывод: Привет, Мир!
```

#### **Function Expression (Функциональное выражение)**

Функциональные выражения создают функцию в контексте другого выражения. Они не поднимаются (не имеют **hoisting**).

**Синтаксис:**

```javascript
const имяФункции = function (параметры) {
  // тело функции
  return результат;
};
```

**Пример:**

```javascript
const add = function (a, b) {
  return a + b;
};

console.log(add(2, 3)); // Вывод: 5
```

Поскольку создание функции происходит в контексте выражения присваивания (с правой стороны от `=`), это **Function Expression**.

Обратите внимание, что после ключевого слова `function` нет имени. Для **Function Expression** допускается его отсутствие.

В более сложных ситуациях, с которыми мы столкнёмся позже, функция может быть создана и немедленно вызвана, или запланирована для дальнейшего выполнения, нигде не сохраняясь, таким образом, оставаясь анонимной.

> [!NOTE]
>
> Зачем нужна точка с запятой в конце?
> У вас мог возникнуть вопрос: Почему в **Function Expression** ставится точка с запятой ; на конце, а в **Function Declaration** нет:
>
> ```js
> function sayHi() {
>   // ...
> }
>
> let sayHi = function () {
>   // ...
> };
> ```
>
> Ответ прост: **Function Expression** создаётся здесь как `function(...) {...}` внутри выражения присваивания: `let sayHi = …;`. Точку с запятой `;` рекомендуется ставить в конце выражения, она не является частью синтаксиса функции.
>
> Точка с запятой нужна там и для более простого присваивания, такого как `let sayHi = 5;`, и для присваивания функции.

#### **Функция – это значение**

В JavaScript функции являются объектами первого класса, что означает, что их можно передавать как аргументы, возвращать из других функций и присваивать переменным.

```js
function sayHi() {
  console.log("Привет");
}
const a = sayHi;
a();
```

В этом примере функция `sayHi` копируется в переменную `a`, и затем вызывается через эту переменную.

Давайте разберем ваш пример по шагам:

1. **Создание функции `sayHi`:**

   ```javascript
   function sayHi() {
     console.log("Привет");
   }
   ```

   Здесь вы создаете функцию `sayHi`, которая при вызове выводит в консоль строку `'Привет'`.

2. **Присваивание функции переменной `a`:**

   ```javascript
   const a = sayHi;
   ```

   В этой строке вы присваиваете переменной `a` ссылку на функцию `sayHi`. Теперь `a` содержит ту же функцию, что и `sayHi`. Обратите внимание, что вы не вызываете функцию в этот момент (нет скобок `()` после `sayHi`), а просто передаете ссылку на неё.

3. **Вызов функции через переменную `a`:**
   ```javascript
   a();
   ```
   Здесь вы вызываете функцию, которая теперь хранится в переменной `a`. Поскольку `a` ссылается на ту же функцию, что и `sayHi`, в консоль будет выведено `'Привет'`.

**Важные моменты:**

- **Функции в JavaScript являются объектами.** Это означает, что они могут быть присвоены переменным, переданы как аргументы и возвращены из других функций.
- **Присваивание функции переменной не создает новую функцию.** Переменная `a` просто ссылается на ту же функцию, что и `sayHi`. Если вы измените функцию `sayHi`, это повлияет и на вызов через `a`, и наоборот.
- **Вызов функции через переменную.** Когда вы вызываете `a()`, это эквивалентно вызову `sayHi()`, так как `a` и `sayHi` ссылаются на одну и ту же функцию.

**Пример с изменением функции:**

```javascript
function sayHi() {
  console.log("Привет");
}

const a = sayHi;

// Изменяем функцию sayHi
sayHi = function () {
  console.log("Пока");
};

a(); // Выведет 'Привет', так как a ссылается на оригинальную функцию
sayHi(); // Выведет 'Пока', так как sayHi теперь ссылается на новую функцию
```

В этом примере, даже после изменения `sayHi`, переменная `a` продолжает ссылаться на оригинальную функцию, поэтому вызов `a()` выведет `'Привет'`, а вызов `sayHi()` выведет `'Пока'`.

Таким образом, копирование функции в JavaScript — это просто присваивание ссылки на функцию другой переменной, что позволяет вызывать функцию через эту переменную.

#### **Различия между Function Declaration и Function Expression**

1. **Синтаксические отличия**

**Function Declaration**: функция объявляется отдельной конструкцией `«function…»` в основном потоке кода.

```js
// Function Declaration
function sum(a, b) {
  return a + b;
}
```

**Function Expression**: функция, созданная внутри другого выражения или синтаксической конструкции. В данном случае функция создаётся в правой части «выражения присваивания» `=`:

```js
// Function Expression
let sum = function (a, b) {
  return a + b;
};
```

2. **Всплытие или hoisting**

Другое отличие состоит в том, когда движок JavaScript создаёт функцию.

**Function Expression** создаётся, когда выполнение доходит до него, и затем уже может использоваться.

После того, как поток выполнения достигнет правой части выражения присваивания `let sum = function…` – **с этого момента, функция считается созданной и может быть использована** (присвоена переменной, вызвана и т.д. ).

С **Function Declaration** всё иначе.

**Function Declaration** может быть вызвана раньше, чем она объявлена.

Другими словами, когда движок JavaScript готовится выполнять скрипт или блок кода, прежде всего он ищет в нём **Function Declaration** и создаёт все такие функции. Можно считать этот процесс «стадией инициализации».

И только после того, как все объявления **Function Declaration** будут обработаны, продолжится выполнение.

В результате функции, созданные как **Function Declaration**, могут быть вызваны раньше своих определений.

Например, так будет работать:

```js
sayHi("Вася"); // Привет, Вася

function sayHi(name) {
  alert(`Привет, ${name}`);
}
```

Функция `sayHi` была создана, когда движок JavaScript подготавливал скрипт к выполнению, и такая функция видна повсюду в этом скрипте.

…Если бы это было **Function Expression**, то такой код вызвал бы ошибку:

```js
sayHi("Вася"); // ошибка!

let sayHi = function (name) {
  // (*) магии больше нет
  alert(`Привет, ${name}`);
};
```

Функции, объявленные при помощи **Function Expression**, создаются тогда, когда выполнение доходит до них. Это случится только на строке, помеченной звёздочкой `(*)`. Слишком поздно.

3. **Область видимости**

Ещё одна важная особенность **Function Declaration** заключается в их блочной области видимости.

В строгом режиме, когда **Function Declaration** находится в блоке `{...}`, функция доступна везде внутри блока. Но не снаружи него.

Для примера давайте представим, что нам нужно объявить функцию `welcome()` в зависимости от значения переменной `age`, которое мы получим во время выполнения кода. И затем запланируем использовать её когда-нибудь в будущем.

Если мы попробуем использовать **Function Declaration**, это не заработает так, как задумывалось:

```js
let age = prompt("Сколько Вам лет?", 18);

// в зависимости от условия объявляем функцию
if (age < 18) {
  function welcome() {
    alert("Привет!");
  }
} else {
  function welcome() {
    alert("Здравствуйте!");
  }
}

// ...не работает
welcome(); // Error: welcome is not defined
```

Это произошло, так как объявление **Function Declaration** видимо только внутри блока кода, в котором располагается.

Вот ещё один пример:

```js
let age = 16; // возьмём для примера 16

if (age < 18) {
  welcome(); // \ (выполнится)
  // |
  function welcome() {
    // |
    alert("Привет!"); // | Function Declaration доступно
  } // | во всём блоке кода, в котором объявлено
  // |
  welcome(); // / (выполнится)
} else {
  function welcome() {
    alert("Здравствуйте!");
  }
}

// здесь фигурная скобка закрывается,
// поэтому Function Declaration, созданные внутри блока кода выше -- недоступны отсюда.

welcome(); // Ошибка: welcome is not defined
```

Что можно сделать, чтобы `welcome` была видима снаружи `if`?

Верным подходом будет воспользоваться функцией, объявленной при помощи **Function Expression**, и присвоить значение `welcome` переменной, объявленной снаружи `if`, что обеспечит нам нужную видимость.

Такой код заработает, как ожидалось:

```js
let age = prompt("Сколько Вам лет?", 18);

let welcome;

if (age < 18) {
  welcome = function () {
    alert("Привет!");
  };
} else {
  welcome = function () {
    alert("Здравствуйте!");
  };
}

welcome(); // теперь всё в порядке
```

Или мы могли бы упростить это ещё сильнее, используя условный оператор `?`:

```js
let age = prompt("Сколько Вам лет?", 18);

let welcome =
  age < 18
    ? function () {
        alert("Привет!");
      }
    : function () {
        alert("Здравствуйте!");
      };

welcome(); // теперь всё в порядке
```

> [!TIP]
>
> Когда использовать **Function Declaration**, а когда **Function Expression**?
>
> Как правило, если нам понадобилась функция, в первую очередь нужно рассматривать синтаксис **Function Declaration**, который мы использовали до этого. Он даёт нам больше свободы в том, как мы можем организовывать код. Функции, объявленные таким образом, можно вызывать до их объявления.
>
> Также функции вида `function f(…) {…}` чуть более заметны в коде, чем `let f = function(…) {…}`. **Function Declaration** легче «ловятся глазами».
>
> …Но если **Function Declaration** нам не подходит по какой-то причине, или нам нужно условное объявление (мы рассмотрели это в примере выше), то следует использовать **Function Expression**.

#### **Итого**

Основные отличия:

1. **Имя функции**: Function Declaration всегда имеют имя, а Function Expression могут быть анонимными.
2. **Поднятие (hoisting)**: Function Declaration поднимаются в начало своей области видимости, а Function Expression — нет.

---

### 4. **Выбор имени функции**

Функция – это действие. Поэтому имя функции обычно является глаголом. Оно должно быть кратким, точным и описывать действие функции, чтобы программист, который будет читать код, получил верное представление о том, что делает функция.

Как правило, используются глагольные префиксы, обозначающие общий характер действия, после которых следует уточнение. Обычно в командах разработчиков действуют соглашения, касающиеся значений этих префиксов.

Например, функции, начинающиеся с `"show"` обычно что-то показывают.

Функции, начинающиеся с…

- `"get…"` – возвращают значение,
- `"set…"` – устанавливают значение,
- `"calc…"` – что-то вычисляют,
- `"create…"` – что-то создают,
- `"check…"` – что-то проверяют и возвращают логическое значение, и т.д.

Примеры таких имён:

```js
showMessage(..) // показывает сообщение
getAge(..) // возвращает возраст (получая его каким-то образом)
calcSum(..) // вычисляет сумму и возвращает результат
createForm(..) // создаёт форму (и обычно возвращает её)
checkPermission(..) // проверяет доступ, возвращая true/false
```

Благодаря префиксам, при первом взгляде на имя функции становится понятным, что делает её код, и какое значение она может возвращать.

> [!TIP]
>
> Одна функция – одно действие
> Функция должна делать только то, что явно подразумевается её названием. И это должно быть одним действием.
>
> Два независимых действия обычно подразумевают две функции, даже если предполагается, что они будут вызываться вместе (в этом случае мы можем создать третью функцию, которая будет их вызывать).
>
> Несколько примеров, которые нарушают это правило:
>
> - `getAge` – будет плохим выбором, если функция будет выводить `alert` с возрастом (должна только возвращать его).
> - `createForm` – будет плохим выбором, если функция будет изменять документ, добавляя форму в него (должна только создавать форму и возвращать её).
> - `checkPermission` – будет плохим выбором, если функция будет отображать сообщение с текстом доступ разрешён/запрещён (должна только выполнять проверку и возвращать её результат).
>
> В этих примерах использовались общепринятые смыслы префиксов. Конечно, вы в команде можете договориться о других значениях, но обычно они мало отличаются от общепринятых. В любом случае вы и ваша команда должны чётко понимать, что значит префикс, что функция с ним может делать, а чего не может.

> [!TIP]
>
> Сверхкороткие имена функций
> Имена функций, которые используются очень часто, иногда делают сверхкороткими.
>
> Например, фреймворк `jQuery` определяет функцию с помощью `$`. В библиотеке `Lodash` основная функция представлена именем `_`.
>
> Это исключения. В основном имена функций должны быть в меру краткими и описательными.

---

### 5. **Функции == Комментарии**

Функции должны быть короткими и делать только что-то одно. Если это что-то большое, имеет смысл разбить функцию на несколько меньших. Иногда следовать этому правилу непросто, но это определённо хорошее правило.

Небольшие функции не только облегчают тестирование и отладку – само существование таких функций выполняет роль хороших комментариев!

Например, сравним ниже две функции `showPrimes(n)`. Каждая из них выводит простое число до `n`.

Первый вариант использует метку `nextPrime`:

```js
function showPrimes(n) {
  nextPrime: for (let i = 2; i < n; i++) {
    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert(i); // простое
  }
}
```

Второй вариант использует дополнительную функцию `isPrime(n)` для проверки на простое:

```js
function showPrimes(n) {
  for (let i = 2; i < n; i++) {
    if (!isPrime(i)) continue;

    alert(i); // простое
  }
}

function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if (n % i == 0) return false;
  }
  return true;
}
```

Второй вариант легче для понимания, не правда ли? Вместо куска кода мы видим название действия (`isPrime`). Иногда разработчики называют такой код **самодокументируемым**.

Таким образом, допустимо создавать функции, даже если мы не планируем повторно использовать их. Такие функции структурируют код и делают его более понятным.

---

### 6. **Область видимости для функции**

**Внешние переменные**

У функции есть доступ к внешним переменным, например:

```js
let userName = "Вася";

function showMessage() {
  let message = "Привет, " + userName;
  alert(message);
}

showMessage(); // Привет, Вася
```

Функция обладает полным доступом к внешним переменным и может изменять их значение.

Например:

```js
let userName = "Вася";

function showMessage() {
  userName = "Петя"; // (1) изменяем значение внешней переменной

  let message = "Привет, " + userName;
  alert(message);
}

alert(userName); // Вася перед вызовом функции

showMessage();

alert(userName); // Петя, значение внешней переменной было изменено функцией
```

Внешняя переменная используется, только если внутри функции нет такой локальной.

Если одноимённая переменная объявляется внутри функции, тогда она перекрывает внешнюю. Например, в коде ниже функция использует локальную переменную `userName`. Внешняя будет проигнорирована:

```js
let userName = "Вася";

function showMessage() {
  let userName = "Петя"; // объявляем локальную переменную

  let message = "Привет, " + userName; // Петя
  alert(message);
}

// функция создаст и будет использовать свою собственную локальную переменную userName
showMessage();

alert(userName); // Вася, не изменилась, функция не трогала внешнюю переменную
```

> [!TIP]
>
> **Глобальные переменные**
>
> Переменные, объявленные снаружи всех функций, такие как внешняя переменная `userName` в вышеприведённом коде – называются глобальными.
>
> Глобальные переменные видимы для любой функции (если только их не перекрывают одноимённые локальные переменные).
>
> Желательно сводить использование глобальных переменных к минимуму. В современном коде обычно мало или совсем нет глобальных переменных. Хотя они иногда полезны для хранения важнейших «общепроектовых» данных.

### 7. **Примеры реального использования в коде**

#### Пример 1: Функция для проверки четности числа

```javascript
// Декларация функции
function isEven(number) {
  return number % 2 === 0;
}

console.log(isEven(4)); // Вывод: true
console.log(isEven(5)); // Вывод: false
```

#### Пример 2: Функция для вычисления факториала числа

```javascript
// Функциональное выражение
const factorial = function (n) {
  if (n === 0) {
    return 1;
  }
  return n * factorial(n - 1);
};

console.log(factorial(5)); // Вывод: 120
console.log(factorial(0)); // Вывод: 1
```

#### Пример 3: Функция для обработки данных пользователей

```javascript
// Декларация функции
function processUserData(users) {
  users.forEach((user) => {
    console.log(`Имя: ${user.name}, Возраст: ${user.age}`);
  });
}

const users = [
  { name: "John", age: 30 },
  { name: "Jane", age: 25 },
];

processUserData(users);
// Вывод:
// Имя: John, Возраст: 30
// Имя: Jane, Возраст: 25
```

#### Пример 4: Функция для конкатенации строк

```javascript
// Функциональное выражение
const concatenateStrings = function (str1, str2) {
  return str1 + " " + str2;
};

console.log(concatenateStrings("Hello", "World")); // Вывод: Hello World
```

---

## |2| **Аргументы, параметры и возвращаемые значения**

### 1. **Передача аргументов**

Значение, передаваемое в качестве параметра функции, также называется аргументом.

Другими словами:

**Параметр** – это переменная, указанная в круглых скобках в объявлении функции.
**Аргумент** – это значение, которое передаётся функции при её вызове.

Мы объявляем функции со списком параметров, затем вызываем их, передавая аргументы.

#### Как передавать аргументы в функцию

Аргументы передаются в функцию, чтобы функция могла использовать эти значения при выполнении. Когда вы вызываете функцию, вы передаете значения в скобках.

**Пример:**

```javascript
function greet(name) {
  console.log(`Привет, ${name}!`);
}

greet("Алексей"); // Вывод: Привет, Алексей!
```

В этом примере `Алексей` является аргументом, передаваемым функции `greet` переданное значение **копируется** в локальную переменную `name`. Которая используется в теле функции и является ее параметром.

**Функция всегда получает только копию значения**

Вот ещё один пример: у нас есть переменная `from`, и мы передаём её функции у которой есть параметр `from`. Такое совпадение имен здесь выбрано не случайно: функция изменяет значение `from`, но это изменение не отражается на глобальной переменной `from`.

```js
function showMessage(from, text) {
  from = "*" + from + "*"; // немного украсим "from"

  alert(from + ": " + text);
}

let from = "Аня";

showMessage(from, "Привет"); // *Аня*: Привет

// значение "from" осталось прежним, функция изменила значение локальной переменной
alert(from); // Аня
```

Рассматривая приведённый выше пример, мы могли бы сказать: «функция `showMessage` объявляется с двумя параметрами, затем вызывается с двумя аргументами: `from` и `"Привет"`».

#### Аргументы по умолчанию

Если при вызове функции аргумент не был указан, то его значением становится `undefined`.
JavaScript позволяет задавать значения по умолчанию для параметров функции. Если аргумент не передается, используется значение по умолчанию.

**Пример:**

```javascript
function greet(name = "гость") {
  console.log(`Привет, ${name}!`);
}

greet(); // Вывод: Привет, гость!
greet("Мир"); // Вывод: Привет, Мир!
```

В этом примере, если аргумент `name` не передается, используется значение по умолчанию `"гость"`, но могут быть и более сложное выражение, которое будет вычисляться при отстутствии параметра:

```js
function showMessage(from, text = anotherFunction()) {
  // anotherFunction() выполнится только если не передан text
  // результатом будет значение text
}
```

> [!TIP]
>
> **Вычисление параметров по умолчанию**
> В JavaScript параметры по умолчанию вычисляются каждый раз, когда функция вызывается без соответствующего аргумента.
>
> В приведённом выше примере, функция `anotherFunction()` не будет вызвана вообще, если указан аргумент `text`.
>
> С другой стороны, функция будет независимо вызываться каждый раз, когда аргумент `text` отсутствует.

#### **Альтернативные параметры по умолчанию**

> [!NOTE]
>
> Ранние версии JavaScript не поддерживали параметры по умолчанию. Поэтому существуют альтернативные способы, которые могут встречаться в старых скриптах.

Иногда имеет смысл присваивать значения по умолчанию для параметров не в объявлении функции, а на более позднем этапе.

Во время выполнения функции мы можем проверить передачу параметра явно сравнив его с `undefined`:

```js
function showMessage(text) {
  // ...
  if (text === undefined) {
    // если параметр отсутствует
    text = "пустое сообщение";
  }
  alert(text);
}
showMessage(); // пустое сообщение
```

…Или мы можем использовать оператор `||`:

```js
function showMessage(text) {
    // Если значение text ложно, тогда присвоить параметру text значение по умолчанию
    // Внимание, в этом варианте будет считаться отсутствующим значением
    // любое значение дающее false, в том числе и пустая строка text === ""
    text = text || 'пусто';
    ...
}
```

Современные движки JavaScript поддерживают оператор нулевого слияния `??`. Его использование будет лучшей практикой, в случае, если большинство ложных значений, таких как `0`, следует расценивать как «нормальные».

```js
function showCount(count) {
  // если count равен undefined или null, показать "неизвестно"
  alert(count ?? "неизвестно");
}
showCount(0); // 0
showCount(null); // неизвестно
showCount(); // неизвестно
```

---

### 2. **Spread и Rest параметры**

> [!TIP]
>
> Подробнее про операторы `spread` и `rest` будем изучать в главе [2.3.2 Spread/rest операторы](./2.3.2%20Spread_rest%20операторы.md)

- `Spread` оператор может использоваться для передачи элементов массива в качестве аргументов функции.

**Пример:**

```javascript
function sum(a, b, c) {
  return a + b + c;
}

const numbers = [1, 2, 3];
console.log(sum(...numbers)); // 6
```

Здесь `...numbers` разворачивает массив `[1, 2, 3]` в аргументы функции `sum`.

- `Rest` параметры делают функции более гибкими и позволяют легко работать с произвольным количеством аргументов. Это особенно полезно в случаях, когда заранее неизвестно, сколько аргументов будет передано функции.

**Сбор аргументов функции**

```javascript
function sum(...args) {
  return args.reduce((acc, val) => acc + val, 0);
}

console.log(sum(1, 2, 3)); // 6
console.log(sum(1, 2, 3, 4, 5)); // 15
```

Здесь `...args` собирает все переданные аргументы в массив `args`.

Подробнее про `spread` и `rest` операторы будем говорить позже.

### 3. **Возвращаемые значения**

#### Возврат значений из функции

Функция может возвращать результат своей работы, используя оператор `return`. Как только функция достигает оператора `return`, она завершает выполнение и возвращает указанное значение.

**Пример:**

```javascript
function add(a, b) {
  return a + b;
}

const result = add(3, 7);
console.log(result); // Вывод: 10
```

В этом примере функция `add` возвращает сумму двух чисел.

Директива `return` может находиться в любом месте тела функции. Как только выполнение доходит до этого места, функция останавливается, и значение возвращается в вызвавший её код (присваивается переменной `result` выше).

Вызовов `return` может быть несколько, например:

```js
function checkAge(age) {
  if (age >= 18) {
    return true;
  } else {
    return confirm("А родители разрешили?");
  }
}

let age = prompt("Сколько вам лет?", 18);

if (checkAge(age)) {
  alert("Доступ получен");
} else {
  alert("Доступ закрыт");
}
```

Возможно использовать `return` и без значения. Это приведёт к немедленному выходу из функции.

Например:

```js
function showMovie(age) {
  if (!checkAge(age)) {
    return;
  }

  alert("Вам показывается кино"); // (\*)
  // ...
}
```

В коде выше, если `checkAge(age)` вернёт `false`, `showMovie` не выполнит `alert`.

> [!NOTE]
>
> Результат функции с пустым `return` или без него – `undefined`
> Если функция не возвращает значения, это всё равно, как если бы она возвращала `undefined`:
>
> ```js
> function doNothing() {
>   /* пусто */
> }
>
> alert(doNothing() === undefined); // true
> ```
>
> Пустой `return` аналогичен `return undefined`:
>
> ```js
> function doNothing() {
>   return;
> }
>
> alert(doNothing() === undefined); // true
> ```

> [!WARNING]
>
> Никогда не добавляйте перевод строки между `return` и его значением
> Для длинного выражения в `return` может быть заманчиво разместить его на нескольких отдельных строках, например так:
>
> ```plaintext
> return
> (some + long + expression + or + whatever \* f(a) + f(b))
> ```
>
> Код не выполнится, потому что интерпретатор JavaScript подставит точку с запятой после `return`. Для него это будет выглядеть так:
>
> ```plaintext
> return;
> (some + long + expression + or + whatever \* f(a) + f(b))
> ```
>
> Таким образом, это фактически стало пустым `return`.
>
> Если мы хотим, чтобы возвращаемое выражение занимало несколько строк, нужно начать его на той же строке, что и `return`. Или, хотя бы, поставить там открывающую скобку, вот так:
>
> ```plaintext
> return (
>     some + long + expression
>     + or +
>     whatever * f(a) + f(b)
>     );
> ```
>
> И тогда всё сработает, как задумано.

#### Множественные возвращаемые значения

JavaScript не поддерживает множественные возвращаемые значения напрямую. Однако, можно возвращать объект или массив, содержащий несколько значений.

**Пример с использованием объекта:**

```javascript
function getUser() {
  return {
    name: "John",
    age: 30,
  };
}

const user = getUser();
console.log(user.name); // Вывод: John
console.log(user.age); // Вывод: 30
```

**Пример с использованием массива:**

```javascript
function getCoordinates() {
  return [50.45, 30.52];
}

const [latitude, longitude] = getCoordinates();
console.log(latitude); // Вывод: 50.45
console.log(longitude); // Вывод: 30.52
```

---

### 4. **Псевдомассив `arguments` в функциях**

Псевдомассив `arguments` — это специальный объект, доступный внутри обычных функций (не стрелочных), который содержит все аргументы, переданные в функцию. Он похож на массив, но не является настоящим массивом, поэтому у него нет методов массива, таких как `map`, `filter` или `reduce`. Давайте разберем эту тему подробнее.

#### 1. **Что такое `arguments`?**

`arguments` — это объект, который доступен внутри тела функции и содержит все переданные в неё аргументы. Он похож на массив, но это псевдомассив, так как:

- У него есть свойство `length`, которое указывает количество переданных аргументов.
- К элементам можно обращаться по индексу, как в массиве (`arguments[0]`, `arguments[1]` и т.д.).
- У него нет методов массива, таких как `push`, `pop`, `forEach` и других.

#### 2. **Пример использования `arguments`**

Рассмотрим пример функции, которая использует `arguments` для работы с переданными аргументами.

```javascript
function sum() {
  let total = 0;
  for (let i = 0; i < arguments.length; i++) {
    total += arguments[i];
  }
  return total;
}

console.log(sum(1, 2, 3)); // 6
console.log(sum(10, 20)); // 30
```

Здесь:

- `arguments` содержит все переданные аргументы: `1, 2, 3` или `10, 20`.
- Мы используем цикл `for` для перебора элементов `arguments` и вычисления суммы.

#### 3. **Свойства и особенности `arguments`**

a) **Свойство `length`**

Свойство `length` указывает количество переданных аргументов.

```javascript
function logArgs() {
  console.log(`Количество аргументов: ${arguments.length}`);
}

logArgs(1, 2, 3); // Количество аргументов: 3
logArgs("a", "b"); // Количество аргументов: 2
```

b) **Доступ к элементам по индексу**

Элементы `arguments` можно получить по индексу, как в массиве.

```javascript
function logFirstArg() {
  console.log(`Первый аргумент: ${arguments[0]}`);
}

logFirstArg(10, 20, 30); // Первый аргумент: 10
```

c) **Псевдомассив, а не массив**

`arguments` не является настоящим массивом, поэтому у него нет методов массива, таких как `map`, `filter`, `reduce` и других.

```javascript
function tryArrayMethods() {
  arguments.map((arg) => console.log(arg)); // Ошибка: arguments.map is not a function
}

tryArrayMethods(1, 2, 3);
```

Чтобы использовать методы массива, нужно преобразовать `arguments` в настоящий массив.

#### 4. **Преобразование `arguments` в массив**

Для работы с `arguments` как с массивом его можно преобразовать в настоящий массив. Это можно сделать несколькими способами.

a) **Использование `Array.from`**

`Array.from` создает массив из псевдомассива.

```javascript
function sum() {
  const args = Array.from(arguments);
  return args.reduce((acc, val) => acc + val, 0);
}

console.log(sum(1, 2, 3)); // 6
```

b) **Использование оператора `...` (spread)**

Оператор `...` (spread) позволяет преобразовать `arguments` в массив.

```javascript
function sum() {
  const args = [...arguments];
  return args.reduce((acc, val) => acc + val, 0);
}

console.log(sum(1, 2, 3)); // 6
```

c) **Использование `Array.prototype.slice`**

Метод `slice` можно использовать для преобразования `arguments` в массив.

```javascript
function sum() {
  const args = Array.prototype.slice.call(arguments);
  return args.reduce((acc, val) => acc + val, 0);
}

console.log(sum(1, 2, 3)); // 6
```

#### 5. **Стрелочные функции и `arguments`**

Стрелочные функции **не имеют своего `arguments`**. Если попытаться использовать `arguments` внутри стрелочной функции, он будет ссылаться на `arguments` из окружающей обычной функции (если она есть).

**Пример:**

```javascript
function outerFunction() {
  const innerFunction = () => {
    console.log(arguments); // arguments из outerFunction
  };
  innerFunction();
}

outerFunction(1, 2, 3); // Вывод: [1, 2, 3]
```

Если стрелочная функция используется вне обычной функции, `arguments` будет недоступен:

```javascript
const arrowFunction = () => {
  console.log(arguments); // Ошибка: arguments is not defined
};

arrowFunction(1, 2, 3);
```

#### 6. **Rest-параметры как альтернатива `arguments`**

Начиная с ES6, вместо `arguments` рекомендуется использовать rest-параметры. Rest-параметры позволяют собирать все переданные аргументы в настоящий массив.

**Пример:**

```javascript
function sum(...args) {
  return args.reduce((acc, val) => acc + val, 0);
}

console.log(sum(1, 2, 3)); // 6
```

Преимущества rest-параметров:

- Это настоящий массив, поэтому доступны все методы массива.
- Код становится более читаемым и современным.

#### 7. **Итог**

- `arguments` — это псевдомассив, доступный внутри обычных функций, который содержит все переданные аргументы.
- У `arguments` есть свойство `length` и доступ к элементам по индексу, но нет методов массива.
- `arguments` можно преобразовать в массив с помощью `Array.from`, оператора `...` или `Array.prototype.slice`.
- Стрелочные функции не имеют своего `arguments`.
- В современных проектах рекомендуется использовать rest-параметры (`...args`) вместо `arguments`.

**Примеры:**

```javascript
// Использование arguments
function logArgs() {
  console.log(arguments);
}

logArgs(1, 2, 3); // [1, 2, 3]

// Преобразование arguments в массив
function sum() {
  const args = [...arguments];
  return args.reduce((acc, val) => acc + val, 0);
}

console.log(sum(1, 2, 3)); // 6

// Использование rest-параметров
function sumRest(...args) {
  return args.reduce((acc, val) => acc + val, 0);
}

console.log(sumRest(1, 2, 3)); // 6
```

### 5. **Примеры реального использования в коде**

#### Пример 1: Функция для вычисления средней оценки

```javascript
function calculateAverage(...scores) {
  const sum = scores.reduce((acc, score) => acc + score, 0);
  return sum / scores.length;
}

const average = calculateAverage(80, 90, 75);
console.log(average); // Вывод: 81.66666666666667
```

#### Пример 2: Функция для форматирования имени пользователя

```javascript
function formatUserName(firstName, lastName = "Doe") {
  return `${firstName} ${lastName}`;
}

console.log(formatUserName("John")); // Вывод: John Doe
console.log(formatUserName("Jane", "Smith")); // Вывод: Jane Smith
```

#### Пример 3: Функция для создания объекта пользователя

```javascript
function createUser(name, age) {
  return {
    name,
    age,
    isActive: true,
  };
}

const user = createUser("Alice", 28);
console.log(user); // Вывод: { name: "Alice", age: 28, isActive: true }
```

#### Пример 4: Функция для поиска максимального числа

```javascript
function findMax(...numbers) {
  return Math.max(...numbers);
}

console.log(findMax(1, 5, 3, 9, 2)); // Вывод: 9
```

#### Пример 5: Функция для фильтрации пользователей по возрасту

```javascript
function filterAdults(users) {
  return users.filter((user) => user.age >= 18);
}

const users = [
  { name: "John", age: 17 },
  { name: "Jane", age: 22 },
  { name: "Alex", age: 15 },
];

const adults = filterAdults(users);
console.log(adults); // Вывод: [{ name: "Jane", age: 22 }]
```

#### Пример 6: Функция для форматирования даты

```javascript
function formatDate(date = new Date()) {
  return date.toISOString().split("T")[0];
}

console.log(formatDate()); // Вывод: текущая дата в формате YYYY-MM-DD
console.log(formatDate(new Date("2022-01-01"))); // Вывод: 2022-01-01
```

---

## **Практика**

### 1. **Объявление и вызов функций**

#### 1. **Приветствие пользователя**

Напишите функцию `greet`, которая принимает один параметр `name` и выводит строку "Привет, `name`!".

```javascript
function greet(name) {}

greet("Алексей");
```

#### 2. **Сложение двух чисел**

Напишите функцию `add`, которая принимает два параметра `a` и `b` и возвращает их сумму.

```javascript
function add(a, b) {}

console.log(add(3, 7)); // Вывод: 10
```

#### 3. **Проверка на четность**

Напишите функцию `isEven`, которая принимает один параметр `number` и возвращает `true`, если число четное, и `false` в противном случае.

```javascript
function isEven(number) {}

console.log(isEven(4)); // Вывод: true
console.log(isEven(7)); // Вывод: false
```

#### 4. **Поиск подстроки**

Напишите функцию `containsSubstring`, которая принимает две строки `str` и `substr` и возвращает `true`, если `substr` содержится в `str`, и `false` в противном случае.

```javascript
function containsSubstring(str, substr) {}

console.log(containsSubstring("Hello World", "World")); // Вывод: true
console.log(containsSubstring("Hello World", "world")); // Вывод: false
```

#### 5. **Подсчет количества символов**

Напишите функцию `countCharacters`, которая принимает строку `str` и возвращает объект, содержащий количество каждого символа в строке.

```javascript
function countCharacters(str) {}

console.log(countCharacters("hello")); // Вывод: { h: 1, e: 1, l: 2, o: 1 }
```

#### 6. **Подсчет слов в строке**

Напишите функцию `countWords`, которая принимает строку `str` и возвращает количество слов в строке.

```javascript
function countWords(str) {}

console.log(countWords("Hello world! How are you?")); // Вывод: 5
```

#### 7. **Обязателен ли "else"?**

Следующая функция возвращает `true`, если параметр `age` больше `18`.

В ином случае она запрашивает подтверждение через `confirm` и возвращает его результат:

```js
function checkAge(age) {
  if (age > 18) {
    return true;
  } else {
    // ...
    return confirm("Родители разрешили?");
  }
}
```

Будет ли эта функция работать как-то иначе, если убрать `else`?

```js
function checkAge(age) {
  if (age > 18) {
    return true;
  }
  // ...
  return confirm("Родители разрешили?");
}
```

Есть ли хоть одно отличие в поведении этого варианта?

#### 8. **Перепишите функцию, используя оператор '?' или '||'**

Следующая функция возвращает `true`, если параметр `age` больше `18`.

В ином случае она задаёт вопрос `confirm` и возвращает его результат.

```js
function checkAge(age) {
  if (age > 18) {
    return true;
  } else {
    return confirm("Родители разрешили?");
  }
}
```

Перепишите функцию, чтобы она делала то же самое, но без `if`, в одну строку.

Сделайте два варианта функции `checkAge`:

Используя оператор `?`
Используя оператор `||`

#### 9. **Функция min(a, b)**

Напишите функцию `min(a,b)`, которая возвращает меньшее из чисел `a` и `b`.

Пример вызовов:

```js
min(2, 5) == 2;
min(3, -1) == -1;
min(1, 1) == 1;
```

#### 10. **Функция pow(x,n)**

Напишите функцию `pow(x,n)`, которая возводит `x` в степень `n` и возвращает результат.

```js
pow(3, 2) = 3 * 3 = 9
pow(3, 3) = 3 * 3 * 3 = 27
pow(1, 100) = 1 * 1 * ... * 1 = 1
```

Создайте страницу, которая запрашивает `x` и `n`, а затем выводит результат `pow(x,n)`.

P.S. В этой задаче функция обязана поддерживать только натуральные значения `n`, т.е. целые от `1` и выше.

---

### 2. **Аргументы, параметры и возвращаемые значения**

#### 1. **Сравнение двух чисел**

Сделайте функцию, которая параметрами принимает 2 числа. Если эти числа равны - пусть функция вернет true, а если не равны - false.

```js
console.log(isEqual(2, 3));
```

#### 2. **Проверка максимального значения суммы двух чисел**

Сделайте функцию, которая параметрами принимает 2 числа. Если их сумма больше 10 - пусть вернет true, а если нет то - false.

```js
console.log(isSumBigger10(8, 3));
```

#### 3. **Проверка на знак числа**

Сделайте функцию, которая параметром принимает число и проверяет - отрицательное оно или нет.
Если отрицательное - пусть функция вернет true, а если нет - false.

```js
console.log(isNegative(-2));
```

#### 4. **Проверка на дипазон**

Сделайте функцию isNumberInRange, которая параметром принимает число и проверяет, что оно больше нуля и меньше 10.
Если это так - пусть функция возвращает true, если не так - false.

```js
console.log(isNumberInRange(5));
```

#### 5. **Фильтрация массива**

Дан массив с числами. Запишите в новый массив только те числа, которые больше нуля и меньше 10-ти.
Для этого используйте вспомогательную функцию isNumberInRange из предыдущей задачи.

```js
const arr = [1, 2, -3, 4, 11, 8];

console.log(arrInRange(arr));
```

#### 6. **Приведение суммы чисел**

Дано число. Сложите его цифры. Если сумма получилась более 9-ти, опять сложите его цифры.
И так, пока сумма не станет однозначным числом (9 и менее).

```js
console.log(getDigitsSum(678)); // 3
```

#### 7. **Поиск суммы цифр в диапазоне**

Найдите все года от 1 до 2020, сумма цифр которых равна 13.
Для этого используйте вспомогательную функцию getDigitsSum из предыдущей задачи

#### 8. **Поиск делителей числа**

Сделайте функцию getDivisors, которая параметром принимает число и
возвращает массив его делителей (чисел, на которое делится данное число).

```js
console.log(getDivisors(100));
```

#### 9. **Среднее значение**

Напишите функцию `average`, которая принимает произвольное количество чисел и возвращает их среднее значение.

```javascript
function average(...numbers) {}

console.log(average(1, 2, 3, 4, 5)); // Вывод: 3
```

#### 10. **Объединение массивов**

Напишите функцию `mergeArrays`, которая принимает два массива и возвращает один массив, содержащий все элементы обоих массивов.

```javascript
function mergeArrays(array1, array2) {}

console.log(mergeArrays([1, 2, 3], [4, 5, 6])); // Вывод: [1, 2, 3, 4, 5, 6]
```

#### 11. **Переворот строки**

Напишите функцию `reverseString`, которая принимает строку и возвращает перевернутую строку.

```javascript
function reverseString(str) {}

console.log(reverseString("hello")); // Вывод: olleh
```

#### 12. **Проверка массива**

Напишите функцию `isArray`, которая проверяет, является ли переданный аргумент массивом. Возвращает `true`, если является, и `false` в противном случае.

```javascript
function isArray(arg) {}

console.log(isArray([1, 2, 3])); // Вывод: true
console.log(isArray("hello")); // Вывод: false
```

#### 13. **Нахождение минимального числа**

Напишите функцию `findMin`, которая принимает произвольное количество чисел и возвращает наименьшее из них.

```javascript
function findMin(...numbers) {}

console.log(findMin(3, 5, 1, 8, 2)); // Вывод: 1
```

#### 14. **Перевод градусов Цельсия в Фаренгейты**

Напишите функцию `celsiusToFahrenheit`, которая принимает температуру в градусах Цельсия и возвращает температуру в Фаренгейтах.

```javascript
function celsiusToFahrenheit(celsius) {}

console.log(celsiusToFahrenheit(0)); // Вывод: 32
console.log(celsiusToFahrenheit(100)); // Вывод: 212
```

#### 15. **Проверка символа**

Напишите функцию `isVowel`, которая принимает символ и проверяет, является ли он гласной. Возвращает `true`, если является, и `false` в противном случае.

```javascript
function isVowel(char) {}

console.log(isVowel("a")); // Вывод: true
console.log(isVowel("b")); // Вывод: false
```

#### 16. **Объединение строк**

Напишите функцию `joinStrings`, которая принимает произвольное количество строк и возвращает одну строку, содержащую все переданные строки, разделенные пробелом.

```javascript
function joinStrings(...strings) {}

console.log(joinStrings("Hello", "world", "JavaScript")); // Вывод: Hello world JavaScript
```
