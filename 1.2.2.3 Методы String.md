# **1.2.2.2 Методы String**

> [Index](./0%20Index.md)
> || [1.2.2 Типы данных](./1.2.2%20Типы%20данных.md)

## **Методы объекта `String` в JavaScript**

Объект `String` предоставляет множество методов для работы с текстом, включая манипуляцию строками, поиск, замену, преобразование регистров и многое другое.

---

## **1. Получение длины строки**

### **`str.length`**

Возвращает количество символов в строке.

```javascript
let text = 'Hello, World!';
console.log(text.length); // 13
```

> [!WARNING]
>
> **`length` — это свойство**
>
> Бывает так, что люди с практикой в других языках случайно пытаются вызвать его, добавляя круглые скобки: они пишут `str.length()` вместо `str.length`. **Это не работает.**
>
> Так как `str.length` — это числовое свойство, а не функция, добавлять скобки не нужно.

## **2. Извлечение подстроки**

> [!TIP]
>
> **Какой метод выбрать?**
>
> Все эти методы эффективно выполняют задачу. Формально у метода `substr` есть небольшой недостаток: он описан не в собственно спецификации JavaScript, а в приложении к ней — `Annex B`. Это приложение описывает возможности языка для использования в браузерах, существующие в основном по историческим причинам. Таким образом, в другом окружении, отличном от браузера, он может не поддерживаться. Однако на практике он работает везде.
>
> Из других вариантов, `slice` более гибок, он поддерживает отрицательные аргументы, и его короче писать. Так что, в принципе, можно запомнить только его.

### **`charAt(index)`**

Возвращает символ из строки по указанному индексу.

```javascript
let text = 'JavaScript';
console.log(text.charAt(4)); // "S"
```

### **`charCodeAt(index)`**

Возвращает код символа (UTF-16) по указанному индексу.

```javascript
let text = 'ABC';
console.log(text.charCodeAt(0)); // 65
```

### **`str.substring(start, [end])`**

Возвращает часть строки между `start` и `end` (не включая) `end`.

Это — почти то же, что и `slice`, но можно задавать `start` больше `end`.
Если start больше `end`, то метод `substring` сработает так, как если бы аргументы были поменяны местами.

> [!CAUTION]
>
> Отрицательные значения `substring`, в отличие от `slice`, не поддерживает, они интерпретируются как `0`.

```javascript
let text = 'JavaScript';
console.log(text.substring(0, 4)); // "Java"

let str = 'stringify';

// для substring эти два примера — одинаковы
alert(str.substring(2, 6)); // "ring"
alert(str.substring(6, 2)); // "ring"

// …но не для slice:
alert(str.slice(2, 6)); // "ring" (то же самое)
alert(str.slice(6, 2)); // "" (пустая строка)
```

### **`str.substr(start, [length])`**

Возвращает часть строки от `start` длины `length`.

В противоположность предыдущим методам, этот позволяет указать длину вместо конечной позиции:

```js
let str = 'stringify';
// ring, получаем 4 символа, начиная с позиции 2
alert(str.substr(2, 4));
```

Значение первого аргумента может быть отрицательным, тогда позиция определяется с конца:

```js
let str = 'stringify';
// gi, получаем 2 символа, начиная с позиции 4 с конца строки
alert(str.substr(-4, 2));
```

Этот метод находится в `Annex B` спецификации языка. Это означает, что его должны поддерживать только браузерные движки JavaScript, и использовать его не рекомендуется. Но на практике он поддерживается везде.

### **`str.slice(start, [end])`**

Возвращает часть строки от `start` до (не включая) `end`. Поддерживает отрицательные индексы (счёт от конца строки).

```javascript
let text = 'JavaScript';
console.log(text.slice(0, 4)); // "Java"
console.log(text.slice(-6, -1)); // "Scrip"
```

Если аргумент end отсутствует, slice возвращает символы до конца строки:

```js
let str = 'stringify';
alert(str.slice(2)); // ringify, с позиции 2 и до конца
```

### **`split(separator, [limit])`**

Разбивает строку на массив подстрок.

```javascript
let text = 'apple,banana,cherry';
console.log(text.split(',')); // ["apple", "banana", "cherry"]
```

---

## **3. Поиск и проверка**

### **`str.indexOf(searchValue, [start])`**

Он ищет подстроку `substr` в строке `str`, начиная с позиции `pos`, и возвращает позицию, на которой располагается совпадение, либо `-1` при отсутствии совпадений.

```javascript
let str = 'Widget with id';

alert(str.indexOf('Widget')); // 0, потому что подстрока 'Widget' найдена в начале
alert(str.indexOf('widget')); // -1, совпадений нет, поиск чувствителен к регистру

alert(str.indexOf('id')); // 1, подстрока "id" найдена на позиции 1 (..idget with id)
```

Необязательный второй аргумент позволяет начать поиск с определённой позиции.

Например, первое вхождение "id" — на позиции 1. Для того, чтобы найти следующее, начнём поиск с позиции 2:

```js
let str = 'Widget with id';

alert(str.indexOf('id', 2)); // 12
```

Чтобы найти все вхождения подстроки, нужно запустить indexOf в цикле. Каждый раз, получив очередную позицию, начинаем новый поиск со следующей:

```js
let str = 'Ослик Иа-Иа посмотрел на виадук';

let target = 'Иа'; // цель поиска

let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos == -1) break;

  alert(`Найдено тут: ${foundPos}`);
  pos = foundPos + 1; // продолжаем со следующей позиции
}
```

Тот же алгоритм можно записать и короче:

```js
let str = 'Ослик Иа-Иа посмотрел на виадук';
let target = 'Иа';

let pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert(pos);
}
```

При проверке `indexOf` в условии `if` есть небольшое неудобство. Такое условие не будет работать:

```js
let str = 'Widget with id';

if (str.indexOf('Widget')) {
  alert('Совпадение есть'); // не работает
}
```

Мы ищем подстроку "`Widget`", и она здесь есть, прямо на позиции `0`. Но `alert` не показывается, т. к. `str.indexOf("Widget")` возвращает `0`, и `if` решает, что тест не пройден.

Поэтому надо делать проверку на `-1`:

```js
let str = 'Widget with id';

if (str.indexOf('Widget') != -1) {
  alert('Совпадение есть'); // теперь работает
}
```

#### **Трюк с побитовым НЕ**

Существует старый трюк с использованием побитового оператора НЕ — `~`. Он преобразует число в 32-разрядное целое со знаком (signed 32-bit integer). Дробная часть, в случае, если она присутствует, отбрасывается. Затем все биты числа инвертируются.

На практике это означает простую вещь: для 32-разрядных целых чисел значение `~n` равно `-(n+1)`.

В частности:

```js
alert(~2); // -3, то же, что -(2+1)
alert(~1); // -2, то же, что -(1+1)
alert(~0); // -1, то же, что -(0+1)
alert(~-1); // 0, то же, что -(-1+1)
```

Таким образом, `~n` равняется `0` только при `n == -1` (для любого `n`, входящего в 32-разрядные целые числа со знаком).

Соответственно, прохождение проверки `if ( ~str.indexOf("…") )` означает, что результат `indexOf` отличен от `-1`, совпадение есть.

Это иногда применяют, чтобы сделать проверку `indexOf` компактнее:

```js
let str = 'Widget';

if (~str.indexOf('Widget')) {
  alert('Совпадение есть'); // работает
}
```

Обычно использовать возможности языка каким-либо неочевидным образом не рекомендуется, но этот трюк широко используется в старом коде, поэтому его важно понимать.

Просто запомните: `if (~str.indexOf(…))` означает **«если найдено»**.

Впрочем, если быть точнее, из-за того, что большие числа обрезаются до 32 битов оператором `~`, существуют другие числа, для которых результат тоже будет 0, самое маленькое из которых — `~4294967295=0`. Поэтому такая проверка будет правильно работать только для строк меньшей длины.

На данный момент такой трюк можно встретить только в старом коде, потому что в новом он просто не нужен: есть метод `.includes`

### **`str.lastIndexOf(searchValue, [start])`**

Возвращает индекс последнего вхождения подстроки, ищет с конца строки к её началу.

```javascript
let text = 'JavaScript is great!';
console.log(text.lastIndexOf('is')); // 12
```

### **`str.includes(searchValue, [start])`**

Проверяет, содержит ли строка подстроку. Возвращает `true` или `false`. Это — правильный выбор, если нам необходимо проверить, есть ли совпадение, но позиция не нужна:

```javascript
alert('Widget with id'.includes('Widget')); // true
alert('Hello'.includes('Bye')); // false

let text = 'Hello, World!';
console.log(text.includes('World')); // true
```

Необязательный второй аргумент str.includes позволяет начать поиск с определённой позиции:

```js
alert('Midget'.includes('id')); // true
alert('Midget'.includes('id', 3)); // false, поиск начат с позиции 3
```

### **`startsWith(searchValue, [start])`**

Проверяет, начинается ли строка с указанной подстроки.

```javascript
let text = 'Hello, World!';
console.log(text.startsWith('Hello')); // true
```

### **`endsWith(searchValue, [length])`**

Проверяет, заканчивается ли строка указанной подстрокой.

```javascript
let text = 'Hello, World!';
console.log(text.endsWith('!')); // true
```

---

## **4. Изменение строки**

### **`toUpperCase()`**

Преобразует строку в верхний регистр.

```javascript
let text = 'hello';
console.log(text.toUpperCase()); // "HELLO"
```

### **`toLowerCase()`**

Преобразует строку в нижний регистр.

```javascript
let text = 'HELLO';
console.log(text.toLowerCase()); // "hello"
```

Если мы захотим перевести в нижний регистр какой-то конкретный символ:

```js
alert('Interface'[0].toLowerCase()); // 'i'
```

### **`trim()`**

Удаляет пробелы в начале и конце строки.

```javascript
let text = '   Hello   ';
console.log(text.trim()); // "Hello"
```

### **`trimStart()` / `trimEnd()`**

Удаляют пробелы только в начале или в конце строки.

```javascript
let text = '   Hello   ';
console.log(text.trimStart()); // "Hello   "
console.log(text.trimEnd()); // "   Hello"
```

### **`replace(searchValue, replaceValue)`**

Заменяет первое вхождение подстроки.

```javascript
let text = 'Hello, World!';
console.log(text.replace('World', 'JavaScript')); // "Hello, JavaScript!"
```

### **`replaceAll(searchValue, replaceValue)`**

Заменяет все вхождения подстроки.

```javascript
let text = 'apple apple apple';
console.log(text.replaceAll('apple', 'banana')); // "banana banana banana"
```

---

## **5. Повторение и заполнение строки**

### **`repeat(count)`**

Повторяет строку указанное количество раз.

```javascript
let text = 'Hi ';
console.log(text.repeat(3)); // "Hi Hi Hi "
```

### **`padStart(targetLength, padString)`**

Добавляет символы в начало строки до указанной длины.

```javascript
let text = '5';
console.log(text.padStart(3, '0')); // "005"
```

### **`padEnd(targetLength, padString)`**

Добавляет символы в конец строки до указанной длины.

```javascript
let text = '5';
console.log(text.padEnd(3, '0')); // "500"
```

---

## **6. Строки как шаблоны**

### **Шаблонные литералы с `` ` ` ``**

Шаблонные строки позволяют включать выражения через `${}`.

```javascript
let name = 'John';
let age = 30;
console.log(`My name is ${name}, and I am ${age} years old.`);
// "My name is John, and I am 30 years old."
```

---

## **7. Сравнение строк**

Как мы знаем из главы Операторы сравнения, строки сравниваются посимвольно в алфавитном порядке.

Тем не менее, есть некоторые нюансы.

1. Строчные буквы больше заглавных:

   ```js
   alert('a' > 'Z'); // true
   ```

2. Буквы, имеющие диакритические знаки, идут «не по порядку»:

   ```js
   alert('Österreich' > 'Zealand'); // true
   ```

   Это может привести к своеобразным результатам при сортировке названий стран: нормально было бы ожидать, что `Zealand` будет после `Österreich` в списке.

Чтобы разобраться, что происходит, давайте ознакомимся с внутренним представлением строк в JavaScript.

Строки кодируются в `UTF-16`. Таким образом, у любого символа есть соответствующий код. Есть специальные методы, позволяющие получить символ по его коду и наоборот.

```js
str.codePointAt(pos); // Возвращает код для символа, находящегося на позиции `pos`:

// одна и та же буква в нижнем и верхнем регистре
// будет иметь разные коды
alert('z'.codePointAt(0)); // 122
alert('Z'.codePointAt(0)); // 90
String.fromCodePoint(code);
```

Создаёт символ по его коду `code`

```js
alert(String.fromCodePoint(90)); // Z
```

Давайте сделаем строку, содержащую символы с кодами от `65` до `220` — это латиница и ещё некоторые распространённые символы:

```js
let str = '';

for (let i = 65; i <= 220; i++) {
  str += String.fromCodePoint(i);
}
alert(str);
// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^\_`abcdefghijklmnopqrstuvwxyz{|}~
// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ
```

Как видите, сначала идут заглавные буквы, затем несколько спецсимволов, затем строчные и `Ö` ближе к концу вывода.

Теперь очевидно, почему `a > Z`.

Символы сравниваются по их кодам. Больший код — больший символ. Код `a (97)` больше кода `Z (90)`.

- Все строчные буквы идут после заглавных, так как их коды больше.
- Некоторые буквы, такие как `Ö`, вообще находятся вне основного алфавита. У этой буквы код больше, чем у любой буквы от `a` до `z`.

### **Правильное сравнение**

«Правильный» алгоритм сравнения строк сложнее, чем может показаться, так как разные языки используют разные алфавиты.

Поэтому браузеру нужно знать, какой язык использовать для сравнения.

К счастью, все современные браузеры (для IE10− нужна дополнительная библиотека **Intl.JS**) поддерживают стандарт **ECMA 402**, обеспечивающий правильное сравнение строк на разных языках с учётом их правил.

Для этого есть соответствующий метод.

Вызов `str.localeCompare(str2)` возвращает число, которое показывает, какая строка больше в соответствии с правилами языка:

- Отрицательное число, если `str` меньше `str2`.
- Положительное число, если `str` больше `str2`.
- `0`, если строки равны.

Например:

```js
alert('Österreich'.localeCompare('Zealand')); // -1
```

У этого метода есть два дополнительных аргумента, которые указаны в [документации](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare).

- **Первый** позволяет указать язык (по умолчанию берётся из окружения) — от него зависит порядок букв.
- **Второй** — определить дополнительные правила, такие как чувствительность к регистру, а также следует ли учитывать различия между `"a"` и `"á"`.

---

## **8. Пример полного использования методов**

```javascript
let text = '   JavaScript is awesome!   ';
console.log(text.trim().toUpperCase()); // "JAVASCRIPT IS AWESOME!"
console.log(text.includes('JavaScript')); // true
console.log(text.replace('awesome', 'great')); // "   JavaScript is great!   "
console.log(text.split(' ')); // ["", "", "", "JavaScript", "is", "awesome!", "", "", ""]
console.log('123'.padStart(5, '0')); // "00123"
```

Если вам нужно пояснить какой-то метод подробнее или привести дополнительные примеры, дайте знать!
