# **1.3.3 Оператор `switch`**

> [Index](./0%20Index.md)
> || [1.3 Управляющие конструкции](./1.3%20Управляющие%20конструкции.md)

Конструкция `switch` заменяет собой сразу несколько `if`. Она представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами.

Оператор `switch` используется для выбора одного из нескольких блоков кода для выполнения в зависимости от значения переменной или выражения.

---

## **Синтаксис**

Конструкция `switch` имеет один или более блок `case` и необязательный блок `default`.

Выглядит она так:

```javascript
switch (expression) {
    case value1:
        // код, который выполнится, если expression === value1
        break;
    case value2:
        // код, который выполнится, если expression === value2
        break;
    default:
    // код, который выполнится, если expression не совпало ни с одним из значений
}
```

-   `expression` — выражение, результат которого проверяется на строгое равенство с каждым `case`.
-   `value` — значение, с которым сравнивается `expression`. Выполнение начинается от соответствующей директивы `case` и продолжается до ближайшего `break` (или до конца `switch`).
-   `break` — предотвращает выполнение последующих блоков `case`. Если его не указать, исполнение продолжится до ближайшего `break` или завершения оператора `switch`.
-   `default` — необязательный блок, который выполняется, если ни один из `case` не подошел.

---

## **Простая демонстрация**

```javascript
let a = 2 + 2;

switch (a) {
    case 3:
        alert('Маловато');
        break;
    case 4:
        alert('В точку!');
        break;
    case 5:
        alert('Перебор');
        break;
    default:
        alert('Нет таких значений');
}
// Вывод: `В точку!`
```

Здесь оператор `switch` последовательно сравнит `a` со всеми вариантами из `case`.

Сначала `3`, затем — так как нет совпадения — `4`. Совпадение найдено, будет выполнен этот вариант, со строки `alert('В точку!')` и далее, до ближайшего `break`, который прервёт выполнение.

Если `break` нет, то выполнение пойдёт ниже по следующим `case`, при этом остальные проверки игнорируются.

---

## **Тип имеет значение**

Нужно отметить, что проверка на равенство всегда строгая `===`. Значения должны быть одного типа, чтобы выполнялось равенство.

Для примера, давайте рассмотрим следующий код:

```js
let arg = prompt('Введите число?');
switch (arg) {
    case '0':
    case '1':
        alert('Один или ноль');
        break;
    case '2':
        alert('Два');
        break;
    case 3:
        alert('Никогда не выполнится!');
        break;
    default:
        alert('Неизвестное значение');
}
```

Для `'0'` и `'1'` выполнится первый `alert`. Для `'2'` — второй `alert`. Но для `3`, результат выполнения `prompt` будет строка `"3"`, которая не соответствует строгому равенству `===` с числом `3`. Таким образом, мы имеем «мёртвый код» в `case 3`! Выполнится вариант `default`.

---

## **Условия в `case`**

Сложные условия, такие как диапазоны, можно реализовать через логические операторы:

```javascript
const x = 15;

switch (true) {
    case x > 10 && x < 20:
        console.log('x находится в диапазоне от 10 до 20');
        break;
    case x >= 20:
        console.log('x больше или равен 20');
        break;
    default:
        console.log('x меньше или равен 10');
}
// Вывод: `x находится в диапазоне от 10 до 20`
```

Но в данном контексте конструкция `switch` требует `true`, потому что она используется для проверки сложных условий. Обычный `switch` сравнивает значение `expression` с каждым `case` на строгое равенство `===`. Однако для проверки диапазонов или более сложных условий это не подходит, так как они не представляют собой конкретные значения, которые можно проверить на равенство.

Чтобы обойти это ограничение, `true` указывается как значение для проверки в `switch`. Каждый `case` затем представляет собой логическое выражение, которое возвращает `true` или `false`.

**Например**
Если переписать предыдущий пример где в значении `expression` подставить `x`

```js
const x = 15;

switch (x) {
    case x > 10 && x < 20:
        console.log('x находится в диапазоне от 10 до 20');
        break;
    case x >= 20:
        console.log('x больше или равен 20');
        break;
    default:
        console.log('x меньше или равен 10');
}
```

то отработает только `default`

> [!NOTE]
>
> **Любое выражение может быть аргументом для `switch/case`**
> И `switch` и `case` допускают любое выражение в качестве аргумента.
>
> Например:
>
> ```js
> let a = '1';
> let b = 0;
>
> switch (+a) {
>     case b + 1:
>         alert(
>             'Выполнится, т.к. значением +a будет 1, что в точности равно b+1',
>         );
>         break;
>
>     default:
>         alert('Это не выполнится');
> }
> ```
>
> В этом примере выражение `+a` вычисляется в `1`, что совпадает с выражением `b + 1` в `case`, и следовательно, код в этом блоке будет выполнен. Но такая запись ухудшает читаемость кода, поэтому не рекомендуется к использованию.

---

## **Пропуск `break`**

Если пропустить `break`, выполнение продолжится до следующего `case`:

```javascript
const score = 85;

switch (true) {
    case score >= 90:
        console.log('Отлично!');
        break;
    case score >= 80:
        console.log('Хорошо!');
    case score >= 70:
        console.log('Удовлетворительно.');
        break;
    default:
        console.log('Плохо.');
}

// Вывод:
// Хорошо!
// Удовлетворительно.
```

---

## **Пропуск default**

Если пропустить блок `default`, то при отсутствии совпадений в блоке `switch` он закончит свою работу без выпадения ошибки

```js
let arg = '5';
switch (arg) {
    case '1':
        alert('Один');
        break;
    case '2':
        alert('Два');
        break;
}
// Ошибок нет
```

---

## **Группировка случаев**

Если несколько `case` выполняют одинаковую логику, можно их сгруппировать:

```javascript
const fruit = 'apple';

switch (fruit) {
    case 'apple': // (*)
    case 'pear':
        console.log('Это фрукт семейства розоцветных.');
        break;
    case 'banana':
    case 'mango':
        console.log('Это тропический фрукт.');
        break;
    default:
        console.log('Неизвестный фрукт.');
}
// Вывод: `Это фрукт семейства розоцветных.`
```

Возможность группировать `case` – это побочный эффект того, как `switch/case` работает без `break`. Здесь выполнение `case 'apple'` начинается со строки `(*)` и продолжается в `case 'pear'`, потому что отсутствует `break`.

---

## **Исключения при использовании switch**

При использовании оператора `switch` возможны исключения, например

```js
const x;

switch (x) {
    case 1:
        console.log('x === 1');
        break;
    case 2:
        console.log('x === 2');
        break;
}
// Ошибка: SyntaxError: Missing initializer in const declaration
```

Если присвоить `x = undefined`, то тип ошибки изменится

```js
const x = undefined;

switch (x) {
    case 1:
        console.log('x === 1');
        break;
    case 2:
        console.log('x === 2');
        break;
}
// Ошибка: ReferenceError: un is not defined
```

Проверка на `undefined` в блоке `switch` будет работать только при наличии `case undefined:`

```js
const x = undefined;

switch (x) {
    case undefined:
        console.log('x === undefined');
        break;
    case 2:
        console.log('x === 2');
        break;
}
```

---

## **Плюсы `switch`**

1. **Читаемость:** Удобен для работы с множеством проверок на равенство.
2. **Оптимизация:** На уровне компилятора может быть оптимизирован лучше, чем `if-else` в некоторых языках.
3. **Удобство группировки:** Легко группировать несколько значений в одном блоке.

---

## **Минусы `switch`**

1. **Непредсказуемое поведение без `break`:** Пропуск `break` может привести к выполнению нежелательного кода.
2. **Сравнение только на строгое равенство:** Для использования сложных условий напрямую, как в `if-else` с применением условных операторов типа `(x > 5)` необходимо в качестве `expression` использовать `true`.
3. **Труден для поддержки:** Большой `switch` может стать трудно читаемым и отлаживаемым.
4. **Не подходит для расширяемости:** Для динамически добавляемых условий нужно переписывать код.

---

## **Почему не рекомендуется использовать `switch`?**

Современные подходы в программировании предлагают альтернативы, такие как:

-   **Объекты или карты (Map):** Это более гибкий и читаемый способ хранения соответствий "значение → действие".
-   **Функции:** Можно использовать объекты с функциями для замены `switch`.

### **Пример: Использование объекта**

```javascript
const actions = {
    1: () => console.log('Понедельник'),
    2: () => console.log('Вторник'),
    3: () => console.log('Среда'),
    default: () => console.log('Неизвестный день'),
};

const day = 3;
(actions[day] || actions.default)();
```

Этот подход позволяет избежать множества блоков `case` и легко добавлять новые условия.

### **Пример: Использование `if-else`**

```javascript
const day = 3;

if (x === 1) {
    console.log('Понедельник');
} else if (x === 2) {
    console.log('Вторник');
} else if (x === 3) {
    console.log('Среда');
} else {
    console.log('Неизвестный день');
}
```

### **Пример: Использование `switch`**

```javascript
const day = 3;

switch (x) {
    case 1:
        console.log('Понедельник');
        break;
    case 2:
        console.log('Вторник');
        break;
    case 3:
        console.log('Среда');
        break;
    default:
        console.log('Неизвестный день');
}
```

### **Сравнение**

1. **Читаемость:** `if-else` и объекты более интуитивно понятны и гибки чем `switch`.
2. **Расширяемость:** Объекты или карты позволяют динамически добавлять новые пары "условие → действие".
3. **Меньше ошибок:** Проблемы с пропущенными `break` исключены при использовании объектов или функций.

---

## **Заключение**

Хотя `switch` может быть полезен в простых ситуациях, таких как статические проверки на равенство, он менее гибок, чем современные альтернативы, такие как объекты или функции. По мере усложнения логики лучше выбирать более универсальные подходы.

---

## **Задачи**

1. Напишите `switch`, который выведет название месяца по номеру (1 — январь, 2 — февраль и т.д.).
2. Реализуйте `switch` для проверки типа данных переменной (`number`, `string`, `boolean`, `object`, `undefined`, `null`).
3. Используйте `switch` для проверки оценки студента:
    - `5`: "Отлично"
    - `4`: "Хорошо"
    - `3`: "Удовлетворительно"
    - Остальные: "Неудовлетворительно".
4. Напишите `switch`, который определяет тип устройства по его имени (например, `iPhone` → "Apple", `Galaxy` → "Samsung").
5. Напишите `switch`, который проверяет значение переменной и в случае пропуска `break` выводит все последующие значения.
6. Реализуйте `switch`, который выведет, рабочий ли день по номеру дня недели.
7. Напишите `switch` для определения времени года по месяцу.
8. Создайте `switch`, который выполняет арифметическую операцию (`+`, `-`, `*`, `/`) на двух числах.
9. Реализуйте `switch`, который переводит текстовое представление числа (`"один"`, `"два"`, `"три"`) в цифровое (`1`, `2`, `3`).
10. Используйте `switch` для перевода кода ошибки HTTP в текстовое сообщение (например, `404` → "Не найдено", `500` → "Ошибка сервера").
11. Напишите `"if"`, аналогичный `"switch"`
    Напишите `if..else`, соответствующий следующему `switch`:

```js
switch (browser) {
    case 'Edge':
        alert("You've got the Edge!");
        break;

    case 'Chrome':
    case 'Firefox':
    case 'Safari':
    case 'Opera':
        alert('Okay we support these browsers too');
        break;

    default:
        alert('We hope that this page looks ok!');
}
```

12. Переписать условия `"if"` на `"switch"`
    Перепишите код с использованием одной конструкции `switch`:

```js
const number = +prompt('Введите число между 0 и 3', '');

if (number === 0) {
    alert('Вы ввели число 0');
}

if (number === 1) {
    alert('Вы ввели число 1');
}

if (number === 2 || number === 3) {
    alert('Вы ввели число 2, а может и 3');
}
```
