# **1.3.3 Оператор `switch`**

> [Index](./0%20Index.md)
> || [1.3 Управляющие конструкции](./1.3%20Управляющие%20конструкции.md)

Конструкция `switch` заменяет собой сразу несколько `if`.

Она представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами.
Оператор `switch` используется для выбора одного из нескольких блоков кода для выполнения в зависимости от значения переменной или выражения.

---

### **Синтаксис**

Конструкция `switch` имеет один или более блок `case` и необязательный блок `default`.

Выглядит она так:

```javascript
switch (expression) {
    case value1:
        // код, который выполнится, если expression === value1
        break;
    case value2:
        // код, который выполнится, если expression === value2
        break;
    default:
    // код, который выполнится, если expression не совпало ни с одним из значений
}
```

-   **`expression`** — выражение, результат которого проверяется на строгое равенство с каждым `case`.
-   **`case value`** — значение, с которым сравнивается `expression`, начинает выполняться от соответствующей директивы `case` и далее, до ближайшего `break` (или до конца `switch`).
-   **`break`** — предотвращает выполнение последующих блоков `case`. Если его не указать, исполнение продолжится до ближайшего `break` или завершения оператора `switch`.
-   **`default`** — необязательный блок, который выполняется, если ни один из `case` не подошел.

---

### **Пример 1: Простая демонстрация**

```javascript
let a = 2 + 2;

switch (a) {
    case 3:
        alert('Маловато');
        break;
    case 4:
        alert('В точку!');
        break;
    case 5:
        alert('Перебор');
        break;
    default:
        alert('Нет таких значений');
}
// Вывод: `В точку!`
```

Здесь оператор `switch` последовательно сравнит `a` со всеми вариантами из `case`.

Сначала `3`, затем – так как нет совпадения – `4`. Совпадение найдено, будет выполнен этот вариант, со строки `alert('В точку!')` и далее, до ближайшего `break`, который прервёт выполнение.

Если `break` нет, то выполнение пойдёт ниже по следующим `case`, при этом остальные проверки игнорируются.

> [!NOTE]
>
> **Любое выражение может быть аргументом для `switch/case`**
> И `switch` и `case` допускают любое выражение в качестве аргумента.
>
> Например:
>
> ```js
> let a = '1';
> let b = 0;
>
> switch (+a) {
>     case b + 1:
>         alert(
>             'Выполнится, т.к. значением +a будет 1, что в точности равно b+1',
>         );
>         break;
>
>     default:
>         alert('Это не выполнится');
> }
> ```
>
> В этом примере выражение `+a` вычисляется в `1`, что совпадает с выражением `b + 1` в `case`, и следовательно, код в этом блоке будет выполнен. Но такая запись ухудшает читаемость кода, поэтому не рекомендуется к использованию.

---

### **Пример 2: Группировка случаев**

Если несколько `case` выполняют одинаковую логику, можно их сгруппировать:

```javascript
const fruit = 'apple';

switch (fruit) {
    case 'apple': // (*)
    case 'pear':
        console.log('Это фрукт семейства розоцветных.');
        break;
    case 'banana':
    case 'mango':
        console.log('Это тропический фрукт.');
        break;
    default:
        console.log('Неизвестный фрукт.');
}
// Вывод: `Это фрукт семейства розоцветных.`
```

Возможность группировать `case` – это побочный эффект того, как `switch/case` работает без `break`. Здесь выполнение `case 'apple'` начинается со строки `(*)` и продолжается в `case 'pear'`, потому что отсутствует `break`.

---

### **Пример 3: Пропуск `break`**

Если пропустить `break`, выполнение продолжится до следующего `case`:

```javascript
const score = 85;

switch (true) {
    case score >= 90:
        console.log('Отлично!');
        break;
    case score >= 80:
        console.log('Хорошо!');
    // нет break, выполнение продолжится
    case score >= 70:
        console.log('Удовлетворительно.');
        break;
    default:
        console.log('Плохо.');
}

// Вывод:
// Хорошо!
// Удовлетворительно.
```

---

### **Тип имеет значение**

Нужно отметить, что проверка на равенство всегда строгая (===). Значения должны быть одного типа, чтобы выполнялось равенство.

Для примера, давайте рассмотрим следующий код:

```js
let arg = prompt('Введите число?');
switch (arg) {
    case '0':
    case '1':
        alert('Один или ноль');
        break;

    case '2':
        alert('Два');
        break;

    case 3:
        alert('Никогда не выполнится!');
        break;
    default:
        alert('Неизвестное значение');
}
```

Для `'0'` и `'1'` выполнится первый `alert`.
Для `'2'` – второй `alert`.
Но для `3`, результат выполнения `prompt` будет строка `"3"`, которая не соответствует строгому равенству `===` с числом `3`. Таким образом, мы имеем «мёртвый код» в `case 3`! Выполнится вариант `default`.

---

### **Плюсы `switch`:**

1. **Читаемость:** Удобен для работы с множеством проверок на равенство.
2. **Оптимизация:** На уровне компилятора может быть оптимизирован лучше, чем `if-else` в некоторых языках.
3. **Удобство группировки:** Легко группировать несколько значений в одном блоке.

---

### **Минусы `switch`:**

1. **Непредсказуемое поведение без `break`:** Пропуск `break` может привести к выполнению нежелательного кода.
2. **Сравнение только на равенство:** Нельзя использовать сложные условия, как в `if-else`.
3. **Не поддерживает динамические диапазоны:** Например, `if (x > 5)` невозможно реализовать напрямую.
4. **Труден для поддержки:** Большой `switch` может стать трудно читаемым и отладимым.
5. **Не подходит для расширяемости:** Для динамически добавляемых условий нужно переписывать код.

---

### **Почему не рекомендуется использовать `switch`?**

Современные подходы в программировании предлагают альтернативы, такие как:

-   **Объекты или карты (Map):**  
    Это более гибкий и читаемый способ хранения соответствий "значение → действие".
-   **Функции:** Можно использовать объекты с функциями для замены `switch`.

**Пример с объектом:**

```javascript
const actions = {
    1: () => console.log('Понедельник'),
    2: () => console.log('Вторник'),
    3: () => console.log('Среда'),
    default: () => console.log('Неизвестный день'),
};

const day = 3;
(actions[day] || actions.default)();
```

### **Недостатки `switch` в сравнении с альтернативными подходами**

Хотя `switch` полезен в определенных ситуациях, его использование имеет ограничения по сравнению с более современными подходами. Рассмотрим это детально.

---

#### **1. Ограниченная гибкость условий**

`switch` выполняет проверки только на **строгое равенство (`===`)**, что ограничивает его возможности:

-   Нельзя использовать сложные выражения.
-   Нельзя проверить диапазоны, например, `x > 10 && x < 20`.

**Альтернатива: `if-else`**

```javascript
const age = 25;

if (age >= 18 && age < 30) {
    console.log('Молодежь');
} else if (age >= 30 && age < 60) {
    console.log('Взрослый');
} else {
    console.log('Неизвестный возраст');
}
```

`if-else` позволяет задавать любые условия, что делает его более универсальным.

---

#### **2. Плохая поддержка динамических данных**

В `switch` все варианты (`case`) задаются статически. Если нужно динамически формировать условия, это затруднительно.

**Альтернатива: объекты или карты (`Map`)**

```javascript
const userRoles = {
    admin: 'Полный доступ',
    editor: 'Доступ к редактированию',
    viewer: 'Только чтение',
};

const role = 'editor';
console.log(userRoles[role] || 'Неизвестная роль');
```

Такой подход более читаем и легко расширяется.

---

#### **3. Ошибки из-за пропуска `break`**

Если забыть добавить `break`, выполнение продолжится на следующий `case`, что может привести к неожиданным результатам.

**Пример:**

```javascript
const num = 2;

switch (num) {
    case 1:
        console.log('Один');
    case 2:
        console.log('Два'); // Выполнится
    case 3:
        console.log('Три'); // Выполнится тоже
        break;
}
```

**Альтернатива:**
В объектах или функциях такая ошибка невозможна.

---

#### **4. Плохая читаемость в больших конструкциях**

Когда в `switch` много `case`, он становится трудно читаемым и поддерживаемым. Это затрудняет отладку.

**Альтернатива: использование объектов или функций**

```javascript
const actions = {
    monday: () => console.log('Рабочий день'),
    tuesday: () => console.log('Рабочий день'),
    saturday: () => console.log('Выходной'),
    default: () => console.log('Неизвестный день'),
};

const day = 'saturday';
(actions[day] || actions.default)();
```

---

#### **5. Увеличение сложности при масштабировании**

Если необходимо добавить новые проверки, в `switch` это требует переписывания кода, что делает его менее гибким.

**Пример:**

Добавление нового правила в объект проще, чем внесение его в `switch`:

```javascript
// С объектом
const actions = {
    1: 'Понедельник',
    2: 'Вторник',
    3: 'Среда',
};

actions[4] = 'Четверг'; // Легко добавляется
```

---

#### **6. Проблемы с расширением функциональности**

Если нужно не только проверить значение, но и выполнить разные действия, объекты с функциями или классы справляются лучше.

**Пример:**

```javascript
const actions = {
    save: (data) => console.log(`Сохраняем: ${data}`),
    delete: (id) => console.log(`Удаляем: ${id}`),
};

const command = 'save';
actions[command]?.('Новая запись'); // Сохраняем: Новая запись
```

---

#### **7. Подверженность ошибкам копирования**

Если в большом `switch` нужно повторять ключевые слова, такие как `case` и `break`, это может привести к случайным ошибкам.

**Пример:**
Объект лишен этой проблемы:

```javascript
const days = {
    1: 'Понедельник',
    2: 'Вторник',
    3: 'Среда',
};
console.log(days[4] || 'Неизвестный день');
```

---

#### **8. Современные возможности языка**

Современные функции JavaScript (например, стрелочные функции и цепочки вызовов) делают альтернативы более предпочтительными.

---

### **Заключение**

Хотя `switch` может быть полезен в простых ситуациях, таких как статические проверки на равенство, он менее гибок, чем современные альтернативы, такие как объекты или функции. По мере усложнения логики лучше выбирать более универсальные подходы.

---

### **Задачи**

1. Напишите `switch`, который выведет название месяца по номеру (1 — январь, 2 — февраль и т.д.).
2. Реализуйте `switch` для проверки типа данных переменной (`number`, `string`, `boolean`, `object`, `undefined`, `null`).
3. Используйте `switch` для проверки оценки студента:
    - `5`: "Отлично"
    - `4`: "Хорошо"
    - `3`: "Удовлетворительно"
    - Остальные: "Неудовлетворительно".
4. Напишите `switch`, который определяет тип устройства по его имени (например, `iPhone` → "Apple", `Galaxy` → "Samsung").
5. Напишите `switch`, который проверяет значение переменной и в случае пропуска `break` выводит все последующие значения.
6. Реализуйте `switch`, который выведет, рабочий ли день по номеру дня недели.
7. Напишите `switch` для определения времени года по месяцу.
8. Создайте `switch`, который выполняет арифметическую операцию (`+`, `-`, `*`, `/`) на двух числах.
9. Реализуйте `switch`, который переводит текстовое представление числа (`"один"`, `"два"`, `"три"`) в цифровое (`1`, `2`, `3`).
10. Используйте `switch` для перевода кода ошибки HTTP в текстовое сообщение (например, `404` → "Не найдено", `500` → "Ошибка сервера").
11. Напишите `"if"`, аналогичный `"switch"`
    Напишите `if..else`, соответствующий следующему `switch`:

```js
switch (browser) {
    case 'Edge':
        alert("You've got the Edge!");
        break;

    case 'Chrome':
    case 'Firefox':
    case 'Safari':
    case 'Opera':
        alert('Okay we support these browsers too');
        break;

    default:
        alert('We hope that this page looks ok!');
}
```

12. Переписать условия `"if"` на `"switch"`
    Перепишите код с использованием одной конструкции `switch`:

```js
const number = +prompt('Введите число между 0 и 3', '');

if (number === 0) {
    alert('Вы ввели число 0');
}

if (number === 1) {
    alert('Вы ввели число 1');
}

if (number === 2 || number === 3) {
    alert('Вы ввели число 2, а может и 3');
}
```
