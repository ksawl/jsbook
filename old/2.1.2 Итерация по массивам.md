# **2.1.2 Итерация по массивам**

> [Index](./0%20Index.md)
> || [2.1 Массивы](./2.1%20Массивы.md)

---

Работа с массивами — одна из самых частых задач в JavaScript. Для итерации по массивам используются как традиционные циклы, так и встроенные методы. В этом разделе мы подробно рассмотрим циклы и методы для работы с массивами, включая их использование с асинхронными функциями.

---

## |1| **Итерируемые объекты**

Итерируемые объекты (**iterables**) — это объекты, которые могут быть перебраны с помощью цикла `for...of`. Они представляют собой коллекции данных, по которым можно последовательно итерироваться. В JavaScript многие встроенные структуры данных являются итерируемыми, например, массивы, строки, `Set`, `Map` и другие. Давайте разберем эту тему подробно.

---

### **1. Что такое итерируемый объект?**

Итерируемый объект — это объект, который реализует **протокол итерации**. Это означает, что он должен иметь метод с ключом `Symbol.iterator`, который возвращает **итератор**.

#### **Итератор**

Итератор — это объект, который умеет последовательно возвращать элементы коллекции. Он должен иметь метод `next()`, который возвращает объект с двумя свойствами:

-   `value`: текущее значение.
-   `done`: булево значение, указывающее, завершена ли итерация.

---

### **2. Пример итерируемого объекта**

Рассмотрим пример создания собственного итерируемого объекта.

```javascript
const myIterable = {
    [Symbol.iterator]() {
        let step = 0;
        return {
            next() {
                step++;
                if (step === 1) {
                    return { value: 'Hello', done: false };
                } else if (step === 2) {
                    return { value: 'World', done: false };
                } else {
                    return { value: undefined, done: true };
                }
            },
        };
    },
};

for (const value of myIterable) {
    console.log(value);
}
// Hello
// World
```

Здесь:

-   `myIterable` — итерируемый объект.
-   Метод `[Symbol.iterator]` возвращает итератор.
-   Итератор имеет метод `next()`, который возвращает значения `'Hello'` и `'World'`, а затем завершает итерацию.

---

### **3. Встроенные итерируемые объекты**

#### a) **Массивы**

Массивы являются итерируемыми объектами по умолчанию.

```javascript
const numbers = [1, 2, 3];
for (const num of numbers) {
    console.log(num);
}
// 1
// 2
// 3
```

#### b) **Строки**

Строки также являются итерируемыми объектами.

```javascript
const text = 'Hello';
for (const char of text) {
    console.log(char);
}
// H
// e
// l
// l
// o
```

#### c) **Set**

`Set` — это коллекция уникальных значений, которая является итерируемой.

```javascript
const uniqueNumbers = new Set([1, 2, 3, 2, 1]);
for (const num of uniqueNumbers) {
    console.log(num);
}
// 1
// 2
// 3
```

#### d) **Map**

`Map` — это коллекция пар ключ-значение, которая также является итерируемой.

```javascript
const map = new Map([
    ['name', 'Alice'],
    ['age', 25],
]);
for (const [key, value] of map) {
    console.log(`${key}: ${value}`);
}
// name: Alice
// age: 25
```

#### e) **NodeList**

Коллекции DOM-элементов, такие как `NodeList`, также являются итерируемыми.

```javascript
const elements = document.querySelectorAll('div');
for (const element of elements) {
    console.log(element);
}
```

---

### **4. Как работает `for...of`?**

Цикл `for...of` использует метод `[Symbol.iterator]` итерируемого объекта для получения итератора. Затем он вызывает метод `next()` итератора до тех пор, пока `done` не станет `true`.

**Пример:**

```javascript
const array = [1, 2, 3];
const iterator = array[Symbol.iterator]();

console.log(iterator.next()); // { value: 1, done: false }
console.log(iterator.next()); // { value: 2, done: false }
console.log(iterator.next()); // { value: 3, done: false }
console.log(iterator.next()); // { value: undefined, done: true }
```

---

### **5. Создание итерируемого объекта**

Вы можете создать собственный итерируемый объект, реализовав метод `[Symbol.iterator]`.

#### Пример: Итерируемый объект, который возвращает числа Фибоначчи

```javascript
const fibonacci = {
    [Symbol.iterator]() {
        let prev = 0,
            curr = 1;
        return {
            next() {
                [prev, curr] = [curr, prev + curr];
                return { value: curr, done: false };
            },
        };
    },
};

for (const num of fibonacci) {
    if (num > 100) break;
    console.log(num);
}
// 1
// 2
// 3
// 5
// 8
// 13
// 21
// 34
// 55
// 89
```

---

### **6. Использование итерируемых объектов с `...` (spread и rest)**

Итерируемые объекты можно использовать с операторами `...` (spread и rest).

**Пример:**

```javascript
const set = new Set([1, 2, 3]);
const array = [...set]; // Преобразование Set в массив
console.log(array); // [1, 2, 3]
```

---

### **7. Итерируемые объекты и генераторы**

Генераторы — это функции, которые возвращают итераторы. Они упрощают создание итерируемых объектов.

**Пример:**

```javascript
function* fibonacciGenerator() {
    let prev = 0,
        curr = 1;
    while (true) {
        [prev, curr] = [curr, prev + curr];
        yield curr;
    }
}

const fibonacci = fibonacciGenerator();
for (const num of fibonacci) {
    if (num > 100) break;
    console.log(num);
}
// 1
// 2
// 3
// 5
// 8
// 13
// 21
// 34
// 55
// 89
```

---

### **8. Итог**

-   **Итерируемые объекты** — это объекты, которые можно перебирать с помощью `for...of`.
-   Они реализуют протокол итерации, включая метод `[Symbol.iterator]`, который возвращает итератор.
-   Встроенные итерируемые объекты: массивы, строки, `Set`, `Map`, `NodeList` и другие.
-   Вы можете создавать собственные итерируемые объекты, реализуя метод `[Symbol.iterator]`.
-   Итерируемые объекты работают с операторами `...` (spread и rest) и генераторами.

Примеры:

```javascript
// Итерация по массиву
const numbers = [1, 2, 3];
for (const num of numbers) {
    console.log(num);
}

// Создание итерируемого объекта
const myIterable = {
    [Symbol.iterator]() {
        let step = 0;
        return {
            next() {
                step++;
                if (step <= 3) {
                    return { value: step, done: false };
                } else {
                    return { value: undefined, done: true };
                }
            },
        };
    },
};

for (const value of myIterable) {
    console.log(value);
}
// 1
// 2
// 3
```

---

## |2| **Итерируемый объект `Set`**

Итерируемый объект `Set` в JavaScript — это коллекция уникальных значений, где каждое значение может встречаться только один раз. `Set` является встроенным итерируемым объектом, что означает, что его можно перебирать с помощью цикла `for...of` или методов, работающих с итерируемыми объектами, таких как `Array.from()` или оператор расширения (`...`).

### Основные характеристики `Set`:

1. **Уникальность значений**: Все значения в `Set` уникальны. Если попытаться добавить значение, которое уже существует в `Set`, оно не будет добавлено.
2. **Итерируемость**: `Set` реализует протокол итерации, поэтому его можно перебирать с помощью `for...of`.
3. **Отсутствие индексов**: В отличие от массивов, `Set` не имеет индексов, и доступ к элементам по индексу невозможен.
4. **Методы для работы**: `Set` предоставляет методы для добавления, удаления и проверки наличия элементов.

### Создание `Set`

`Set` создаётся с помощью конструктора `new Set()`. В конструктор можно передать итерируемый объект (например, массив), чтобы сразу добавить элементы в `Set`.

```javascript
const set = new Set([1, 2, 3, 4, 5]);
console.log(set); // Set { 1, 2, 3, 4, 5 }
```

### Основные методы и свойства `Set`

#### 1. **`add(value)`**

Добавляет значение в `Set`. Если значение уже существует, оно не будет добавлено.

```javascript
const set = new Set();
set.add(1);
set.add(2);
set.add(1); // Не будет добавлено, так как 1 уже есть
console.log(set); // Set { 1, 2 }
```

#### 2. **`delete(value)`**

Удаляет значение из `Set`. Возвращает `true`, если значение было удалено, и `false`, если значение не найдено.

```javascript
const set = new Set([1, 2, 3]);
set.delete(2); // true
set.delete(4); // false (не найдено)
console.log(set); // Set { 1, 3 }
```

#### 3. **`has(value)`**

Проверяет, существует ли значение в `Set`. Возвращает `true` или `false`.

```javascript
const set = new Set([1, 2, 3]);
console.log(set.has(2)); // true
console.log(set.has(4)); // false
```

#### 4. **`clear()`**

Очищает `Set`, удаляя все его элементы.

```javascript
const set = new Set([1, 2, 3]);
set.clear();
console.log(set); // Set {}
```

#### 5. **`size`**

Свойство `size` возвращает количество элементов в `Set`.

```javascript
const set = new Set([1, 2, 3]);
console.log(set.size); // 3
```

### Итерирование по `Set`

Поскольку `Set` является итерируемым объектом, его можно перебирать с помощью цикла `for...of` или преобразовывать в массив.

#### Пример с `for...of`:

```javascript
const set = new Set([1, 2, 3]);

for (const value of set) {
    console.log(value); // 1, 2, 3
}
```

#### Пример с преобразованием в массив:

```javascript
const set = new Set([1, 2, 3]);
const array = Array.from(set); // или [...set]
console.log(array); // [1, 2, 3]
```

### Использование `Set` для удаления дубликатов

Одно из самых популярных применений `Set` — удаление дубликатов из массива.

```javascript
const array = [1, 2, 2, 3, 4, 4, 5];
const uniqueArray = [...new Set(array)];
console.log(uniqueArray); // [1, 2, 3, 4, 5]
```

### Сравнение с массивом

-   **Уникальность**: В `Set` все значения уникальны, в массиве могут быть дубликаты.
-   **Производительность**: Поиск и удаление элементов в `Set` выполняется быстрее, чем в массиве, так как `Set` использует хэш-таблицы для хранения значений.
-   **Отсутствие индексов**: В `Set` нет индексов, поэтому доступ к элементам по индексу невозможен.

### Примеры использования `Set`

#### 1. Хранение уникальных значений

```javascript
const set = new Set();
set.add('apple');
set.add('banana');
set.add('apple'); // Не будет добавлено
console.log(set); // Set { "apple", "banana" }
```

#### 2. Проверка наличия элемента

```javascript
const set = new Set(['apple', 'banana']);
console.log(set.has('banana')); // true
console.log(set.has('cherry')); // false
```

#### 3. Удаление дубликатов из массива

```javascript
const numbers = [1, 2, 2, 3, 4, 4, 5];
const uniqueNumbers = [...new Set(numbers)];
console.log(uniqueNumbers); // [1, 2, 3, 4, 5]
```

#### 4. Перебор элементов

```javascript
const set = new Set([1, 2, 3]);
set.forEach((value) => {
    console.log(value); // 1, 2, 3
});
```

### Заключение

`Set` — это мощный инструмент для работы с коллекциями уникальных значений. Он предоставляет удобные методы для добавления, удаления и проверки наличия элементов, а также поддерживает итерацию. `Set` особенно полезен для задач, где требуется гарантировать уникальность данных, таких как удаление дубликатов из массива или хранение уникальных идентификаторов.

---

## |3| **Работа с массивами объектов**

Массивы объектов — это одна из самых распространённых структур данных в JavaScript. Они используются для хранения коллекций данных, где каждый элемент массива представляет собой объект с определёнными свойствами. Например, массив пользователей, товаров, заказов и т.д.

**Пример хранения данных:**

```javascript
const users = [
    { name: 'Alice', age: 25 },
    { name: 'Bob', age: 30 },
    { name: 'Charlie', age: 35 },
];
```

Здесь `users` — это массив объектов, где каждый объект представляет пользователя с двумя свойствами: `name` (имя) и `age` (возраст).

Массивы объектов часто обрабатываются с помощью методов массивов, таких как `map()`, `filter()`, `reduce()` и других. Эти методы позволяют выполнять различные операции над данными, такие как преобразование, фильтрация и агрегация.

---

## |4| **Цикл `for`**

Цикл `for` — это классический способ итерации по массиву. Он позволяет гибко управлять процессом перебора элементов.

### Синтаксис:

```javascript
for (let i = 0; i < array.length; i++) {
    // Действия с array[i]
}
```

### Пример:

```javascript
const numbers = [1, 2, 3, 4, 5];
for (let i = 0; i < numbers.length; i++) {
    console.log(numbers[i]);
}
// 1
// 2
// 3
// 4
// 5
```

### Особенности

В цикле `for` условие `i < numbers.length` играет ключевую роль в управлении итерациями.

#### **1. Что такое `i < numbers.length`?**

-   `i` — это переменная-счетчик, которая увеличивается на каждой итерации цикла.
-   `numbers.length` — это свойство массива, которое возвращает количество элементов в массиве.
-   Условие `i < numbers.length` проверяет, меньше ли текущее значение `i` длины массива.

---

#### **2. Как это работает?**

Цикл `for` состоит из трех частей:

1. **Инициализация**: `let i = 0` — создается переменная `i` и устанавливается в `0`.
2. **Условие**: `i < numbers.length` — проверяется перед каждой итерацией. Если условие истинно, цикл продолжается.
3. **Обновление**: `i++` — после каждой итерации значение `i` увеличивается на 1.

**Пример:**

```javascript
const numbers = [1, 2, 3, 4, 5];
for (let i = 0; i < numbers.length; i++) {
    console.log(numbers[i]);
}
```

**Пошаговое выполнение:**

1. `i = 0`: `0 < 5` (истина) → выполняется тело цикла → выводится `numbers[0]` (1).
2. `i = 1`: `1 < 5` (истина) → выполняется тело цикла → выводится `numbers[1]` (2).
3. `i = 2`: `2 < 5` (истина) → выполняется тело цикла → выводится `numbers[2]` (3).
4. `i = 3`: `3 < 5` (истина) → выполняется тело цикла → выводится `numbers[3]` (4).
5. `i = 4`: `4 < 5` (истина) → выполняется тело цикла → выводится `numbers[4]` (5).
6. `i = 5`: `5 < 5` (ложь) → цикл завершается.

---

#### **3. Почему именно `i < numbers.length`?**

-   **Индексация массива начинается с 0**: Первый элемент массива имеет индекс `0`, последний — `numbers.length - 1`.
-   **Предотвращение выхода за границы массива**: Если использовать `i <= numbers.length`, цикл попытается обратиться к `numbers[numbers.length]`, что вызовет ошибку (например, `undefined`).

**Пример ошибки:**

```javascript
for (let i = 0; i <= numbers.length; i++) {
    console.log(numbers[i]);
}
// На последней итерации: numbers[5] → undefined
```

---

#### **4. Альтернативные условия**

Иногда используются другие условия, например:

-   `i <= numbers.length - 1` — эквивалентно `i < numbers.length`.
-   `i !== numbers.length` — редко используется, но также работает.

---

#### **5. Итог**

Условие `i < numbers.length` в цикле `for`:

-   Обеспечивает корректный перебор всех элементов массива.
-   Предотвращает выход за границы массива.
-   Является стандартным и наиболее читаемым способом итерации по массиву.

**Пример:**

```javascript
const numbers = [1, 2, 3, 4, 5];
for (let i = 0; i < numbers.length; i++) {
    console.log(numbers[i]);
}
// 1
// 2
// 3
// 4
// 5
```

### **Преимущества:**

-   Полный контроль над индексом и условиями выхода.
-   Подходит для сложных сценариев (например, перебор с шагом 2).

---

## |5| **Цикл `for...of`**

Цикл `for...of` — это современный и удобный способ итерации по итерируемым объектам, таким как массивы, строки, `Set`, `Map` и другие. Он был введен в стандарте ES6 (ECMAScript 2015) и предоставляет простой и читаемый синтаксис для перебора элементов.

### **1. Синтаксис**

```javascript
for (const element of iterable) {
    // Действия с element
}
```

-   `element` — переменная, которая на каждой итерации принимает значение текущего элемента.
-   `iterable` — итерируемый объект (массив, строка, `Set`, `Map` и т.д.).

---

### **2. Основные особенности**

#### a) **Простота и читаемость**

Цикл `for...of` позволяет перебирать элементы напрямую, без необходимости использования индексов. Это делает код более читаемым и лаконичным.

**Пример:**

```javascript
const numbers = [1, 2, 3, 4, 5];
for (const num of numbers) {
    console.log(num);
}
// 1
// 2
// 3
// 4
// 5
```

---

#### b) **Работа с любыми итерируемыми объектами**

Цикл `for...of` работает не только с массивами, но и с другими итерируемыми объектами, такими как строки, `Set`, `Map`, `NodeList` и т.д.

**Пример со строкой:**

```javascript
const text = 'Hello';
for (const char of text) {
    console.log(char);
}
// H
// e
// l
// l
// o
```

**Пример с `Set`:**

```javascript
const uniqueNumbers = new Set([1, 2, 3, 2, 1]);
for (const num of uniqueNumbers) {
    console.log(num);
}
// 1
// 2
// 3
```

**Пример с `Map`:**

```javascript
const map = new Map([
    ['name', 'Alice'],
    ['age', 25],
]);
for (const [key, value] of map) {
    console.log(`${key}: ${value}`);
}
// name: Alice
// age: 25
```

---

#### c) **Нет доступа к индексу**

В отличие от цикла `for`, `for...of` не предоставляет доступ к индексу элемента. Если вам нужен индекс, используйте метод `entries` или цикл `for`.

**Пример с `entries`:**

```javascript
const numbers = [10, 20, 30];
for (const [index, num] of numbers.entries()) {
    console.log(`Index: ${index}, Value: ${num}`);
}
// Index: 0, Value: 10
// Index: 1, Value: 20
// Index: 2, Value: 30
```

---

#### d) **Не изменяет исходный объект**

Цикл `for...of` не изменяет исходный итерируемый объект. Если вам нужно изменить элементы, делайте это явно.

**Пример:**

```javascript
const numbers = [1, 2, 3];
for (const num of numbers) {
    console.log(num * 2); // Изменение только для вывода
    num *= 2; // Uncaught TypeError: Assignment to constant variable.
}
// 2
// 4
// 6
console.log(numbers); // [1, 2, 3] (исходный массив не изменился)
```

этот же пример с циклом `for`

```js
for (let i = 0; i < numbers.length; i++) {
    numbers[i] *= 2; // Изменение элемента массива
    console.log(numbers[i] * 2); // Изменение только для вывода
}
// 4
// 8
// 12
console.log(numbers); // [2, 4, 6] (исходный массив изменился)
```

---

#### e) **Работа с асинхронными операциями**

Цикл `for...of` поддерживает асинхронные операции с использованием `await`. Это делает его удобным для работы с асинхронными задачами.

**Пример:**

```javascript
async function processArray(array) {
    for (const num of array) {
        await new Promise((resolve) => setTimeout(resolve, 1000));
        console.log(num);
    }
}

processArray([1, 2, 3]);
// 1 (через 1 секунду)
// 2 (через 2 секунды)
// 3 (через 3 секунды)
```

---

#### f) **Не работает с объектами**

Цикл `for...of` не работает с обычными объектами, так как они не являются итерируемыми. Для перебора свойств объекта используйте `for...in` или `Object.keys`.

**Пример с `for...in`:**

```javascript
const person = { name: 'Alice', age: 25 };
for (const key in person) {
    console.log(`${key}: ${person[key]}`);
}
// name: Alice
// age: 25
```

---

### **3. Сравнение с другими циклами**

| Цикл/Метод | Доступ к индексу | Подходит для асинхронных операций | Работа с объектами | Читаемость |
| ---------- | ---------------- | --------------------------------- | ------------------ | ---------- |
| `for`      | Да               | Да (с `await`)                    | Нет                | Средняя    |
| `for...of` | Нет              | Да (с `await`)                    | Нет                | Высокая    |
| `for...in` | Нет              | Нет                               | Да                 | Высокая    |
| `forEach`  | Да               | Нет                               | Нет                | Высокая    |

---

### **4. Итог**

-   Цикл `for...of` прост в использовании и подходит для итерации по итерируемым объектам.
-   Он не предоставляет доступ к индексу, но это можно обойти с помощью `entries`.
-   Поддерживает асинхронные операции с `await`.
-   Не работает с обычными объектами (используйте `for...in` или `Object.keys`).

Примеры:

```javascript
// Итерация по массиву
const numbers = [1, 2, 3];
for (const num of numbers) {
    console.log(num);
}

// Итерация по строке
const text = 'Hello';
for (const char of text) {
    console.log(char);
}

// Итерация с асинхронными операциями
async function processArray(array) {
    for (const num of array) {
        await new Promise((resolve) => setTimeout(resolve, 1000));
        console.log(num);
    }
}
```

---

## |6| **Метод `forEach()`**

Метод `forEach()` — это встроенный метод массивов, который позволяет выполнить переданную функцию один раз для каждого элемента массива. Он часто используется для итерации по массиву, когда не требуется создание нового массива или возврат значения.

### **1. Синтаксис**

```javascript
array.forEach((element, index, array) => {
    // Действия с element
});
```

-   **`element`**: Текущий элемент массива.
-   **`index`**: Индекс текущего элемента (опционально).
-   **`array`**: Сам массив, по которому происходит итерация (опционально).

---

### **2. Основные особенности**

#### a) **Простота и читаемость**

Метод `forEach` предоставляет простой и читаемый способ перебора элементов массива без необходимости использования индексов вручную.

**Пример:**

```javascript
const numbers = [1, 2, 3, 4, 5];
numbers.forEach((num) => {
    console.log(num);
});
// 1
// 2
// 3
// 4
// 5
```

---

#### b) **Нет возвращаемого значения**

Метод `forEach` всегда возвращает `undefined`. Он используется только для выполнения операций над элементами массива.

**Пример:**

```javascript
const result = numbers.forEach((num) => num * 2);
console.log(result); // undefined
```

---

#### c) **Не изменяет исходный массив**

Метод `forEach` не изменяет исходный массив, если только вы не делаете это явно внутри функции.

**Пример:**

```javascript
const numbers = [1, 2, 3];
numbers.forEach((num, index, arr) => {
    arr[index] = num * 2; // Явное изменение массива
});
console.log(numbers); // [2, 4, 6]
```

---

#### d) **Не прерывается**

Метод `forEach` не поддерживает прерывание итерации (например, с помощью `break`). Если нужно прервать выполнение, используйте цикл `for` или метод `some`.

**Пример:**

```javascript
const numbers = [1, 2, 3, 4, 5];
numbers.forEach((num) => {
    if (num === 3) return; // Не прерывает выполнение
    console.log(num);
});
// 1
// 2
// 4
// 5
```

---

### **3. Использование с асинхронными функциями**

Метод `forEach` не поддерживает `await` так, как циклы `for` или `for...of`. Если передать асинхронную функцию в `forEach`, она не будет ждать завершения асинхронных операций.

**Пример:**

```javascript
async function processArray(array) {
    array.forEach(async (item) => {
        await new Promise((resolve) => setTimeout(resolve, 1000));
        console.log(item);
    });
}

processArray([1, 2, 3]);
// 1, 2, 3 выводятся одновременно через 1 секунду
```

#### Особенности:

-   **Параллельное выполнение**: Все асинхронные операции запускаются одновременно.
-   **Не подходит для последовательных задач**: Если порядок выполнения важен, используйте цикл `for` или `for...of`.

---

### **4. Когда использовать `forEach`?**

Метод `forEach` подходит для:

-   Простого перебора элементов массива.
-   Выполнения операций над каждым элементом без необходимости возврата нового массива.
-   Задач, где порядок выполнения не важен.

---

### **5. Примеры использования**

#### a) **Вывод элементов массива**

```javascript
const fruits = ['apple', 'banana', 'orange'];
fruits.forEach((fruit) => {
    console.log(fruit);
});
// apple
// banana
// orange
```

#### b) **Изменение элементов массива**

```javascript
const numbers = [1, 2, 3];
numbers.forEach((num, index, arr) => {
    arr[index] = num * 2;
});
console.log(numbers); // [2, 4, 6]
```

#### c) **Использование индекса**

```javascript
const colors = ['red', 'green', 'blue'];
colors.forEach((color, index) => {
    console.log(`Цвет ${color} имеет индекс ${index}`);
});
// Цвет red имеет индекс 0
// Цвет green имеет индекс 1
// Цвет blue имеет индекс 2
```

---

### **6. Итог**

-   Метод `forEach` используется для выполнения функции для каждого элемента массива.
-   Он не возвращает новый массив и не поддерживает прерывание итерации.
-   Для асинхронных операций лучше использовать циклы `for` или `for...of`.
-   `forEach` подходит для простых задач, где не требуется создание нового массива или возврат значения.

Примеры:

```javascript
// Простой перебор
const numbers = [1, 2, 3];
numbers.forEach((num) => {
    console.log(num);
});

// Изменение элементов
const doubled = [];
numbers.forEach((num) => {
    doubled.push(num * 2);
});
console.log(doubled); // [2, 4, 6]
```

---

## |7| **Метод `map()`**

Метод `map()` — это один из самых полезных и часто используемых методов массивов в JavaScript. Он создает новый массив, применяя переданную функцию к каждому элементу исходного массива. Этот метод не изменяет исходный массив, а возвращает новый, что делает его идеальным для функционального программирования.

### **1. Синтаксис**

```javascript
const newArray = array.map((element, index, array) => {
    return /* новое значение */;
});
```

-   **`element`**: Текущий элемент массива.
-   **`index`**: Индекс текущего элемента (опционально).
-   **`array`**: Сам массив, по которому происходит итерация (опционально).
-   **`newArray`**: Новый массив, созданный на основе результатов вызова функции.

---

### **2. Основные особенности**

#### a) **Создание нового массива**

Метод `map` возвращает новый массив, в котором каждый элемент является результатом вызова переданной функции.

**Пример:**

```javascript
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map((num) => num * 2);
console.log(doubled); // [2, 4, 6, 8, 10]
```

---

#### b) **Не изменяет исходный массив**

Метод `map` не изменяет исходный массив. Он всегда возвращает новый массив.

**Пример:**

```javascript
const numbers = [1, 2, 3];
const squared = numbers.map((num) => num * num);
console.log(squared); // [1, 4, 9]
console.log(numbers); // [1, 2, 3] (исходный массив не изменился)
```

---

#### c) **Использование индекса и массива**

Метод `map` позволяет использовать индекс текущего элемента и сам массив внутри функции.

**Пример:**

```javascript
const numbers = [1, 2, 3];
const indexed = numbers.map((num, index, arr) => {
    return `Элемент ${num} имеет индекс ${index} в массиве [${arr}]`;
});
console.log(indexed);
// [
//   "Элемент 1 имеет индекс 0 в массиве [1,2,3]",
//   "Элемент 2 имеет индекс 1 в массиве [1,2,3]",
//   "Элемент 3 имеет индекс 2 в массиве [1,2,3]"
// ]
```

---

#### d) **Поддержка асинхронных функций**

Если передать асинхронную функцию в `map`, она вернет массив промисов. Для обработки таких случаев можно использовать `Promise.all`.

**Пример:**

```javascript
const numbers = [1, 2, 3];
const promises = numbers.map(async (num) => {
    await new Promise((resolve) => setTimeout(resolve, 1000));
    return num * 2;
});

Promise.all(promises).then((results) => console.log(results));
// Через 1 секунду: [2, 4, 6]
```

---

### **3. Примеры использования**

#### a) **Преобразование массива чисел**

```javascript
const numbers = [1, 2, 3, 4, 5];
const squared = numbers.map((num) => num * num);
console.log(squared); // [1, 4, 9, 16, 25]
```

#### b) **Преобразование массива объектов**

```javascript
const users = [
    { name: 'Alice', age: 25 },
    { name: 'Bob', age: 30 },
];
const names = users.map((user) => user.name);
console.log(names); // ['Alice', 'Bob']
```

#### c) **Добавление новых свойств**

```javascript
const products = [
    { name: 'Laptop', price: 1000 },
    { name: 'Phone', price: 500 },
];
const productsWithTax = products.map((product) => ({
    ...product,
    priceWithTax: product.price * 1.2,
}));
console.log(productsWithTax);
// [
//   { name: 'Laptop', price: 1000, priceWithTax: 1200 },
//   { name: 'Phone', price: 500, priceWithTax: 600 }
// ]
```

---

### **4. Когда использовать `map`?**

Метод `map` подходит для:

-   Преобразования элементов массива.
-   Создания нового массива на основе существующего.
-   Задач, где требуется сохранить исходный массив неизменным.

---

### **5. Итог**

-   Метод `map` создает новый массив, применяя функцию к каждому элементу исходного массива.
-   Он не изменяет исходный массив и всегда возвращает новый.
-   Подходит для преобразования данных, работы с объектами и асинхронных операций (с `Promise.all`).

Примеры:

```javascript
// Преобразование массива чисел
const numbers = [1, 2, 3];
const doubled = numbers.map((num) => num * 2);
console.log(doubled); // [2, 4, 6]

// Преобразование массива объектов
const users = [
    { name: 'Alice', age: 25 },
    { name: 'Bob', age: 30 },
];
const names = users.map((user) => user.name);
console.log(names); // ['Alice', 'Bob']

#### Пример 1: Преобразование массива объектов в строку

// Преобразуем массив пользователей в строку формата "Имя (Возраст)".
const usersString = users
    .map((user) => `${user.name} (${user.age})`)
    .join(', ');
console.log(usersString); // "Alice (25), Bob (30), Charlie (35)"


// Асинхронные операции
const asyncNumbers = [1, 2, 3];
const promises = asyncNumbers.map(async (num) => {
    await new Promise((resolve) => setTimeout(resolve, 1000));
    return num * 2;
});
Promise.all(promises).then((results) => console.log(results)); // [2, 4, 6]
```

---

## |8| **Метод `filter()`**

Метод `filter()` — это встроенный метод массивов, который создает новый массив, содержащий только те элементы, которые удовлетворяют заданному условию. Он не изменяет исходный массив, а возвращает новый, что делает его идеальным для задач, где нужно отфильтровать данные.

### **1. Синтаксис**

```javascript
const newArray = array.filter((element, index, array) => {
    return /* условие */;
});
```

-   **`element`**: Текущий элемент массива.
-   **`index`**: Индекс текущего элемента (опционально).
-   **`array`**: Сам массив, по которому происходит итерация (опционально).
-   **`newArray`**: Новый массив, содержащий только элементы, для которых условие вернуло `true`.

---

### **2. Основные особенности**

#### a) **Создание нового массива**

Метод `filter` возвращает новый массив, содержащий только те элементы, для которых переданная функция возвращает `true`.

**Пример:**

```javascript
const numbers = [1, 2, 3, 4, 5];
const evenNumbers = numbers.filter((num) => num % 2 === 0);
console.log(evenNumbers); // [2, 4]
```

---

#### b) **Не изменяет исходный массив**

Метод `filter` не изменяет исходный массив. Он всегда возвращает новый массив.

**Пример:**

```javascript
const numbers = [1, 2, 3, 4, 5];
const filtered = numbers.filter((num) => num > 2);
console.log(filtered); // [3, 4, 5]
console.log(numbers); // [1, 2, 3, 4, 5] (исходный массив не изменился)
```

---

#### c) **Использование индекса и массива**

Метод `filter` позволяет использовать индекс текущего элемента и сам массив внутри функции.

**Пример:**

```javascript
const numbers = [1, 2, 3, 4, 5];
const filtered = numbers.filter((num, index) => index % 2 === 0);
console.log(filtered); // [1, 3, 5] (элементы с четными индексами)
```

---

#### d) **Поддержка сложных условий**

Метод `filter` может использоваться для фильтрации по сложным условиям, включая проверку свойств объектов.

**Пример:**

```javascript
const users = [
    { name: 'Alice', age: 25 },
    { name: 'Bob', age: 30 },
    { name: 'Charlie', age: 20 },
];
const adults = users.filter((user) => user.age >= 25);
console.log(adults);
// [
//   { name: 'Alice', age: 25 },
//   { name: 'Bob', age: 30 }
// ]
```

---

### **3. Примеры использования**

#### a) **Фильтрация чисел**

```javascript
const numbers = [1, 2, 3, 4, 5];
const positiveNumbers = numbers.filter((num) => num > 0);
console.log(positiveNumbers); // [1, 2, 3, 4, 5]
```

#### b) **Фильтрация строк**

```javascript
const words = ['apple', 'banana', 'cherry', 'date'];
const longWords = words.filter((word) => word.length > 5);
console.log(longWords); // ['banana', 'cherry']
```

#### c) **Фильтрация объектов**

```javascript
const products = [
    { name: 'Laptop', price: 1000 },
    { name: 'Phone', price: 500 },
    { name: 'Tablet', price: 300 },
];
const affordableProducts = products.filter((product) => product.price < 600);
console.log(affordableProducts);
// [
//   { name: 'Phone', price: 500 },
//   { name: 'Tablet', price: 300 }
// ]
```

Отфильтруем пользователей, чьи имена начинаются на букву "A".

```javascript
const users = [
    { name: 'Alice', age: 25 },
    { name: 'Bob', age: 30 },
    { name: 'Charlie', age: 35 },
];

const usersWithA = users.filter((user) => user.name.startsWith('A'));
console.log(usersWithA); // [ { name: 'Alice', age: 25 } ]
```

---

### **4. Когда использовать `filter`?**

Метод `filter` подходит для:

-   Отбора элементов массива по заданному условию.
-   Создания нового массива на основе существующего.
-   Задач, где требуется сохранить исходный массив неизменным.

---

### **5. Итог**

-   Метод `filter` создает новый массив, содержащий только элементы, удовлетворяющие условию.
-   Он не изменяет исходный массив и всегда возвращает новый.
-   Подходит для фильтрации данных, включая числа, строки и объекты.

Примеры:

```javascript
// Фильтрация чисел
const numbers = [1, 2, 3, 4, 5];
const evenNumbers = numbers.filter((num) => num % 2 === 0);
console.log(evenNumbers); // [2, 4]

// Фильтрация объектов
const users = [
    { name: 'Alice', age: 25 },
    { name: 'Bob', age: 30 },
    { name: 'Charlie', age: 20 },
];
const adults = users.filter((user) => user.age >= 25);
console.log(adults);
// [
//   { name: 'Alice', age: 25 },
//   { name: 'Bob', age: 30 }
// ]
```

---

## |9| **Метод `reduce()`**

Метод `reduce()` — это один из самых мощных и гибких методов массивов в JavaScript. Он позволяет "свернуть" массив в одно значение, применяя переданную функцию к каждому элементу массива. Этот метод часто используется для агрегации данных, таких как суммирование, нахождение максимального значения или преобразование массива в объект.

### **1. Синтаксис**

```javascript
const result = array.reduce((accumulator, currentValue, index, array) => {
    return /* новое значение accumulator */;
}, initialValue);
```

-   **`accumulator`**: Аккумулятор, который хранит промежуточный результат.
-   **`currentValue`**: Текущий элемент массива.
-   **`index`**: Индекс текущего элемента (опционально).
-   **`array`**: Сам массив, по которому происходит итерация (опционально).
-   **`initialValue`**: Начальное значение аккумулятора (опционально).
-   **`result`**: Итоговое значение, возвращаемое методом `reduce`.

Условно работу метода `reduce` можно представить в виде функции

```js
const array = [1, 2, 3];
function calcAcc(accumulator, currentValue, index, array = []) {
    accumulator += currentValue;
    return accumulator;
}

function reduce(fun, initialValue) {
    let accumulator = initialValue ?? array[0];
    let i = Number(initialValue === undefined);

    for (i; i < array.length; i++) {
        accumulator = fun(accumulator, array[i]);
    }

    return accumulator;
}

const result = reduce(calcAcc, 0);
console.log(result); // 6
```

---

### **2. Основные особенности**

#### a) **Аккумулятор**

Аккумулятор — это переменная, которая хранит промежуточный результат на каждой итерации. На первой итерации аккумулятор равен `initialValue` (если он указан), или первому элементу массива (если `initialValue` не указан).

**Пример:**

```javascript
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce((acc, num) => acc + num, 0);
console.log(sum); // 15
```

---

#### b) **Начальное значение (`initialValue`)**

Начальное значение аккумулятора можно указать вторым аргументом. Если оно не указано, метод `reduce` использует первый элемент массива в качестве начального значения, а итерация начинается со второго элемента.

**Пример без `initialValue`:**

```javascript
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce((acc, num) => acc + num);
console.log(sum); // 15
```

**Пример с `initialValue`:**

```javascript
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce((acc, num) => acc + num, 10);
console.log(sum); // 25 (10 + 1 + 2 + 3 + 4 + 5)
```

---

#### c) **Использование индекса и массива**

Метод `reduce` позволяет использовать индекс текущего элемента и сам массив внутри функции.

**Пример:**

```javascript
const numbers = [1, 2, 3, 4, 5];
const result = numbers.reduce((acc, num, index) => {
    acc[index] = num * 2;
    return acc;
}, {});
console.log(result); // { 0: 2, 1: 4, 2: 6, 3: 8, 4: 10 }
```

---

#### d) **Поддержка сложных операций**

Метод `reduce` может использоваться для выполнения сложных операций, таких как группировка, преобразование массива в объект или вычисление статистики.

**Пример:**

```javascript
const users = [
    { name: 'Alice', age: 25 },
    { name: 'Bob', age: 30 },
    { name: 'Charlie', age: 25 },
];
const groupedByAge = users.reduce((acc, user) => {
    if (!acc[user.age]) {
        acc[user.age] = [];
    }
    acc[user.age].push(user);
    return acc;
}, {});
console.log(groupedByAge);
// {
//   25: [{ name: 'Alice', age: 25 }, { name: 'Charlie', age: 25 }],
//   30: [{ name: 'Bob', age: 30 }]
// }
```

---

### **3. Примеры использования**

#### a) **Суммирование элементов массива**

```javascript
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce((acc, num) => acc + num, 0);
console.log(sum); // 15
```

#### b) **Нахождение максимального значения**

```javascript
const numbers = [10, 20, 5, 30, 15];
const max = numbers.reduce((acc, num) => Math.max(acc, num), -Infinity);
console.log(max); // 30
```

#### c) **Преобразование массива в объект**

```javascript
const fruits = ['apple', 'banana', 'orange'];
const fruitMap = fruits.reduce((acc, fruit, index) => {
    acc[fruit] = index;
    return acc;
}, {});
console.log(fruitMap); // { apple: 0, banana: 1, orange: 2 }
```

#### d) **Группировка объектов по свойству**

```javascript
const users = [
    { name: 'Alice', age: 25 },
    { name: 'Bob', age: 30 },
    { name: 'Charlie', age: 25 },
];
const groupedByAge = users.reduce((acc, user) => {
    if (!acc[user.age]) {
        acc[user.age] = [];
    }
    acc[user.age].push(user);
    return acc;
}, {});
console.log(groupedByAge);
// {
//   25: [{ name: 'Alice', age: 25 }, { name: 'Charlie', age: 25 }],
//   30: [{ name: 'Bob', age: 30 }]
// }
```

#### e) **Сумма возрастов всех пользователей.**

```javascript
const users = [
    { name: 'Alice', age: 25 },
    { name: 'Bob', age: 30 },
    { name: 'Charlie', age: 35 },
];

const totalAge = users.reduce((acc, user) => acc + user.age, 0);
console.log(totalAge); // 90
```

#### f) **Объект из объекта**

Создадим объект, где ключами будут имена пользователей, а значениями — их возраст.

```javascript
const usersMap = users.reduce((acc, user) => {
    acc[user.name] = user.age;
    return acc;
}, {});

console.log(usersMap);
// { Alice: 25, Bob: 30, Charlie: 35 }
```

---

### **4. Когда использовать `reduce`?**

Метод `reduce` подходит для:

-   Агрегации данных (суммирование, нахождение максимального/минимального значения).
-   Преобразования массива в объект или другую структуру данных.
-   Группировки данных по определенному признаку.
-   Выполнения сложных операций, которые требуют накопления результата.

---

### **5. Итог**

-   Метод `reduce` позволяет "свернуть" массив в одно значение, применяя функцию к каждому элементу.
-   Он не изменяет исходный массив и всегда возвращает новое значение.
-   Подходит для агрегации данных, преобразования массивов и выполнения сложных операций.

Примеры:

```javascript
// Суммирование элементов
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce((acc, num) => acc + num, 0);
console.log(sum); // 15

// Преобразование массива в объект
const fruits = ['apple', 'banana', 'orange'];
const fruitMap = fruits.reduce((acc, fruit, index) => {
    acc[fruit] = index;
    return acc;
}, {});
console.log(fruitMap); // { apple: 0, banana: 1, orange: 2 }

// Группировка объектов по свойству
const users = [
    { name: 'Alice', age: 25 },
    { name: 'Bob', age: 30 },
    { name: 'Charlie', age: 25 },
];
const groupedByAge = users.reduce((acc, user) => {
    if (!acc[user.age]) {
        acc[user.age] = [];
    }
    acc[user.age].push(user);
    return acc;
}, {});
console.log(groupedByAge);
// {
//   25: [{ name: 'Alice', age: 25 }, { name: 'Charlie', age: 25 }],
//   30: [{ name: 'Bob', age: 30 }]
// }

// Сгруппируем пользователей по возрасту (младше 30 и старше 30).
const groupedUsers = users.reduce(
    (acc, user) => {
        if (user.age < 30) {
            acc.young.push(user);
        } else {
            acc.old.push(user);
        }
        return acc;
    },
    { young: [], old: [] },
);

console.log(groupedUsers);
// {
//   young: [ { name: 'Alice', age: 25 } ],
//   old: [ { name: 'Bob', age: 30 }, { name: 'Charlie', age: 35 } ]
// }

// Найдём максимальный возраст среди пользователей.
const maxAge = users.reduce(
    (max, user) => (user.age > max ? user.age : max),
    0,
);
console.log(maxAge); // 35
```

---

## |10| **Метод `every()`**

Метод `every()` — это встроенный метод массивов, который проверяет, удовлетворяют ли **все** элементы массива заданному условию. Если все элементы проходят проверку, метод возвращает `true`, иначе — `false`. Этот метод полезен для валидации данных или проверки условий на уровне всего массива.

### **1. Синтаксис**

```javascript
const result = array.every((element, index, array) => {
    return /* условие */;
});
```

-   **`element`**: Текущий элемент массива.
-   **`index`**: Индекс текущего элемента (опционально).
-   **`array`**: Сам массив, по которому происходит итерация (опционально).
-   **`result`**: Булево значение (`true` или `false`).

---

### **2. Основные особенности**

#### a) **Проверка всех элементов**

Метод `every` возвращает `true`, только если **все** элементы массива удовлетворяют условию. Если хотя бы один элемент не проходит проверку, метод возвращает `false`.

**Пример:**

```javascript
const numbers = [2, 4, 6, 8, 10];
const allEven = numbers.every((num) => num % 2 === 0);
console.log(allEven); // true
```

---

#### b) **Пустой массив**

Если массив пуст, метод `every` всегда возвращает `true`, независимо от условия.

**Пример:**

```javascript
const emptyArray = [];
const result = emptyArray.every((num) => num > 0);
console.log(result); // true
```

---

#### c) **Использование индекса и массива**

Метод `every` позволяет использовать индекс текущего элемента и сам массив внутри функции.

**Пример:**

```javascript
const numbers = [1, 2, 3, 4, 5];
const result = numbers.every((num, index) => num > index);
console.log(result); // true (1 > 0, 2 > 1, 3 > 2, 4 > 3, 5 > 4)
```

---

#### d) **Прерывание итерации**

Метод `every` прерывает выполнение, как только находит элемент, не удовлетворяющий условию. Это делает его более эффективным для больших массивов.

**Пример:**

```javascript
const numbers = [2, 4, 5, 8, 10];
const allEven = numbers.every((num) => {
    console.log(`Проверка: ${num}`);
    return num % 2 === 0;
});
// Проверка: 2
// Проверка: 4
// Проверка: 5 (итерация прерывается)
console.log(allEven); // false
```

---

### **3. Примеры использования**

#### a) **Проверка всех чисел на положительность**

```javascript
const numbers = [1, 2, 3, 4, 5];
const allPositive = numbers.every((num) => num > 0);
console.log(allPositive); // true
```

#### b) **Проверка всех строк на длину**

```javascript
const words = ['apple', 'banana', 'cherry'];
const allLongWords = words.every((word) => word.length > 5);
console.log(allLongWords); // false ('apple' имеет длину 5)
```

#### c) **Проверка всех объектов на наличие свойства**

```javascript
const users = [
    { name: 'Alice', age: 25 },
    { name: 'Bob', age: 30 },
    { name: 'Charlie' },
];
const allHaveAge = users.every((user) => user.age !== undefined);
console.log(allHaveAge); // false (у Charlie нет свойства age)
```

### d) **Проверка возраста всех пользователей**

```javascript
const allAdults = users.every((user) => user.age > 20);
console.log(allAdults); // true
```

---

### **4. Когда использовать `every`?**

Метод `every` подходит для:

-   Проверки, удовлетворяют ли все элементы массива определенному условию.
-   Валидации данных (например, проверка, что все числа положительные или все объекты имеют определенное свойство).
-   Задач, где важно прерывание итерации при первом несоответствии.

---

### **5. Итог**

-   Метод `every` проверяет, удовлетворяют ли все элементы массива заданному условию.
-   Он возвращает `true`, если все элементы проходят проверку, и `false`, если хотя бы один элемент не проходит.
-   Подходит для валидации данных и проверки условий на уровне всего массива.

Примеры:

```javascript
// Проверка всех чисел на положительность
const numbers = [1, 2, 3, 4, 5];
const allPositive = numbers.every((num) => num > 0);
console.log(allPositive); // true

// Проверка всех строк на длину
const words = ['apple', 'banana', 'cherry'];
const allLongWords = words.every((word) => word.length > 5);
console.log(allLongWords); // false

// Проверка всех объектов на наличие свойства
const users = [
    { name: 'Alice', age: 25 },
    { name: 'Bob', age: 30 },
    { name: 'Charlie' },
];
const allHaveAge = users.every((user) => user.age !== undefined);
console.log(allHaveAge); // false
```

---

## |11| **Метод `some()`**

Метод `some()` в JavaScript является одним из методов массивов, который позволяет проверить, удовлетворяет ли **хотя бы один элемент** массива заданному условию. Если хотя бы один элемент проходит проверку, метод возвращает `true`, в противном случае — `false`.

### Синтаксис

```javascript
arr.some(callback(element[, index[, array]])[, thisArg])
```

-   **`callback`** — функция, которая вызывается для каждого элемента массива. Она принимает три аргумента:
    -   **`element`** — текущий элемент массива.
    -   **`index`** (необязательный) — индекс текущего элемента.
    -   **`array`** (необязательный) — массив, по которому происходит итерация.
-   **`thisArg`** (необязательный) — значение, которое будет использоваться как `this` при выполнении функции `callback`.

### Возвращаемое значение

-   `true`, если хотя бы один элемент массива удовлетворяет условию, заданному в `callback`.
-   `false`, если ни один элемент не удовлетворяет условию.

### Как работает метод `some()`

1. Метод `some()` проходит по каждому элементу массива.
2. Для каждого элемента вызывается функция `callback`.
3. Если `callback` возвращает `true` для какого-либо элемента, метод `some()` немедленно возвращает `true` (остальные элементы не проверяются).
4. Если `callback` возвращает `false` для всех элементов, метод `some()` возвращает `false`.

### Примеры использования

#### Пример 1: Проверка наличия положительных чисел

```javascript
const numbers = [-1, -2, 0, 4, -5];

const hasPositiveNumber = numbers.some((num) => num > 0);

console.log(hasPositiveNumber); // true, потому что 4 > 0
```

#### Пример 2: Проверка наличия строк длиннее 5 символов

```javascript
const words = ['apple', 'banana', 'cherry', 'date'];

const hasLongWord = words.some((word) => word.length > 5);

console.log(hasLongWord); // true, потому что "banana" и "cherry" длиннее 5 символов
```

#### Пример 3: Использование `thisArg`

```javascript
const threshold = 10;

function isGreaterThanThreshold(num) {
    return num > threshold;
}

const numbers = [1, 5, 8, 12, 3];

const result = numbers.some(isGreaterThanThreshold, threshold);

console.log(result); // true, потому что 12 > 10
```

#### Пример 4: Проверка возраста пользователя

```javascript
const hasYoungUser = users.some((user) => user.age < 30);
console.log(hasYoungUser); // true
```

### Особенности

1. **Пустой массив**: Если массив пуст, метод `some()` всегда возвращает `false`, так как нет элементов для проверки.

    ```javascript
    const emptyArray = [];
    const result = emptyArray.some((el) => el > 0);
    console.log(result); // false
    ```

2. **Прерывание выполнения**: Метод `some()` прекращает выполнение, как только находит элемент, удовлетворяющий условию. Это может быть полезно для оптимизации.

3. **Неизменяемость**: Метод `some()` не изменяет исходный массив.

### Сравнение с другими методами

-   **`every()`**: Возвращает `true`, если **все** элементы массива удовлетворяют условию.
-   **`find()`**: Возвращает **первый элемент**, удовлетворяющий условию, или `undefined`, если такого элемента нет.
-   **`filter()`**: Возвращает **новый массив** со всеми элементами, удовлетворяющими условию.

### Когда использовать `some()`

Метод `some()` полезен, когда нужно проверить, существует ли хотя бы один элемент, соответствующий определённому критерию. Например:

-   Проверка, есть ли в массиве хотя бы одно положительное число.
-   Проверка, есть ли в списке пользователей хотя бы один администратор.
-   Проверка, выполняется ли условие хотя бы для одного элемента в коллекции.

---

## |12| **Сравнение циклов и методов**

| Метод/Цикл | Возвращает новый массив? | Изменяет исходный массив?  | Прерывание итерации       | Поддерживает `await`? | Читаемость |
| ---------- | ------------------------ | -------------------------- | ------------------------- | --------------------- | ---------- |
| `for`      | Нет                      | Да (если изменять вручную) | Да (через `break`)        | Да (с `await`)        | Низкая     |
| `for...of` | Нет                      | Да (если изменять вручную) | Да (через `break`)        | Да (с `await`)        | Средняя    |
| `forEach`  | Нет                      | Да (если изменять вручную) | Нет                       | Нет                   | Высокая    |
| `map`      | Да                       | Нет                        | Нет                       | Да (с `Promise.all`)  | Высокая    |
| `filter`   | Да                       | Нет                        | Нет                       | Нет                   | Высокая    |
| `reduce`   | Нет (одно значение)      | Нет                        | Нет                       | Нет                   | Средняя    |
| `every`    | Нет (булево значение)    | Нет                        | Да (если вернуть `false`) | Нет                   | Высокая    |
| `some`     | Нет (булево значение)    | Нет                        | Да (если вернуть `true`)  | Нет                   | Высокая    |

### Пояснения к столбцам:

1. **Возвращает новый массив?**  
   Указывает, возвращает ли метод/цикл новый массив или нет. Например, `map` и `filter` возвращают новый массив, а `forEach` и `reduce` — нет.

2. **Изменяет исходный массив?**  
   Указывает, может ли метод/цикл изменить исходный массив. Например, `for` и `for...of` могут изменять массив, если это делается вручную, а `map` и `filter` не изменяют исходный массив.

3. **Прерывание итерации**  
   Указывает, можно ли прервать итерацию до завершения. Например, в `for` и `for...of` можно использовать `break`, а в `forEach`, `map`, `filter` и `reduce` — нет.

4. **Поддерживает `await`?**  
   Указывает, можно ли использовать `await` внутри цикла/метода для работы с асинхронными операциями. Например, `for` и `for...of` поддерживают `await`, а `forEach`, `map`, `filter` и другие методы — нет.

5. **Читаемость**  
   Оценивает, насколько легко понять и использовать метод/цикл. Например, `forEach`, `map`, `filter` и другие методы массивов обычно более читаемы, чем классические циклы `for`.

### Примеры использования:

#### `for`

```javascript
for (let i = 0; i < arr.length; i++) {
    if (arr[i] > 10) break; // Прерывание итерации
    arr[i] *= 2; // Изменение исходного массива
}
```

#### `for...of`

```javascript
for (const item of arr) {
    if (item > 10) break; // Прерывание итерации
    console.log(item);
}
```

#### `forEach`

```javascript
arr.forEach((item) => {
    console.log(item); // Нет прерывания итерации
});
```

#### `map`

```javascript
const newArr = arr.map((item) => item * 2); // Возвращает новый массив
```

#### `filter`

```javascript
const filteredArr = arr.filter((item) => item > 10); // Возвращает новый массив
```

#### `reduce`

```javascript
const sum = arr.reduce((acc, item) => acc + item, 0); // Возвращает одно значение
```

#### `every`

```javascript
const allPositive = arr.every((item) => item > 0); // Прерывается, если вернёт false
```

#### `some`

```javascript
const hasNegative = arr.some((item) => item < 0); // Прерывается, если вернёт true
```

### Заключение

Выбор метода или цикла зависит от задачи:

-   Используйте `for` или `for...of`, если нужно прерывание итерации или работа с асинхронным кодом.
-   Используйте методы массивов (`forEach`, `map`, `filter` и т.д.), если важна читаемость и неизменяемость исходного массива.
-   Используйте `every` и `some`, если нужно проверить выполнение условия для элементов массива.

---

## |13| **Итог**

-   **Циклы** (`for`, `for...of`) подходят для гибкого управления процессом итерации, особенно с асинхронными операциями.
-   **Методы** (`forEach`, `map`, `filter`, `reduce`, `every`, `some`) обеспечивают удобство и читаемость, но не всегда подходят для асинхронных сценариев.
-   Для асинхронных операций используйте циклы с `await` или `Promise.all` с методами.

Примеры:

```javascript
// for...of с асинхронными операциями
async function processArray(array) {
    for (const element of array) {
        await new Promise((resolve) => setTimeout(resolve, 1000));
        console.log(element);
    }
}

// map с Promise.all
const numbers = [1, 2, 3];
const promises = numbers.map(async (num) => {
    await new Promise((resolve) => setTimeout(resolve, 1000));
    return num * 2;
});

Promise.all(promises).then((results) => console.log(results));
```

---

## **Задачи**

### **1. Встроенные итерируемые объекты**

1. **Работа с встроенными итерируемыми объектами.**  
   Напишите код, который выводит все символы строки `"Hello, world!"` по одному с помощью цикла `for...of`.

2. **Итерируемый объект `Set`.**  
   Создайте объект `Set` из массива `[1, 2, 2, 3, 4, 4, 5]`. Используйте цикл `for...of`, чтобы вывести все уникальные элементы.

3. **Инкремент преобразованного массива**
   Дан массив однозначных чисел `[1, 2, 3]`. Преобразуйте массив в число `123`, увеличьте его на единицу и преобразуйте обратно в массив `[1, 2, 4]`.

---

### **2. Создание итерируемого объекта**

4. **Создание собственного итерируемого объекта.**  
   Напишите объект, который реализует метод `[Symbol.iterator]` и генерирует числа от 1 до 5. Используйте `for...of` для его обхода.

---

### **3. Циклы для работы с массивами**

5. **Цикл `for`.**  
   Напишите программу, которая вычисляет сумму элементов массива `[10, 20, 30, 40, 50]` с помощью обычного цикла `for`.

6. **Цикл `for...of`.**  
   Используйте `for...of` для вывода всех элементов массива `['apple', 'banana', 'cherry']` с их индексами.

---

### **4. Методы для итерации**

7. **`forEach()`**  
   Напишите функцию, которая принимает массив чисел и выводит квадрат каждого числа, используя метод `forEach()`.

8. **`map()`**  
   Напишите программу, которая преобразует массив строк `['1', '2', '3']` в массив чисел `[1, 2, 3]` с помощью метода `map()`.

9. **`filter()`**  
   Напишите функцию, которая принимает массив чисел `[10, 25, 30, 45, 50]` и возвращает новый массив, содержащий только числа больше 30.

10. **`reduce()`**  
    Используя метод `reduce()`, напишите программу, которая подсчитывает произведение всех чисел в массиве `[1, 2, 3, 4, 5]`.

11. **Методы every() и some()**
    Дан массив чисел. Используя метод `every()`, проверьте, все ли элементы массива больше `0`. Используя метод `some()`, проверьте, есть ли в массиве хотя бы один элемент, равный `5`.

### **5. Дополнительные задания для углубления:**

1. Создайте итерируемый объект, который генерирует бесконечную последовательность чисел Фибоначчи. Ограничьте вывод первых 10 чисел.
2. Используя цикл `for...of`, найдите максимальное значение в массиве чисел.
3. Используя метод `map()`, преобразуйте массив строк в массив их длин.
4. Используя метод `filter()`, отфильтруйте массив объектов (например, пользователей) по определённому условию (например, возраст больше 18).
5. Используя метод `reduce()`, найдите среднее значение элементов массива чисел.
