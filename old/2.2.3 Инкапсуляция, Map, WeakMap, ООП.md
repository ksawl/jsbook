# **2.2.3 Инкапсуляция, Map, WeakMap, ООП**

> [Index](./0%20Index.md)
> || [2.2 Объекты](./2.2%20Объекты.md)

---

## |1| **Инкапсуляция, приватные поля и методы**

Инкапсуляция — это один из ключевых принципов объектно-ориентированного программирования (ООП), который позволяет скрыть внутреннюю реализацию объекта и предоставить контролируемый доступ к его данным. В JavaScript инкапсуляция реализуется с помощью приватных полей и методов, которые недоступны извне объекта.

---

### **1. Что такое инкапсуляция?**

Инкапсуляция — это механизм, который:

-   **Скрывает внутренние детали реализации** объекта.
-   **Защищает данные** от несанкционированного доступа.
-   **Предоставляет публичный интерфейс** для взаимодействия с объектом.

---

### **2. Приватные поля и методы**

Начиная с ES2022, JavaScript поддерживает приватные поля и методы, которые обозначаются символом `#`. Они доступны только внутри класса и не могут быть доступны или изменены извне.

#### **2.1. Приватные поля**

Приватные поля объявляются с помощью символа `#` перед именем поля. Они доступны только внутри класса.

**Пример:**

```javascript
class User {
    #password; // Приватное поле

    constructor(username, password) {
        this.username = username;
        this.#password = password;
    }

    // Публичный метод для проверки пароля
    checkPassword(inputPassword) {
        return this.#password === inputPassword;
    }
}

const user = new User('Alice', '123456');
console.log(user.username); // Alice
console.log(user.#password); // Ошибка: Private field '#password' must be declared in an enclosing class
console.log(user.checkPassword('123456')); // true
```

#### **2.2. Приватные методы**

Приватные методы также объявляются с помощью символа `#`. Они могут быть вызваны только внутри класса.

**Пример:**

```javascript
class BankAccount {
    #balance = 0; // Приватное поле

    // Приватный метод для логирования
    #logTransaction(amount) {
        console.log(`Transaction: ${amount}, New Balance: ${this.#balance}`);
    }

    deposit(amount) {
        if (amount > 0) {
            this.#balance += amount;
            this.#logTransaction(amount);
        }
    }

    withdraw(amount) {
        if (amount > 0 && amount <= this.#balance) {
            this.#balance -= amount;
            this.#logTransaction(-amount);
        }
    }
}

const account = new BankAccount();
account.deposit(100); // Transaction: 100, New Balance: 100
account.withdraw(50); // Transaction: -50, New Balance: 50
account.#logTransaction(100); // Ошибка: Private field '#logTransaction' must be declared in an enclosing class
```

---

### **3. Преимущества инкапсуляции**

#### **3.1. Защита данных**

Приватные поля и методы предотвращают несанкционированный доступ к данным, что делает код более безопасным.

**Пример:**

```javascript
class User {
    #password;

    constructor(username, password) {
        this.username = username;
        this.#password = password;
    }

    // Публичный метод для проверки пароля
    checkPassword(inputPassword) {
        return this.#password === inputPassword;
    }
}

const user = new User('Alice', '123456');
console.log(user.checkPassword('wrong')); // false
```

#### **3.2. Сокрытие реализации**

Инкапсуляция позволяет скрыть сложную логику внутри класса, предоставляя только необходимый интерфейс.

**Пример:**

```javascript
class Temperature {
    #celsius;

    constructor(celsius) {
        this.#celsius = celsius;
    }

    get fahrenheit() {
        return this.#celsius * 1.8 + 32;
    }

    set fahrenheit(value) {
        this.#celsius = (value - 32) / 1.8;
    }
}

const temp = new Temperature(25);
console.log(temp.fahrenheit); // 77
temp.fahrenheit = 100;
console.log(temp.fahrenheit); // 100
```

#### **3.3. Упрощение поддержки кода**

Инкапсуляция делает код более модульным и упрощает его поддержку, так как изменения внутренней реализации не влияют на внешний интерфейс.

---

### **4. Инкапсуляция до ES2022**

До появления приватных полей и методов в ES2022 (с символом `#`), разработчики использовали различные подходы для имитации инкапсуляции в JavaScript. Эти подходы были основаны на соглашениях и особенностях языка.

#### **4.1. Соглашение об именовании**

Один из самых простых способов — это использование соглашения об именовании. Приватные поля и методы обозначались символом `_` (нижнее подчёркивание) в начале имени. Это не делало их действительно приватными, но указывало другим разработчикам, что эти поля и методы не предназначены для использования извне.

**Пример:**

```javascript
class User {
    constructor(username, password) {
        this.username = username;
        this._password = password; // "Приватное" поле
    }

    // Публичный метод для проверки пароля
    checkPassword(inputPassword) {
        return this._password === inputPassword;
    }
}

const user = new User('Alice', '123456');
console.log(user.checkPassword('123456')); // true
console.log(user._password); // 123456 (доступно, но не рекомендуется)
```

**Недостатки:**

-   Поля и методы с `_` всё ещё доступны извне.
-   Это всего лишь соглашение, и оно не обеспечивает настоящей инкапсуляции.

---

#### **4.2. Замыкания (Closures)**

Замыкания позволяют создавать действительно приватные поля и методы, используя локальные переменные внутри функции-конструктора.

**1. Приватные поля**

```javascript
function User(username, password) {
    // Приватное поле, объявлено без this
    let _password = password;

    // Публичные методы
    this.username = username;
    this.checkPassword = function (inputPassword) {
        return _password === inputPassword;
    };
}

const user = new User('Alice', '123456');
console.log(user.checkPassword('123456')); // true
console.log(user._password); // undefined (недоступно)
```

**2. Приватные методы**

```javascript
function BankAccount() {
    // Приватное поле
    let _balance = 0;

    // Приватный метод
    function logTransaction(amount) {
        console.log(`Transaction: ${amount}, New Balance: ${_balance}`);
    }

    // Публичные методы
    this.deposit = function (amount) {
        if (amount > 0) {
            _balance += amount;
            logTransaction(amount);
        }
    };

    this.withdraw = function (amount) {
        if (amount > 0 && amount <= _balance) {
            _balance -= amount;
            logTransaction(-amount);
        }
    };

    this.getBalance = function () {
        return _balance;
    };
}

const account = new BankAccount();
account.deposit(100); // Transaction: 100, New Balance: 100
account.withdraw(50); // Transaction: -50, New Balance: 50
console.log(account.getBalance()); // 50
```

**Преимущества:**

-   Поля и методы действительно приватны и недоступны извне.
-   Подходит для создания объектов с помощью функций-конструкторов.

**Недостатки:**

-   Каждый экземпляр объекта создаёт свои копии методов, что может привести к увеличению потребления памяти.
-   Не работает с классами ES6.

---

#### **4.3. Символы (Symbols)**

Символы — это уникальные и неизменяемые значения, которые могут использоваться как ключи для свойств объектов. Они позволяют скрыть поля от случайного доступа, так как символы не видны при обычном перечислении свойств.

**Пример:**

```javascript
const passwordSymbol = Symbol('password');

class User {
    constructor(username, password) {
        this.username = username;
        this[passwordSymbol] = password; // "Приватное" поле
    }

    // Публичный метод для проверки пароля
    checkPassword(inputPassword) {
        return this[passwordSymbol] === inputPassword;
    }
}

const user = new User('Alice', '123456');
console.log(user.checkPassword('123456')); // true
console.log(user[passwordSymbol]); // 123456 (доступно, если знать символ)
```

**Недостатки:**

-   Поля всё ещё доступны, если знать символ.
-   Это не настоящая инкапсуляция, а скорее способ скрыть данные.

---

#### **4.4. WeakMap для приватных полей**

`WeakMap` — это коллекция, которая позволяет использовать объекты в качестве ключей. Это можно использовать для хранения приватных полей, так как ключи `WeakMap` не видны извне.

**Пример:**

```javascript
const privateFields = new WeakMap();

class User {
    constructor(username, password) {
        privateFields.set(this, { password }); // Приватные поля
        this.username = username;
    }

    // Публичный метод для проверки пароля
    checkPassword(inputPassword) {
        return privateFields.get(this).password === inputPassword;
    }
}

const user = new User('Alice', '123456');
console.log(user.checkPassword('123456')); // true
console.log(user.password); // undefined (недоступно)
```

**Преимущества:**

-   Поля действительно приватны и недоступны извне.
-   Подходит для использования с классами ES6.

**Недостатки:**

-   Более сложный синтаксис.
-   Требуется создание отдельной `WeakMap` для каждого класса.

---

### **5. Примеры использования**

#### **5.1. Банковский счёт**

```javascript
class BankAccount {
    #balance = 0;

    deposit(amount) {
        if (amount > 0) {
            this.#balance += amount;
            console.log(`Deposited: ${amount}, New Balance: ${this.#balance}`);
        }
    }

    withdraw(amount) {
        if (amount > 0 && amount <= this.#balance) {
            this.#balance -= amount;
            console.log(`Withdrawn: ${amount}, New Balance: ${this.#balance}`);
        }
    }

    get balance() {
        return this.#balance;
    }
}

const account = new BankAccount();
account.deposit(100); // Deposited: 100, New Balance: 100
account.withdraw(50); // Withdrawn: 50, New Balance: 50
console.log(account.balance); // 50
```

#### **5.2. Пользователь с приватным паролем**

```javascript
class User {
    #password;

    constructor(username, password) {
        this.username = username;
        this.#password = password;
    }

    checkPassword(inputPassword) {
        return this.#password === inputPassword;
    }
}

const user = new User('Alice', '123456');
console.log(user.checkPassword('123456')); // true
console.log(user.checkPassword('wrong')); // false
```

---

### **6. Итог**

-   **Инкапсуляция** — это принцип ООП, который позволяет скрыть внутреннюю реализацию объекта и предоставить контролируемый доступ к данным.
-   **Приватные поля и методы** в JavaScript обозначаются символом `#` и доступны только внутри класса.
-   Инкапсуляция обеспечивает:
    -   Защиту данных.
    -   Сокрытие сложной логики.
    -   Упрощение поддержки кода.
-   Использование приватных полей и методов делает код более безопасным, модульным и удобным для работы.

До ES2022 разработчики использовали различные подходы для имитации инкапсуляции:

1. **Соглашение об именовании** (`_`): Просто, но не обеспечивает настоящей приватности.
2. **Замыкания**: Обеспечивает настоящую приватность, но увеличивает потребление памяти.
3. **Символы**: Скрывает поля, но они всё ещё доступны, если знать символ.
4. **WeakMap**: Обеспечивает настоящую приватность и подходит для классов ES6.

С появлением приватных полей и методов в ES2022 (с символом `#`) необходимость в этих подходах значительно снизилась, так как новый синтаксис предоставляет удобный и надёжный способ реализации инкапсуляции.

---

## |2| **Геттеры и сеттеры**

Геттеры и сеттеры — это специальные методы в классах и объектах, которые позволяют управлять доступом к свойствам. Они используются для чтения (геттеры) и записи (сеттеры) значений свойств, а также для выполнения дополнительной логики при доступе к этим свойствам.

### **1. Синтаксис геттеров и сеттеров**

Геттеры и сеттеры объявляются с помощью ключевых слов `get` и `set` внутри класса или объекта.

#### **1.1. В классах**

```javascript
class Person {
    constructor(firstName, lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    // Геттер для полного имени
    get fullName() {
        return `${this.firstName} ${this.lastName}`;
    }

    // Сеттер для полного имени
    set fullName(name) {
        const [firstName, lastName] = name.split(' ');
        this.firstName = firstName;
        this.lastName = lastName;
    }
}

const person = new Person('Alice', 'Smith');
console.log(person.fullName); // Alice Smith (геттер)
person.fullName = 'Bob Johnson'; // Сеттер
console.log(person.firstName); // Bob
console.log(person.lastName); // Johnson
```

#### **1.2. В объектах**

Геттеры и сеттеры также могут быть определены в литералах объектов.

**Пример:**

```javascript
const user = {
    firstName: 'Alice',
    lastName: 'Smith',

    get fullName() {
        return `${this.firstName} ${this.lastName}`;
    },

    set fullName(name) {
        const [firstName, lastName] = name.split(' ');
        this.firstName = firstName;
        this.lastName = lastName;
    },
};

console.log(user.fullName); // Alice Smith
user.fullName = 'Bob Johnson';
console.log(user.firstName); // Bob
```

---

### **2. Как работают геттеры и сеттеры?**

#### **2.1. Геттеры**

Геттер — это метод, который вызывается при чтении свойства. Он не принимает аргументов и должен возвращать значение.

**Пример:**

```javascript
class Circle {
    constructor(radius) {
        this.radius = radius;
    }

    get area() {
        return Math.PI * this.radius ** 2;
    }
}

const circle = new Circle(5);
console.log(circle.area); // 78.53981633974483
```

#### **2.2. Сеттеры**

Сеттер — это метод, который вызывается при записи значения в свойство. Он принимает один аргумент (новое значение) и может выполнять дополнительные действия, например, валидацию.

**Пример:**

```javascript
class User {
    constructor(age) {
        this._age = age; // Используем _age для хранения значения
    }

    get age() {
        return this._age;
    }

    set age(value) {
        if (value < 0) {
            throw new Error('Age cannot be negative');
        }
        this._age = value;
    }
}

const user = new User(25);
console.log(user.age); // 25
user.age = 30;
console.log(user.age); // 30
user.age = -5; // Ошибка: Age cannot be negative
```

---

### **3. Особенности геттеров и сеттеров**

#### **3.1. Инкапсуляция**

Геттеры и сеттеры позволяют скрыть внутреннюю реализацию и предоставить контролируемый доступ к свойствам.

**Пример:**

```javascript
class Temperature {
    constructor(celsius) {
        this.celsius = celsius;
    }

    get fahrenheit() {
        return this.celsius * 1.8 + 32;
    }

    set fahrenheit(value) {
        this.celsius = (value - 32) / 1.8;
    }
}

const temp = new Temperature(25);
console.log(temp.fahrenheit); // 77
temp.fahrenheit = 100;
console.log(temp.celsius); // 37.77777777777778
```

#### **3.2. Вычисляемые свойства**

Геттеры позволяют создавать вычисляемые свойства, которые не хранятся в объекте, а вычисляются на основе других свойств.

**Пример:**

```javascript
class Rectangle {
    constructor(width, height) {
        this.width = width;
        this.height = height;
    }

    get area() {
        return this.width * this.height;
    }
}

const rect = new Rectangle(10, 5);
console.log(rect.area); // 50
```

#### **3.3. Валидация данных**

Сеттеры позволяют проверять и валидировать данные перед их записью.

**Пример:**

```javascript
class Person {
    constructor(age) {
        this._age = age;
    }

    get age() {
        return this._age;
    }

    set age(value) {
        if (value < 0) {
            throw new Error('Age cannot be negative');
        }
        this._age = value;
    }
}

const person = new Person(25);
person.age = 30; // OK
person.age = -5; // Ошибка: Age cannot be negative
```

---

### **4. Примеры использования**

#### **4.1. Управление доступом к приватным полям**

Геттеры и сеттеры часто используются для доступа к приватным полям (обозначаются символом `#`).

**Пример:**

```javascript
class User {
    #password;

    constructor(username, password) {
        this.username = username;
        this.#password = password;
    }

    get password() {
        return '*****'; // Скрываем пароль
    }

    set password(newPassword) {
        if (newPassword.length < 6) {
            throw new Error('Password must be at least 6 characters long');
        }
        this.#password = newPassword;
    }
}

const user = new User('Alice', '123456');
console.log(user.password); // *****
user.password = 'newPass'; // OK
user.password = '123'; // Ошибка: Password must be at least 6 characters long
```

#### **4.2. Логирование изменений**

Сеттеры могут использоваться для логирования изменений свойств.

**Пример:**

```javascript
class Product {
    constructor(price) {
        this._price = price;
    }

    get price() {
        return this._price;
    }

    set price(value) {
        console.log(`Price changed from ${this._price} to ${value}`);
        this._price = value;
    }
}

const product = new Product(100);
product.price = 150; // Price changed from 100 to 150
```

---

### **5. Итог**

-   **Геттеры** — это методы для чтения свойств.
-   **Сеттеры** — это методы для записи свойств.
-   Они позволяют:
    -   Контролировать доступ к свойствам.
    -   Выполнять дополнительную логику при чтении или записи.
    -   Создавать вычисляемые свойства.
    -   Валидировать данные.
-   Геттеры и сеттеры делают код более безопасным, гибким и удобным для работы с данными.

---

## |3| **Символы как ключи**

В JavaScript объекты представляют собой коллекции пар ключ-значение, где ключи могут быть строками или символами (Symbol). Символы — это уникальные и неизменяемые примитивные значения, которые могут использоваться в качестве ключей для свойств объектов. Они были введены в ECMAScript 6 (ES6) для решения некоторых проблем, связанных с использованием строк в качестве ключей.

### **1. Основные особенности символов как ключей объекта:**

#### **1.1. Уникальность**:

Каждый символ уникален, даже если он создан с тем же описанием. Это гарантирует, что символы не конфликтуют с другими ключами объекта, даже если их имена совпадают.

    ```javascript
    const symbol1 = Symbol('description');
    const symbol2 = Symbol('description');

    console.log(symbol1 === symbol2); // false
    ```

#### **1.2. Неизменяемость**:

Символы неизменяемы. После создания символа его значение нельзя изменить.

#### **1.3. Скрытность**:

Свойства объекта, ключами которых являются символы, не видны при обычном перечислении свойств объекта (например, с помощью `for...in` или `Object.keys()`). Это делает их полезными для создания "скрытых" или внутренних свойств объекта.

    ```javascript
    const obj = {};
    const symbolKey = Symbol('hidden');

    obj[symbolKey] = 'secret value';

    console.log(obj[symbolKey]); // 'secret value'
    console.log(Object.keys(obj)); // []
    ```

#### **1.4. Доступ к символьным свойствам**:

Для получения списка всех символьных ключей объекта можно использовать метод `Object.getOwnPropertySymbols()`.

    ```javascript
    const obj = {};
    const symbolKey = Symbol('key');

    obj[symbolKey] = 'value';

    console.log(Object.getOwnPropertySymbols(obj)); // [Symbol(key)]
    ```

### **2. Глобальные символы**:

`Symbol.for` — это метод, который создаёт символ (тип данных `Symbol`) или возвращает уже существующий символ с указанным ключом из глобального реестра символов.

Символы, созданные с помощью `Symbol.for`, добавляются в специальный глобальный реестр. Это позволяет использовать символы как универсальные уникальные идентификаторы, которые можно повторно получать по ключу в разных частях программы.

---

#### **Синтаксис**

```javascript
Symbol.for(key);
```

-   **`key`**: строка, используемая как имя (ключ) символа. Если символ с этим ключом уже существует в реестре, он возвращается. Если нет, создаётся новый символ с этим ключом.

-   Возвращаемое значение: символ с указанным ключом.

---

#### **Как работает `Symbol.for`**

1. **Поиск в глобальном реестре**:

    - Если символ с указанным ключом уже существует, он будет возвращён.
    - Если символа с таким ключом нет, создаётся новый символ и добавляется в глобальный реестр.

2. **Отличие от `Symbol()`**:
    - `Symbol()` всегда создаёт уникальный символ, даже если передать ему одинаковые ключи.
    - Символы, созданные через `Symbol.for`, могут быть получены повторно по ключу.

---

#### **Примеры**

1. **Создание символа с использованием `Symbol.for`**

```javascript
const sym1 = Symbol.for('example');
const sym2 = Symbol.for('example');

console.log(sym1 === sym2); // true
```

Оба символа `sym1` и `sym2` указывают на один и тот же символ из глобального реестра.

2. **Сравнение с `Symbol()`**

```javascript
const sym1 = Symbol('example');
const sym2 = Symbol('example');

console.log(sym1 === sym2); // false
```

Хотя строки одинаковы, символы, созданные через `Symbol()`, уникальны.

3. **Получение символа по ключу**

```javascript
Symbol.for('mySymbol'); // создаёт символ и добавляет его в реестр
const sym = Symbol.for('mySymbol'); // возвращает уже существующий символ
```

4. **Использование `Symbol.keyFor` для получения ключа**

Для символов, созданных с помощью `Symbol.for`, можно получить их ключ через метод `Symbol.keyFor`.

```javascript
const sym = Symbol.for('myKey');

console.log(Symbol.keyFor(sym)); // "myKey"
```

Но для символов, созданных через `Symbol()`, это не работает:

```javascript
const sym = Symbol('myKey');

console.log(Symbol.keyFor(sym)); // undefined
```

---

#### **Применение `Symbol.for`**

1. **Глобальные уникальные идентификаторы**:

    - Используется, когда нужно создать символ, который будет доступен в разных частях программы (например, в разных модулях).

2. **Обозначение свойств объектов**:
    - Символы часто используются для добавления уникальных свойств объектам, чтобы избежать конфликта имен.

```javascript
const sym = Symbol.for('uniqueID');

const obj = {
    [sym]: 'value',
};

console.log(obj[sym]); // "value"
```

3. **Общий контракт между модулями**:
    - Можно использовать символы как соглашение между различными библиотеками или модулями, чтобы они не перезаписывали свойства друг друга.

---

#### **Преимущества `Symbol.for`**

1. **Удобство повторного использования**: Символы, зарегистрированные через `Symbol.for`, можно получить по ключу из любой части приложения.
2. **Безопасность данных**: Символы гарантируют уникальность и избегают конфликтов между свойствами.
3. **Совместимость с различными модулями**: Позволяет устанавливать соглашения между разными частями кода.

---

#### **Недостатки**

1. **Доступность в глобальном реестре**: Если ключ символа угадаем, другие части кода могут случайно (или намеренно) получить доступ к символу, что снижает безопасность.
2. **Сложность в использовании**: Для начинающих разработчиков концепция символов и их применения может быть сложной.

---

#### **Ключевые моменты**

1. `Symbol.for` создаёт или возвращает символ из глобального реестра.
2. Символы, созданные через `Symbol.for`, могут быть получены по ключу из любой части программы.
3. Используйте `Symbol.keyFor`, чтобы получить строковый ключ символа из реестра.
4. Символы, созданные через `Symbol()`, не попадают в глобальный реестр и всегда уникальны.

5. **Использование символов в качестве ключей**:
   Символы могут быть использованы для создания уникальных идентификаторов или для добавления метаданных к объектам без риска конфликта с другими свойствами.

    ```javascript
    const id = Symbol('id');

    const user = {
        name: 'Alice',
        [id]: 12345,
    };

    console.log(user[id]); // 12345
    ```

6. **Использование символов с наследованием**

    ```javascript
    const parentSymbol = Symbol('parentSymbol');

    class Parent {
        constructor() {
            this[parentSymbol] = 'Родительское значение';
        }

        getParentData() {
            return this[parentSymbol];
        }
    }

    class Child extends Parent {
        constructor() {
            super();
            this[parentSymbol] = 'Дочернее значение'; // Переопределяем символьное свойство
        }
    }

    const childInstance = new Child();

    console.log(childInstance.getParentData()); // 'Дочернее значение'
    console.log(Object.getOwnPropertySymbols(childInstance)); // [Symbol(parentSymbol)]
    ```

### **3. Использование символов в объектах**

#### **3.1. Символы как ключи для объектов, созданных через `Object()`**

Когда объект создается с помощью конструктора `Object()`, символы могут быть добавлены в качестве ключей точно так же, как и в случае с объектными литералами. Символы остаются уникальными и скрытыми от обычных методов перечисления.

**Пример:**

```javascript
// Создаем объект через конструктор Object()
const obj = new Object();

// Создаем символ
const symbolKey = Symbol('uniqueKey');

// Добавляем свойство с символьным ключом
obj[symbolKey] = 'Это значение связано с символьным ключом';

// Доступ к значению через символьный ключ
console.log(obj[symbolKey]); // 'Это значение связано с символьным ключом'

// Символьные ключи не видны при обычном перечислении
console.log(Object.keys(obj)); // []
console.log(Object.getOwnPropertyNames(obj)); // []

// Но их можно получить с помощью Object.getOwnPropertySymbols()
console.log(Object.getOwnPropertySymbols(obj)); // [Symbol(uniqueKey)]
```

---

#### **3.2. Символы как ключи для объектов, созданных через классы (`class`)**

В классах символы могут использоваться для создания приватных или скрытых свойств и методов. Это особенно полезно, если вы хотите скрыть детали реализации от внешнего кода.

**Пример:**

```javascript
// Создаем символ для приватного свойства
const privateDataSymbol = Symbol('privateData');

class MyClass {
    constructor(publicData, privateData) {
        // Публичное свойство
        this.publicData = publicData;

        // Приватное свойство с использованием символа
        this[privateDataSymbol] = privateData;
    }

    // Публичный метод, который использует приватное свойство
    getPrivateData() {
        return this[privateDataSymbol];
    }
}

// Создаем экземпляр класса
const instance = new MyClass('публичные данные', 'приватные данные');

// Доступ к публичному свойству
console.log(instance.publicData); // 'публичные данные'

// Доступ к приватному свойству через метод
console.log(instance.getPrivateData()); // 'приватные данные'

// Попытка доступа к приватному свойству напрямую
console.log(instance[privateDataSymbol]); // 'приватные данные' (но только если символ доступен)

// Символьные ключи не видны при обычном перечислении
console.log(Object.keys(instance)); // ['publicData']
console.log(Object.getOwnPropertyNames(instance)); // ['publicData']

// Получаем символьные ключи
console.log(Object.getOwnPropertySymbols(instance)); // [Symbol(privateData)]
```

---

#### **3.3. Особенности использования символов в классах:**

1. **"Приватность"**:
   Символы не являются настоящими приватными свойствами (как, например, в языках с поддержкой приватных полей, таких как TypeScript или ES2022+). Однако они позволяют скрыть свойства от обычного перечисления, что делает их менее доступными для случайного использования.

2. **Доступ через символ**:
   Если символ доступен в той же области видимости, то свойство можно получить напрямую. Это делает символы менее безопасными, чем настоящие приватные поля (например, `#privateField` в ES2022+).

3. **Уникальность**:
   Каждый символ уникален, что предотвращает конфликты имен. Это особенно полезно в крупных проектах, где несколько модулей могут добавлять свои свойства к объектам.

4. **Совместимость с наследованием**:
   Символы могут быть использованы в классах с наследованием. Например, родительский класс может определить символьное свойство, а дочерний класс может его использовать или переопределять.

---

### **4. Статические методы `Symbol`**

Объект `Symbol` имеет несколько встроенных **статических методов**, которые помогают работать с символами и обеспечивают специальные возможности в языке.

---

#### **4.1. `Symbol.iterator`**

Используется для создания итерируемых объектов. Если объект имеет `Symbol.iterator`, значит, его можно перебирать в `for...of`.

**Пример:**

```javascript
const myIterable = {
    items: [1, 2, 3],
    [Symbol.iterator]() {
        let index = 0;
        return {
            next: () => ({
                value: this.items[index],
                done: index++ >= this.items.length,
            }),
        };
    },
};

for (let item of myIterable) {
    console.log(item); // 1, 2, 3
}
```

---

#### **4.2. `Symbol.for(key)`**

Создаёт или возвращает **глобальный** символ с указанным ключом. Если символ с таким `key` уже существует, он будет возвращён.

**Пример:**

```javascript
let sym1 = Symbol.for('sharedKey');
let sym2 = Symbol.for('sharedKey');

console.log(sym1 === sym2); // ✅ true (это один и тот же символ)
```

---

#### **4.3. `Symbol.keyFor(sym)`**

Возвращает **ключ глобального символа**, созданного через `Symbol.for()`.

**Пример:**

```javascript
let sym = Symbol.for('myKey');
console.log(Symbol.keyFor(sym)); // "myKey"

let localSym = Symbol('localKey');
console.log(Symbol.keyFor(localSym)); // ❌ undefined (не глобальный)
```

---

#### **4.4. `Symbol.hasInstance`**

Определяет поведение оператора `instanceof`. Позволяет задать **кастомную логику проверки** принадлежности объекта классу.

**Пример:**

```javascript
class CustomClass {
    static [Symbol.hasInstance](instance) {
        return instance.custom === true;
    }
}

const obj1 = { custom: true };
console.log(obj1 instanceof CustomClass); // ✅ true

const obj2 = { custom: false };
console.log(obj2 instanceof CustomClass); // ❌ false
```

---

#### **4.5. `Symbol.toPrimitive`**

Определяет **преобразование объекта** в примитивное значение (`number`, `string`, `default`).

**Пример:**

```javascript
let user = {
    name: 'Alice',
    age: 25,
    [Symbol.toPrimitive](hint) {
        if (hint === 'string') return `User: ${this.name}`;
        if (hint === 'number') return this.age;
        return this.name;
    },
};

console.log(String(user)); // "User: Alice"
console.log(+user); // 25
console.log(user + ''); // "Alice"
```

---

#### **4.6. `Symbol.toStringTag`**

Определяет строковое представление объекта при вызове `Object.prototype.toString()`.

**Пример:**

```javascript
class CustomClass {
    get [Symbol.toStringTag]() {
        return 'MyCustomObject';
    }
}

const obj = new CustomClass();
console.log(Object.prototype.toString.call(obj)); // "[object MyCustomObject]"
```

---

#### **4.7. `Symbol.isConcatSpreadable`**

Определяет, будет ли объект **развёрнут** при объединении массивов через `concat()`.

**Пример:**

```javascript
let arrayLike = {
    0: 'A',
    1: 'B',
    length: 2,
    [Symbol.isConcatSpreadable]: true,
};

console.log(['X'].concat(arrayLike)); // ["X", "A", "B"]
```

---

#### **4.8. `Symbol.unscopables`**

Позволяет скрыть свойства объекта от `with`.

**Пример:**

```javascript
let obj = { hidden: 42 };
obj[Symbol.unscopables] = { hidden: true };

with (obj) {
    console.log(hidden); // ❌ Ошибка: hidden is not defined
}
```

---

#### **4.9. `Symbol.match`, `Symbol.replace`, `Symbol.search`, `Symbol.split`**

Используются в **регулярных выражениях** для переопределения работы методов `String.prototype.match()`, `replace()`, `search()`, `split()`.

**Пример (`Symbol.match`)**

```javascript
class CustomMatcher {
    [Symbol.match](string) {
        return string.includes('hello') ? ['hello'] : null;
    }
}

console.log('hello world'.match(new CustomMatcher())); // ["hello"]
```

---

#### **4.10. `Symbol.species`**

Определяет, какой **конструктор** использовать при создании новых экземпляров в методах (`map()`, `filter()`).

**Пример:**

```javascript
class CustomArray extends Array {
    static get [Symbol.species]() {
        return Array; // Возвращаем обычный Array
    }
}

let arr = new CustomArray(1, 2, 3);
let filtered = arr.filter((x) => x > 1);

console.log(filtered instanceof CustomArray); // ❌ false (вернёт обычный Array)
```

---

#### **Итоговая таблица статических методов `Symbol`**

| Символ                                                            | Описание                                                 |
| ----------------------------------------------------------------- | -------------------------------------------------------- |
| `Symbol.iterator`                                                 | Позволяет объекту быть итерируемым (`for...of`).         |
| `Symbol.for(key)`                                                 | Создаёт или возвращает **глобальный** символ.            |
| `Symbol.keyFor(sym)`                                              | Возвращает ключ глобального символа.                     |
| `Symbol.hasInstance`                                              | Кастомизирует поведение оператора `instanceof`.          |
| `Symbol.toPrimitive`                                              | Определяет, как объект преобразуется в примитив.         |
| `Symbol.toStringTag`                                              | Определяет строковое представление объекта.              |
| `Symbol.isConcatSpreadable`                                       | Определяет, будет ли объект развёрнут в `concat()`.      |
| `Symbol.unscopables`                                              | Скрывает свойства объекта от `with`.                     |
| `Symbol.match`, `Symbol.replace`, `Symbol.search`, `Symbol.split` | Настраивают методы строк и регулярных выражений.         |
| `Symbol.species`                                                  | Определяет конструктор, используемый в методах массивов. |

---

#### **Вывод**

-   Символы `Symbol` используются для тонкой настройки поведения объектов.
-   Они позволяют создавать **уникальные идентификаторы** и изменять встроенные механизмы JS.
-   `Symbol.for()` и `Symbol.keyFor()` дают возможность работать с **глобальными символами**.
-   Специальные символы (`Symbol.iterator`, `Symbol.toPrimitive`, `Symbol.species`) управляют поведением объектов в разных сценариях.

---

### **5. Преимущества использования символов:**

-   **Избежание конфликтов имен**: Символы гарантируют, что ключи не будут конфликтовать с другими свойствами объекта.
-   **Скрытие свойств**: Символьные свойства не видны при обычном перечислении, что делает их полезными для внутреннего использования.
-   **Уникальность**: Каждый символ уникален, что позволяет создавать уникальные идентификаторы.

### **6. Недостатки:**

-   **Сложность отладки**: Поскольку символы не видны при обычном перечислении свойств, их сложнее отлаживать.
-   **Ограниченная совместимость**: Символы не поддерживаются в старых версиях JavaScript (до ES6).

### **7. Сравнение с настоящими приватными полями (ES2022+)**

Начиная с ES2022, в JavaScript появилась поддержка настоящих приватных полей с использованием синтаксиса `#`. В отличие от символов, такие поля действительно приватны и недоступны извне.

**Пример:**

```javascript
class MyClass {
    #privateField = 'Приватное значение';

    getPrivateField() {
        return this.#privateField;
    }
}

const instance = new MyClass();

console.log(instance.getPrivateField()); // 'Приватное значение'
console.log(instance.#privateField); // Ошибка: SyntaxError
```

**Преимущества настоящих приватных полей:**

-   Настоящая приватность: поля недоступны извне.
-   Более чистый синтаксис.

**Преимущества символов:**

-   Совместимость с более старыми версиями JavaScript.
-   Гибкость: символы можно использовать в любых объектах, а не только в классах.

### **8. Заключение**

Символы как ключи объектов предоставляют мощный механизм для создания уникальных и скрытых свойств, независимо от того, создан ли объект через `Object()`, класс или объектный литерал. Они особенно полезны для:

-   Сокрытия внутренних деталей реализации.
-   Избежания конфликтов имен в крупных проектах.
-   Создания метаданных или дополнительных свойств, которые не должны быть видны при обычном перечислении.

Однако, если вам нужна настоящая приватность, лучше использовать приватные поля (`#`) из ES2022+.

---

## |4| **Динамическое создание классов**

Динамическое создание классов в JavaScript — это мощный механизм, который позволяет генерировать классы во время выполнения программы. Это может быть полезно в различных сценариях, таких как создание классов на основе конфигураций, метапрограммирование, или когда структура класса зависит от внешних данных. Рассмотрим различные способы динамического создания классов, их преимущества и недостатки.

---

### 1. **Через `new Function`**

Один из самых гибких способов динамического создания классов — использование конструктора `new Function`. Этот подход позволяет создать класс из строки, что может быть полезно, если вы хотите сгенерировать код на лету.

**Пример:**

```javascript
const className = 'DynamicClass';
const methodName = 'sayHello';
const methodBody = 'console.log("Hello, world!");';

// Динамически создаем класс
const DynamicClass = new Function(
    'return class ' +
        className +
        ' { ' +
        '  ' +
        methodName +
        '() { ' +
        methodBody +
        ' } ' +
        '}',
)();

// Создаем экземпляр класса
const instance = new DynamicClass();
instance.sayHello(); // "Hello, world!"
```

**Преимущества:**

-   **Максимальная гибкость**: Вы можете генерировать любой код на основе строк.
-   **Динамическое создание методов и свойств**: Можно добавлять методы и свойства на основе внешних данных.

**Недостатки:**

-   **Потенциально небезопасно**: Использование `new Function` может быть опасным, если строка кода поступает из ненадежного источника (риск инъекций).
-   **Сложность отладки**: Код, сгенерированный из строк, сложнее отлаживать.
-   **Производительность**: Создание функций через `new Function` может быть медленнее, чем использование стандартных конструкций.

---

### 2. **Через `Object.create` и прототипы**

Этот подход позволяет динамически создавать классы, манипулируя прототипами объектов. В JavaScript классы — это синтаксический сахар над прототипным наследованием, поэтому можно создать класс, работая напрямую с прототипами.

**Пример:**

```javascript
// Создаем конструктор
function DynamicClass() {}

// Динамически добавляем метод в прототип
DynamicClass.prototype.sayHello = function () {
    console.log('Hello, world!');
};

// Создаем экземпляр
const instance = new DynamicClass();
instance.sayHello(); // "Hello, world!"
```

**Преимущества:**

-   **Гибкость**: Можно динамически добавлять методы и свойства.
-   **Простота**: Не требует использования сложных конструкций.

**Недостатки:**

-   **Меньше читаемость**: Код может стать менее понятным, особенно для разработчиков, которые привыкли к синтаксису классов.
-   **Отсутствие синтаксического сахара**: Нет поддержки таких возможностей, как `super`, `static`, или приватные поля.

---

### 3. **Через `eval`**

`eval` — это функция, которая выполняет строку как JavaScript-код. Ее можно использовать для динамического создания классов, но это крайне не рекомендуется из-за серьезных проблем с безопасностью и производительностью.

**Пример:**

```javascript
const className = 'DynamicClass';
const methodName = 'sayHello';
const methodBody = 'console.log("Hello, world!");';

// Динамически создаем класс с помощью eval
eval(`
    class ${className} {
        ${methodName}() {
            ${methodBody}
        }
    }
`);

// Создаем экземпляр
const instance = new DynamicClass();
instance.sayHello(); // "Hello, world!"
```

**Преимущества:**

-   **Максимальная гибкость**: Можно генерировать любой код на основе строк.

**Недостатки:**

-   **Опасность**: `eval` выполняет любой переданный код, что делает его уязвимым для инъекций.
-   **Производительность**: Код, выполняемый через `eval`, не оптимизируется движком JavaScript.
-   **Сложность отладки**: Как и в случае с `new Function`, отладка такого кода сложна.

---

### 4. **Фабричные методы и функции**

Фабричный метод (Factory Method) или фабричная функция (Factory Function) — это способ создания объектов без использования ключевого слова `new`. Вместо вызова конструктора или класса, фабричная функция создает и возвращает объект, инкапсулируя логику его создания.

Это позволяет:

-   Избежать использования `new`, делая код более читаемым.
-   Создавать объекты с разной конфигурацией внутри одной функции.
-   Инкапсулировать сложную логику инициализации.
-   Легко расширять функциональность без изменения основного кода.

---

#### **4.1. Простая фабричная функция**

Простейший пример фабричной функции:

```javascript
function createUser(name, age) {
    return {
        name,
        age,
        sayHello() {
            console.log(`Привет, меня зовут ${this.name}!`);
        },
    };
}

const user1 = createUser('Alice', 25);
const user2 = createUser('Bob', 30);

user1.sayHello(); // Привет, меня зовут Alice!
user2.sayHello(); // Привет, меня зовут Bob!
```

**Здесь фабричная функция `createUser` возвращает новый объект, не используя `new`.**

---

#### **4.2. Фабричная функция с динамическими параметрами**

Можно добавлять параметры, влияющие на создание объекта:

```javascript
function createCar(brand, model, fuelType = 'gasoline') {
    return {
        brand,
        model,
        fuelType,
        start() {
            console.log(
                `${this.brand} ${this.model} работает на ${this.fuelType}.`,
            );
        },
    };
}

const car1 = createCar('Toyota', 'Corolla', 'hybrid');
const car2 = createCar('Ford', 'Focus');

car1.start(); // Toyota Corolla работает на hybrid.
car2.start(); // Ford Focus работает на gasoline.
```

**Фабричная функция позволяет устанавливать значения по умолчанию (`fuelType`).**

---

#### **4.3. Фабрика с приватными данными через замыкание**

Используя замыкания, можно скрывать внутренние данные объекта:

```javascript
function createCounter() {
    let count = 0; // Приватная переменная

    return {
        increment() {
            count++;
            console.log(`Текущее значение: ${count}`);
        },
        decrement() {
            count--;
            console.log(`Текущее значение: ${count}`);
        },
        getCount() {
            return count;
        },
    };
}

const counter = createCounter();
counter.increment(); // Текущее значение: 1
counter.increment(); // Текущее значение: 2
console.log(counter.getCount()); // 2
```

**Значение `count` скрыто от внешнего доступа и доступно только через методы объекта.**

---

#### **4.4. Фабричная функция с прототипами (Object.create)**

Можно использовать `Object.create()` для создания объектов с прототипом:

```javascript
const animalPrototype = {
    makeSound() {
        console.log(`${this.name} издает звук!`);
    },
};

function createAnimal(name, species) {
    let animal = Object.create(animalPrototype);
    animal.name = name;
    animal.species = species;
    return animal;
}

const dog = createAnimal('Бобик', 'собака');
dog.makeSound(); // Бобик издает звук!
console.log(Object.getPrototypeOf(dog) === animalPrototype); // true
```

**Объект `dog` создан с прототипом `animalPrototype`, но без класса.**

---

#### **4.5. Фабричный метод внутри класса**

Фабричный метод может быть частью класса:

```javascript
class User {
    constructor(name, role) {
        this.name = name;
        this.role = role;
    }

    static createAdmin(name) {
        return new User(name, 'admin');
    }

    static createGuest() {
        return new User('Гость', 'guest');
    }
}

const admin = User.createAdmin('Alice');
const guest = User.createGuest();

console.log(admin); // User { name: 'Alice', role: 'admin' }
console.log(guest); // User { name: 'Гость', role: 'guest' }
```

**Фабричные методы `createAdmin` и `createGuest` упрощают создание пользователей.**

---

#### **4.6. Фабричная функция с динамически создаваемым методом**

```javascript
function createClass(methodName, methodBody) {
    return class {
        [methodName]() {
            eval(methodBody);
        }
    };
}

// Динамически создаем класс
const DynamicClass = createClass('sayHello', 'console.log("Hello, world!");');

// Создаем экземпляр
const instance = new DynamicClass();
instance.sayHello(); // "Hello, world!"
```

---

#### **4.7. Сравнение фабричной функции и конструктора**

| Фабричная функция                      | Конструктор                           |
| -------------------------------------- | ------------------------------------- |
| Не использует `new`                    | Использует `new`                      |
| Возвращает объект явно                 | `this` привязывается к новому объекту |
| Позволяет легко использовать замыкания | В основном работает с `this`          |
| Можно динамически выбирать прототип    | Использует `prototype`                |

Пример конструктора:

```javascript
function User(name, age) {
    this.name = name;
    this.age = age;
}

const user = new User('Alice', 25);
console.log(user.name); // Alice
```

Фабричная функция:

```javascript
function createUser(name, age) {
    return { name, age };
}

const user = createUser('Alice', 25);
console.log(user.name); // Alice
```

**Фабричная функция проще и гибче, а конструкторы лучше работают с прототипами.**

---

#### **4.8. Итог**

Фабричные методы и функции удобны, когда:  
✅ Нужно создавать объекты без `new`.  
✅ Требуется скрывать внутреннюю логику (замыкания).  
✅ Нужна гибкость (разные конфигурации объектов).  
✅ Хотим использовать прототипы (`Object.create`).

В то же время классы и конструкторы полезны, когда:  
✅ Нужно использовать прототипное наследование.  
✅ Требуется удобный синтаксис `class`.

**Преимущества:**

-   **Гибкость**: Можно создавать классы с разными методами и свойствами на основе параметров.
-   **Безопасность**: Если не использовать `eval`, этот подход безопаснее, чем `new Function` или `eval`.
-   **Читаемость**: Код остается понятным и структурированным.

**Недостатки:**

-   **Ограниченная гибкость**: Если нужно добавить сложную логику, код может стать громоздким.
-   **Зависимость от параметров**: Фабрика классов может стать сложной, если параметров много.

---

### 5. **Через прокси**

Прокси позволяют перехватывать и изменять поведение объектов. Их можно использовать для создания динамических классов, которые изменяют свое поведение в зависимости от контекста.

**Пример:**

```javascript
class DynamicClass {
    constructor() {
        return new Proxy(this, {
            get(target, prop) {
                if (prop === 'sayHello') {
                    return () => console.log('Hello, world!');
                }
                return target[prop];
            },
        });
    }
}

// Создаем экземпляр
const instance = new DynamicClass();
instance.sayHello(); // "Hello, world!"
```

**Преимущества:**

-   **Гибкость**: Можно динамически изменять поведение объектов.
-   **Метапрограммирование**: Прокси позволяют реализовать сложные сценарии, такие как ленивая загрузка или валидация.

**Недостатки:**

-   **Сложность**: Код с прокси может стать сложным для понимания.
-   **Производительность**: Прокси добавляют накладные расходы на выполнение.

---

### 6. **Через шаблоны (например, с использованием шаблонных литералов)**

Этот подход позволяет генерировать классы на основе шаблонов. Он похож на использование `new Function`, но более структурирован.

**Пример:**

```javascript
const createClass = (className, methodName, methodBody) => {
    const classTemplate = `
        class ${className} {
            ${methodName}() {
                ${methodBody}
            }
        }
    `;
    return eval(classTemplate);
};

// Динамически создаем класс
const DynamicClass = createClass(
    'DynamicClass',
    'sayHello',
    'console.log("Hello, world!");',
);

// Создаем экземпляр
const instance = new DynamicClass();
instance.sayHello(); // "Hello, world!"
```

**Преимущества:**

-   **Гибкость**: Можно генерировать классы на основе шаблонов.
-   **Читаемость**: Шаблоны делают код более структурированным.

**Недостатки:**

-   **Опасность**: Использование `eval` делает этот подход уязвимым.
-   **Сложность отладки**: Как и в случае с `new Function`, отладка сложна.

---

### Заключение

Динамическое создание классов в JavaScript — это мощный инструмент, который может быть полезен в различных сценариях. Однако каждый подход имеет свои преимущества и недостатки:

-   **`new Function` и `eval`** предоставляют максимальную гибкость, но могут быть небезопасными и сложными для отладки.
-   **Фабрики классов** — это безопасный и структурированный способ, но он может стать громоздким при сложной логике.
-   **Прокси** позволяют изменять поведение объектов на лету, но добавляют накладные расходы.
-   **Шаблоны** делают код более читаемым, но также могут быть небезопасными при использовании `eval`.

---

## |5| **Коллекция `Map`**

`Map` — это встроенный объект в JavaScript, который позволяет хранить данные в виде пар **ключ-значение**. В отличие от обычных объектов, ключами в `Map` могут быть любые типы данных: объекты, функции, примитивы и даже другие `Map`.

### **1. Создание `Map`**

`Map` создаётся с помощью конструктора `new Map()`.

**Пример:**

```javascript
const map = new Map();
```

---

### **2. Основные методы и свойства**

#### **2.1. `set(key, value)`**

Добавляет пару ключ-значение в `Map`.

**Пример:**

```javascript
map.set('name', 'Alice');
map.set(1, 'Number One');
map.set({ key: 'obj' }, 'Object as key');
```

#### **2.2. `get(key)`**

Возвращает значение по ключу. Если ключ отсутствует, возвращает `undefined`.

**Пример:**

```javascript
console.log(map.get('name')); // Alice
console.log(map.get(1)); // Number One
console.log(map.get({ key: 'obj' })); // undefined (разные объекты)
```

#### **2.3. `has(key)`**

Проверяет, существует ли ключ в `Map`. Возвращает `true` или `false`.

**Пример:**

```javascript
console.log(map.has('name')); // true
console.log(map.has(2)); // false
```

#### **2.4. `delete(key)`**

Удаляет пару ключ-значение по ключу. Возвращает `true`, если ключ существовал, иначе `false`.

**Пример:**

```javascript
map.delete('name');
console.log(map.has('name')); // false
```

#### **2.5. `clear()`**

Очищает `Map`, удаляя все пары ключ-значение.

**Пример:**

```javascript
map.clear();
console.log(map.size); // 0
```

#### **2.6. `size`**

Свойство, возвращающее количество пар ключ-значение в `Map`.

**Пример:**

```javascript
console.log(map.size); // 2
```

---

### **3. Итерация по `Map`**

`Map` поддерживает методы для итерации по элементам:

#### **3.1. `keys()`**

Возвращает итератор по ключам.

**Пример:**

```javascript
for (const key of map.keys()) {
    console.log(key);
}
// name
// 1
```

#### **3.2. `values()`**

Возвращает итератор по значениям.

**Пример:**

```javascript
for (const value of map.values()) {
    console.log(value);
}
// Alice
// Number One
```

#### **3.3. `entries()`**

Возвращает итератор по парам `[ключ, значение]`. По умолчанию используется в `for...of`.

**Пример:**

```javascript
for (const [key, value] of map.entries()) {
    console.log(key, value);
}
// name Alice
// 1 Number One
```

#### **3.4. `forEach()`**

Вызывает функцию для каждой пары ключ-значение.

**Пример:**

```javascript
map.forEach((value, key) => {
    console.log(key, value);
});
// name Alice
// 1 Number One
```

---

### **4. Особенности `Map`**

#### **4.1. Ключи могут быть любого типа**

В отличие от объектов, где ключи могут быть только строками или символами, в `Map` ключами могут быть любые типы данных, включая объекты и функции.

**Пример:**

```javascript
const objKey = { id: 1 };
map.set(objKey, 'Object as key');
console.log(map.get(objKey)); // Object as key
```

#### **4.2. Сохранение порядка элементов**

`Map` сохраняет порядок добавления элементов, что полезно для итерации.

**Пример:**

```javascript
map.set('a', 1);
map.set('b', 2);
map.set('c', 3);

for (const [key, value] of map) {
    console.log(key, value);
}
// a 1
// b 2
// c 3
```

#### **4.3. Простота проверки наличия ключа**

Метод `has()` позволяет легко проверить наличие ключа, в отличие от объектов, где нужно использовать `in` или `hasOwnProperty()`.

**Пример:**

```javascript
console.log(map.has('a')); // true
```

#### **4.4. Лучшая производительность для частого добавления/удаления**

`Map` оптимизирован для частого добавления и удаления элементов, в отличие от объектов.

---

### **5. Сравнение `Map` и объектов**

| Характеристика             | `Map`                              | Объект                                |
| -------------------------- | ---------------------------------- | ------------------------------------- |
| **Типы ключей**            | Любые (объекты, функции и т.д.)    | Только строки или символы             |
| **Порядок элементов**      | Сохраняется                        | Не гарантируется                      |
| **Размер**                 | `size`                             | Нет встроенного свойства              |
| **Производительность**     | Оптимизирован для частых изменений | Менее эффективен для частых изменений |
| **Проверка наличия ключа** | `has()`                            | `in` или `hasOwnProperty()`           |

---

### **6. Примеры использования**

#### **6.1. Хранение данных с объектами в качестве ключей**

```javascript
const user1 = { id: 1, name: 'Alice' };
const user2 = { id: 2, name: 'Bob' };

const userMap = new Map();
userMap.set(user1, 'Admin');
userMap.set(user2, 'User');

console.log(userMap.get(user1)); // Admin
```

#### **6.2. Подсчёт частоты элементов в массиве**

```javascript
const arr = ['a', 'b', 'a', 'c', 'b', 'a'];
const frequencyMap = new Map();

for (const item of arr) {
    frequencyMap.set(item, (frequencyMap.get(item) || 0) + 1);
}

console.log([...frequencyMap]); // [["a", 3], ["b", 2], ["c", 1]]
```

#### **6.3. Кэширование результатов функции**

```javascript
const cache = new Map();

function expensiveOperation(n) {
    if (cache.has(n)) {
        return cache.get(n);
    }
    const result = n * 2; // Имитация сложной операции
    cache.set(n, result);
    return result;
}

console.log(expensiveOperation(5)); // 10 (вычислено)
console.log(expensiveOperation(5)); // 10 (взято из кэша)
```

---

## |6| **Коллекция `WeakMap`**

`WeakMap` — это коллекция в JavaScript, которая позволяет хранить пары ключ-значение, где ключами могут быть только объекты. В отличие от обычного `Map`, `WeakMap` имеет несколько важных особенностей, которые делают его полезным в определенных сценариях.

---

### 1. **Основные особенности `WeakMap`**

1. **Ключи — только объекты**:
   В `WeakMap` ключами могут быть только объекты. Примитивные значения (числа, строки, булевы значения) не допускаются.

2. **Слабые ссылки на ключи**:
   `WeakMap` хранит слабые ссылки на ключи. Это означает, что если объект, используемый в качестве ключа, больше не доступен в программе (например, на него нет других ссылок), он может быть удален сборщиком мусора (garbage collector), и соответствующая запись в `WeakMap` будет автоматически удалена.

3. **Нет итераторов**:
   В отличие от `Map`, `WeakMap` не предоставляет методов для итерации по ключам, значениям или записям. Это связано с тем, что ключи могут быть удалены сборщиком мусора в любой момент.

4. **Ограниченный API**:
   `WeakMap` имеет только несколько методов: `set`, `get`, `has` и `delete`.

---

### 2. **Создание и использование `WeakMap`**

#### Создание `WeakMap`:

```javascript
const weakMap = new WeakMap();
```

#### Добавление и получение значений:

```javascript
const obj1 = {};
const obj2 = {};

// Добавление значений
weakMap.set(obj1, 'value1');
weakMap.set(obj2, 'value2');

// Получение значений
console.log(weakMap.get(obj1)); // "value1"
console.log(weakMap.get(obj2)); // "value2"
```

#### Проверка наличия ключа:

```javascript
console.log(weakMap.has(obj1)); // true
console.log(weakMap.has({})); // false (новый объект, не связанный с ключами weakMap)
```

#### Удаление записи:

```javascript
weakMap.delete(obj1);
console.log(weakMap.has(obj1)); // false
```

---

### 3. **Пример использования `WeakMap`**

#### Пример 1: Хранение приватных данных

`WeakMap` часто используется для хранения приватных данных, связанных с объектами. Это позволяет избежать утечек памяти, так как данные автоматически удаляются, когда объект больше не используется.

```javascript
const privateData = new WeakMap();

class User {
    constructor(name, age) {
        // Сохраняем приватные данные в WeakMap
        privateData.set(this, { name, age });
    }

    getName() {
        return privateData.get(this).name;
    }

    getAge() {
        return privateData.get(this).age;
    }
}

const user = new User('Alice', 30);
console.log(user.getName()); // "Alice"
console.log(user.getAge()); // 30

// Приватные данные недоступны напрямую
console.log(user.name); // undefined
console.log(user.age); // undefined
```

#### Пример 2: Кэширование

`WeakMap` можно использовать для кэширования результатов вычислений, связанных с объектами. Если объект больше не используется, кэш автоматически очищается.

```javascript
const cache = new WeakMap();

function computeExpensiveValue(obj) {
    if (cache.has(obj)) {
        return cache.get(obj);
    }

    const result = /* дорогостоящие вычисления */ obj.someProperty * 2;
    cache.set(obj, result);
    return result;
}

const obj = { someProperty: 10 };
console.log(computeExpensiveValue(obj)); // 20
console.log(computeExpensiveValue(obj)); // 20 (значение взято из кэша)
```

---

### 4. **Преимущества `WeakMap`**

1. **Автоматическое управление памятью**:
   Поскольку `WeakMap` использует слабые ссылки на ключи, он не препятствует сборке мусора. Это помогает избежать утечек памяти.

2. **Приватность данных**:
   `WeakMap` позволяет хранить данные, которые недоступны напрямую через объект, что полезно для создания приватных свойств.

3. **Эффективность**:
   `WeakMap` оптимизирован для работы с объектами и не требует дополнительных механизмов для управления памятью.

---

### 5. **Ограничения `WeakMap`**

1. **Нет итерации**:
   `WeakMap` не предоставляет методов для итерации по ключам, значениям или записям. Это связано с тем, что ключи могут быть удалены в любой момент.

2. **Только объекты в качестве ключей**:
   Ключами могут быть только объекты. Примитивные значения не поддерживаются.

3. **Ограниченный API**:
   `WeakMap` имеет только четыре метода: `set`, `get`, `has` и `delete`.

---

### 6. **Сравнение `WeakMap` и `Map`**

| Характеристика             | `WeakMap`                       | `Map`                                   |
| -------------------------- | ------------------------------- | --------------------------------------- |
| **Ключи**                  | Только объекты                  | Любые значения (объекты, примитивы)     |
| **Слабые ссылки**          | Да                              | Нет                                     |
| **Итерация**               | Нет                             | Да (методы `keys`, `values`, `entries`) |
| **Автоматическая очистка** | Да (при удалении ключей)        | Нет                                     |
| **Использование памяти**   | Эффективное (нет утечек памяти) | Может привести к утечкам памяти         |

---

### 7. **Когда использовать `WeakMap`?**

-   **Приватные данные**: Для хранения данных, которые должны быть скрыты от внешнего кода.
-   **Кэширование**: Для кэширования результатов, связанных с объектами.
-   **Управление памятью**: Когда важно избежать утечек памяти.

---

### 8. **Пример с автоматической очисткой**

```javascript
let obj = {};

const weakMap = new WeakMap();
weakMap.set(obj, 'some data');

console.log(weakMap.has(obj)); // true

// Удаляем ссылку на объект
obj = null;

// Объект будет удален сборщиком мусора, и запись в WeakMap исчезнет
// (это произойдет не сразу, а при следующем цикле сборки мусора)
```

---

### Заключение

`WeakMap` — это мощный инструмент для работы с объектами в JavaScript, особенно когда важно управление памятью и приватность данных. Он идеально подходит для сценариев, где ключи являются объектами, и нужно избежать утечек памяти. Однако из-за ограниченного API и отсутствия итерации `WeakMap` подходит не для всех задач. Используйте его, когда требуется слабая связь и автоматическое управление памятью.

---

## |7| **Объект `Proxy`**

`Proxy` (прокси) — это встроенный объект в JavaScript, который позволяет перехватывать и управлять операциями с другими объектами, такими как доступ к свойствам, их изменение, удаление и вызов функций.

Это мощный инструмент, который может использоваться для логирования, валидации данных, автоматического заполнения значений, защиты объектов и многого другого.

---

### 1. **Синтаксис**

```javascript
const proxy = new Proxy(target, handler);
```

-   **`target`** – оригинальный объект, к которому применяется прокси.
-   **`handler`** – объект с методами-"ловушками" (`traps`), которые перехватывают операции над `target`.

**Пример базового Proxy**

```javascript
const target = { name: 'Alice' };

const handler = {
    get(target, prop) {
        console.log(`Запрос свойства: ${prop}`);
        return target[prop];
    },
};

const proxy = new Proxy(target, handler);

console.log(proxy.name); // Запрос свойства: name, затем "Alice"
```

Здесь `get()` – это ловушка, которая перехватывает обращение к свойствам объекта.

---

### 2. **Методы-ловушки (Traps) в Proxy**

#### **2.1. `get(target, prop, receiver)`** – перехватывает чтение свойства

```javascript
const obj = { name: 'John', age: 30 };

const proxy = new Proxy(obj, {
    get(target, prop) {
        if (prop in target) {
            return target[prop];
        } else {
            return 'Свойство не найдено';
        }
    },
});

console.log(proxy.name); // "John"
console.log(proxy.city); // "Свойство не найдено"
```

---

#### **2.2. `set(target, prop, value, receiver)`** – перехватывает изменение свойств

```javascript
const obj = {};

const proxy = new Proxy(obj, {
    set(target, prop, value) {
        if (typeof value === 'number') {
            target[prop] = value;
        } else {
            console.log(`Ошибка: Значение ${prop} должно быть числом`);
        }
    },
});

proxy.age = 25; // Работает
proxy.name = 'Alice'; // Ошибка: Значение name должно быть числом
console.log(proxy.age); // 25
console.log(proxy.name); // undefined
```

---

#### **2.3. `has(target, prop)`** – перехватывает проверку существования свойства (`in`)

```javascript
const obj = { name: 'Alice', age: 25 };

const proxy = new Proxy(obj, {
    has(target, prop) {
        return prop !== 'age'; // Запрещаем доступ к age
    },
});

console.log('name' in proxy); // true
console.log('age' in proxy); // false
```

---

#### **2.4. `deleteProperty(target, prop)`** – перехватывает удаление свойства (`delete`)

```javascript
const obj = { name: 'Alice', age: 25 };

const proxy = new Proxy(obj, {
    deleteProperty(target, prop) {
        if (prop === 'age') {
            console.log('Удаление age запрещено');
            return false;
        }
        return delete target[prop];
    },
});

delete proxy.name; // Удаляется нормально
delete proxy.age; // Удаление age запрещено
console.log(proxy); // { age: 25 }
```

---

#### **2.5. `apply(target, thisArg, args)`** – перехватывает вызовы функции

```javascript
function greet(name) {
    return `Привет, ${name}!`;
}

const proxy = new Proxy(greet, {
    apply(target, thisArg, args) {
        console.log(`Вызов функции с аргументами: ${args}`);
        return target(...args);
    },
});

console.log(proxy('Alice'));
// Вызов функции с аргументами: Alice
// Привет, Alice!
```

---

#### **2.6. `construct(target, args, newTarget)`** – перехватывает создание экземпляра через `new`

```javascript
class User {
    constructor(name) {
        this.name = name;
    }
}

const ProxyUser = new Proxy(User, {
    construct(target, args) {
        console.log(`Создание экземпляра с аргументами: ${args}`);
        return new target(...args);
    },
});

const user = new ProxyUser('Alice');
// Создание экземпляра с аргументами: Alice
console.log(user.name); // Alice
```

---

### 3. **Применение Proxy в реальных задачах**

#### **3.1. Валидация данных**

```javascript
const user = {};

const proxy = new Proxy(user, {
    set(target, prop, value) {
        if (prop === 'age' && typeof value !== 'number') {
            throw new Error('Возраст должен быть числом');
        }
        target[prop] = value;
    },
});

proxy.age = 30; // Работает
proxy.age = 'тридцать'; // Ошибка: Возраст должен быть числом
```

---

#### **3.2. Автоматическое заполнение значений**

```javascript
const defaults = {
    name: 'Гость',
    age: 18,
};

const proxy = new Proxy(
    {},
    {
        get(target, prop) {
            return prop in target ? target[prop] : defaults[prop];
        },
    },
);

console.log(proxy.name); // "Гость"
console.log(proxy.age); // 18
proxy.name = 'Alice';
console.log(proxy.name); // "Alice"
```

---

#### **3.3. Логирование доступа к объекту**

```javascript
const obj = { a: 1, b: 2 };

const proxy = new Proxy(obj, {
    get(target, prop) {
        console.log(`Доступ к свойству: ${prop}`);
        return target[prop];
    },
});

console.log(proxy.a); // Доступ к свойству: a -> 1
console.log(proxy.b); // Доступ к свойству: b -> 2
```

---

#### **3.4. Защита от изменения данных**

```javascript
const obj = { name: 'Alice' };

const proxy = new Proxy(obj, {
    set(target, prop, value) {
        console.log(`Изменение запрещено`);
        return false;
    },
});

proxy.name = 'Bob'; // Изменение запрещено
console.log(proxy.name); // Alice
```

---

#### **3.5. Создание реактивных объектов (пример для Vue.js-like систем)**

```javascript
function reactive(target) {
    return new Proxy(target, {
        get(target, prop) {
            console.log(`Читаем ${prop}: ${target[prop]}`);
            return target[prop];
        },
        set(target, prop, value) {
            console.log(`Изменяем ${prop} на ${value}`);
            target[prop] = value;
            return true;
        },
    });
}

const state = reactive({ count: 0 });

state.count++; // Читаем count: 0, Изменяем count на 1
console.log(state.count); // Читаем count: 1
```

---

#### **3.6. Перехват и изменение поведения класса и его экземпляров**

Этот код демонстрирует, как можно использовать прокси для перехвата и изменения поведения класса и его экземпляров. Он полезен для задач, где требуется гибкость, например, для логирования, валидации или создания динамических объектов. Однако важно помнить о потенциальных накладных расходах и сложности кода.

```js
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
}
const PersonProxy = new Proxy(Person, {
    construct(target, args) {
        console.log('Construct...');

        return new Proxy(new target(...args), {
            get(t, prop) {
                console.log(`Getting prop ${prop}`);
                return t[prop];
            },
        });
    },
});

const p = new PersonProxy('Neo', 32);
```

Здесь создается прокси для класса `Person`. Прокси позволяет перехватывать и изменять поведение операций, таких как создание экземпляра класса или доступ к его свойствам.

Когда вызывается `new PersonProxy('Neo', 32)`, происходит следующее:

1. **Перехват операции `new`**:

    - Вызывается ловушка `construct` прокси `PersonProxy`.
    - В консоль выводится сообщение: `Construct...`.

2. **Создание экземпляра `Person`**:

    - Внутри ловушки `construct` создается экземпляр класса `Person` с аргументами `'Neo'` и `32`.

3. **Создание прокси для экземпляра**:

    - Для созданного экземпляра `Person` создается новый прокси с ловушкой `get`.

4. **Возврат прокси**:
    - Прокси для экземпляра возвращается как результат операции `new PersonProxy`.

Теперь, если мы попытаемся получить доступ к свойствам объекта `p`, будет вызвана ловушка `get`.

Пример:

```javascript
console.log(p.name); // "Getting prop name", затем "Neo"
console.log(p.age); // "Getting prop age", затем 32
```

**Что происходит:**

1. **Перехват доступа к свойству**:

    - Когда мы обращаемся к `p.name`, вызывается ловушка `get`.
    - В консоль выводится сообщение: `Getting prop name`.

2. **Возврат значения свойства**:
    - Ловушка `get` возвращает значение свойства `name` из экземпляра `Person`.

---

#### **3.7. Добавление комбинированного вызова**

```js
const person = {
    name: 'Alise',
    age: 30,
    job: 'Coder',
};

const op = new Proxy(person, {
    get(target, prop) {
        if (!(prop in target)) {
            return prop
                .split('_')
                .map((p) => target[p])
                .join(' ');
        }
        return target[prop];
    },
});

console.log(op.age); // 30
console.log(op.age_name_job); // 30 Alise Coder
console.log(op.name_job); // Alise Coder
```

#### **3.8. Значение по умолчанию для отсутствующих ключей**

Для любого ключа, которого нет в целевом объекте будет возвращено значение по умолчанию
`defaultWalue`

```js
const withDefaultValue = (target, defaultWalue = 0) => {
    return new Proxy(target, {
        get: (obj, prop) => (prop in obj ? obj[prop] : defaultWalue),
    });
};

const position = withDefaultValue({ x: 32, y: 34 }, 0);

console.log(position.x); // 32
console.log(position.y); // 34
console.log(position.z); // 0
```

#### **3.9. Спрятанные поля**

```js
const withHiddenProps = (target, prefix = '_') => {
    return new Proxy(target, {
        has: (obj, prop) => prop in obj && !prop.startsWith(prefix),
        ownKeys: (obj) =>
            Reflect.ownKeys(obj).filter((key) => !key.startsWith(prefix)),
        get: (obj, prop, receiver) => (prop in receiver ? obj[prop] : void 0),
    });
};

const data = withHiddenProps({ name: 'Alice', age: 23, _uid: 'sasas' });
console.log(data.name); // Alice
console.log(data._uid); // undefined
console.log(Object.keys(data)); // ['name', 'age']
console.log('_uid' in data); // false
for (let key in data) console.log(key); // 'name' 'age'
```

#### **3.10. Индексированный массив**

Этот код создает прокси для класса `Array`, который добавляет дополнительную функциональность: индексацию элементов по их `id` и метод `findById` для быстрого поиска элемента по `id`.

Этот код демонстрирует, как можно использовать прокси для добавления дополнительной функциональности к стандартным классам, таким как `Array`. Он полезен для задач, где требуется быстрый поиск элементов по уникальному идентификатору. Однако важно учитывать ограничения и при необходимости расширять функциональность для поддержки других методов.

```js
const IndexedArray = new Proxy(Array, {
    construct(target, [args]) {
        const index = {};
        args.forEach((item) => (index[item.id] = item));

        return new Proxy(new target(...args), {
            get(arr, prop) {
                switch (prop) {
                    case 'push':
                        return (item) => {
                            index[item.id] = item;
                            arr[prop].call(arr, item);
                        };
                    case 'findById':
                        return (id) => index[id];
                    default:
                        return arr[prop];
                }
            },
        });
    },
});

const users = new IndexedArray([
    { id: 11, name: 'Ivan', age: 33 },
    { id: 22, name: 'John', age: 45 },
    { id: 33, name: 'Vlad', age: 12 },
]);

console.log(users.findById(22)); // { id: 22, name: 'John', age: 45 }
console.log(users.push({ id: 44, name: 'Fedor' }));
console.log(users.findById(44)); // { id: 44, name: 'Fedor' }
```

**Разбор кода**

1. **Создание прокси для класса `Array`**

```javascript
const IndexedArray = new Proxy(Array, {
    construct(target, [args]) {
        // Логика индексации
    },
});
```

-   **`IndexedArray`** — это прокси для класса `Array`.
-   **`construct(target, [args])`** — ловушка, которая перехватывает операцию создания экземпляра массива (вызов `new`).

2. **Индексация элементов**

```javascript
const index = {};
args.forEach((item) => (index[item.id] = item));
```

-   **`index`** — это объект, который будет хранить элементы массива, индексированные по их `id`.
-   **`args`** — это массив элементов, переданных в конструктор.
-   Для каждого элемента массива создается запись в объекте `index`, где ключ — это `id` элемента, а значение — сам элемент.

3. **Создание прокси для экземпляра массива**

```javascript
return new Proxy(new target(...args), {
    get(arr, prop) {
        // Логика перехвата методов
    },
});
```

-   **`new target(...args)`** — создается экземпляр массива с переданными элементами.
-   **`new Proxy(...)`** — создается прокси для этого экземпляра массива.
-   **`get(arr, prop)`** — ловушка, которая перехватывает доступ к свойствам и методам массива.

4. **Перехват методов**

```javascript
get(arr, prop) {
    switch (prop) {
        case 'push':
            return (item) => {
                index[item.id] = item;
                arr[prop].call(arr, item);
            };
        case 'findById':
            return (id) => index[id];
        default:
            return arr[prop];
    }
}
```

-   **`prop`** — это имя свойства или метода, к которому обращаются.
-   **`switch (prop)`** — в зависимости от имени свойства или метода выполняется разная логика.

**4.1. Перехват метода `push`**

```javascript
case 'push':
    return (item) => {
        index[item.id] = item;
        arr[prop].call(arr, item);
    };
```

-   Когда вызывается метод `push`, он добавляет элемент в массив и обновляет индекс.
-   **`index[item.id] = item`** — элемент добавляется в объект `index`.
-   **`arr[prop].call(arr, item)`** — вызывается оригинальный метод `push` массива.

**4.2. Добавление метода `findById`**

```javascript
case 'findById':
    return (id) => index[id];
```

-   Когда вызывается метод `findById`, он возвращает элемент из индекса по его `id`.

**4.3. Обработка остальных свойств и методов**

```javascript
default:
    return arr[prop];
```

-   Для всех остальных свойств и методов возвращается оригинальное значение из массива.

---

**Пример использования**

1. **Создание индексированного массива**

```javascript
const users = new IndexedArray([
    { id: 11, name: 'Ivan', age: 33 },
    { id: 22, name: 'John', age: 45 },
    { id: 33, name: 'Vlad', age: 12 },
]);
```

-   Создается массив `users` с тремя элементами.
-   Каждый элемент индексируется по его `id`.

2. **Поиск элемента по `id`**

```javascript
console.log(users.findById(22)); // { id: 22, name: 'John', age: 45 }
```

-   Метод `findById` возвращает элемент с `id = 22`.

3. **Добавление нового элемента**

```javascript
users.push({ id: 44, name: 'Alice', age: 25 });
console.log(users.findById(44)); // { id: 44, name: 'Alice', age: 25 }
```

-   Метод `push` добавляет новый элемент в массив и обновляет индекс.
-   После добавления элемент можно найти по его `id`.

4. **Доступ к стандартным методам массива**

```javascript
console.log(users.length); // 4
console.log(users[0]); // { id: 11, name: 'Ivan', age: 33 }
```

-   Стандартные свойства и методы массива (например, `length` и доступ по индексу) работают как обычно.

---

**Преимущества**

-   **Быстрый поиск**: Метод `findById` работает за время O(1) благодаря индексации.
-   **Гибкость**: Прокси позволяет добавлять новую функциональность без изменения исходного класса `Array`.
-   **Прозрачность**: Стандартные методы массива продолжают работать как обычно.

**Ограничения**

-   **Только для объектов с `id`**: Код предполагает, что все элементы массива имеют уникальное свойство `id`.
-   **Нет поддержки других методов изменения массива**: Например, `splice`, `pop`, `shift` и другие методы не обновляют индекс. Для полной поддержки нужно добавить перехват этих методов.

---

**Пример с обновлением индекса для `splice`**

Чтобы поддерживать индекс при использовании других методов, можно добавить перехват для `splice`:

```javascript
case 'splice':
    return (...args) => {
        const removed = arr[prop].call(arr, ...args);
        removed.forEach((item) => delete index[item.id]);
        args.slice(2).forEach((item) => (index[item.id] = item));
        return removed;
    };
```

---

### **Заключение**

-   `Proxy` позволяет управлять поведением объектов, перехватывая их операции.
-   Используется для логирования, валидации, защиты данных и реактивного программирования.
-   Главное отличие от `Object.defineProperty()` – возможность перехватывать не только `get/set`, но и `delete`, `apply`, `construct` и другие операции.

Proxy – мощный инструмент, делающий JavaScript-программы более гибкими и безопасными!

---

## |8| **Оператор `with`**

Оператор **`with`** позволяет сократить доступ к свойствам объекта, временно добавляя его в **область видимости**.

**Синтаксис:**

```javascript
with (object) {
    // код, где можно обращаться к свойствам объекта напрямую
}
```

**Основная идея**:  
Вместо написания `object.property` можно просто использовать `property`, как если бы оно было локальной переменной.

---

### 1. **Пример использования `with`**

**Обычное обращение к свойствам объекта:**

```javascript
const user = {
    name: 'Alice',
    age: 25,
    city: 'New York',
};

console.log(user.name); // "Alice"
console.log(user.age); // 25
console.log(user.city); // "New York"
```

**Использование `with`:**

```javascript
with (user) {
    console.log(name); // "Alice"
    console.log(age); // 25
    console.log(city); // "New York"
}
```

Внутри `with` можно обращаться к свойствам `user` напрямую, без явного указания `user.`.

---

### 2. **Почему `with` считается плохой практикой?**

Хотя `with` делает код короче, его **использование не рекомендуется**. Основные причины:

#### **2.1. Неоднозначность поиска переменной**

Если внутри `with` объявить переменную, движок JS не сразу понимает, откуда она:

-   Из объекта?
-   Или из внешней области видимости?

**Проблемный пример:**

```javascript
const user = { name: 'Alice' };
let name = 'Bob';

with (user) {
    console.log(name); // ❓ "Alice" или "Bob"?
}
```

**Ответ:** `"Alice"`, потому что внутри `with` сначала ищется свойство `name` в `user`, и только если его там нет — в глобальной области.

---

#### **2.2. Плохо работает с `strict mode`**

В строгом режиме (`"use strict"`) использование `with` **запрещено**.

```javascript
'use strict';
const obj = { a: 1 };

with (obj) {
    console.log(a); // ❌ Ошибка: 'with' statement is not allowed in strict mode
}
```

Причина: `with` делает код менее предсказуемым и сложнее для оптимизации движком JS.

---

#### **2.3. Медленная производительность**

`with` замедляет выполнение кода, потому что движку приходится **искать переменные в нескольких местах**.

-   Сначала проверяется, есть ли свойство в объекте.
-   Потом проверяется внешняя область видимости.
-   Это делает код **трудночитаемым** и **менее оптимизированным**.

---

### 3. **Альтернативы `with`**

Вместо `with` лучше использовать:

#### **3.1. Деструктуризация объекта**

```javascript
const user = { name: 'Alice', age: 25, city: 'New York' };

// Извлекаем свойства
const { name, age, city } = user;

console.log(name); // "Alice"
console.log(age); // 25
console.log(city); // "New York"
```

Это **короче** и **безопаснее**, чем `with`.

---

#### **3.2. Использование переменной**

```javascript
const user = { name: 'Alice', age: 25, city: 'New York' };
const u = user; // Сокращаем доступ

console.log(u.name); // "Alice"
console.log(u.age); // 25
console.log(u.city); // "New York"
```

`u` указывает на `user`, но код остаётся **предсказуемым**.

---

### 4. **Когда `with` всё-таки полезен?**

Хотя `with` **не рекомендуется**, он может пригодиться, если **нужно временно работать с объектом, имя которого неизвестно заранее**.

**Пример: работа с `Math`**

```javascript
with (Math) {
    console.log(round(3.14)); // 3
    console.log(sqrt(16)); // 4
}
```

Но даже здесь **лучше** использовать `Math.` напрямую.

---

### **6. Итог: стоит ли использовать `with`?**

-   **Нет, `with` считается плохой практикой.**
-   **Альтернативы (`деструктуризация`, `переменная`) делают код чище и безопаснее.**

**Вывод:**

-   `with` усложняет чтение кода, делает его менее предсказуемым и замедляет выполнение.
-   В **строгом режиме (`"use strict"`) он вообще запрещён.**
-   Лучше **не использовать `with` в современных проектах**.

---

## |9| **Основы ООП**

**Объектно-ориентированное программирование (ООП)** — это парадигма программирования, основанная на концепции **объектов**. Объекты могут содержать данные (свойства) и поведение (методы).

ООП используется для организации кода, его повторного использования и удобного управления сложными системами.

---

### 1. **Основные принципы ООП**

1. **Инкапсуляция** – скрытие деталей реализации и предоставление доступа только к нужной информации.
2. **Наследование** – возможность одного класса (объекта) наследовать свойства и методы другого.
3. **Полиморфизм** – возможность использования одного интерфейса для разных реализаций.
4. **Абстракция** – отделение логики от реализации, представление объекта через его основные характеристики.

---

### 2. **Объекты в JavaScript**

В JavaScript объекты являются основой всего. Они могут быть созданы несколькими способами:

#### **2.1. Создание объекта через литерал**

```javascript
const person = {
    name: 'Alice',
    age: 25,
    greet() {
        console.log(`Привет, меня зовут ${this.name}`);
    },
};

person.greet(); // Привет, меня зовут Alice
```

➡️ Это самый простой способ создания объекта, но он не позволяет легко создавать множество одинаковых объектов.

---

#### **2.2. Создание объекта через `Object.create()`**

```javascript
const personProto = {
    greet() {
        console.log(`Привет, меня зовут ${this.name}`);
    },
};

const person = Object.create(personProto);
person.name = 'Alice';
person.age = 25;

person.greet(); // Привет, меня зовут Alice
```

➡️ Используется для создания объектов с определённым прототипом.

---

#### **2.3. Функции-конструкторы**

```javascript
function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.greet = function () {
    console.log(`Привет, меня зовут ${this.name}`);
};

const alice = new Person('Alice', 25);
alice.greet(); // Привет, меня зовут Alice
```

➡️ Позволяет создавать много экземпляров объектов с одним прототипом.

---

#### **2.4. Классы (ES6+)**

```javascript
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    greet() {
        console.log(`Привет, меня зовут ${this.name}`);
    }
}

const alice = new Person('Alice', 25);
alice.greet(); // Привет, меня зовут Alice
```

➡️ Более удобный синтаксис, заменяющий функции-конструкторы.

---

### 3. **Принципы ООП в JavaScript**

#### **3.1. Инкапсуляция (Encapsulation)**

Инкапсуляция позволяет скрывать внутренние данные объекта, предоставляя доступ только к нужным свойствам и методам.

```javascript
class User {
    #password; // Приватное свойство (ES2020)

    constructor(name, password) {
        this.name = name;
        this.#password = password;
    }

    checkPassword(password) {
        return this.#password === password;
    }
}

const user = new User('Alice', '12345');
console.log(user.name); // Alice
console.log(user.#password); // Ошибка! Свойство приватное
console.log(user.checkPassword('12345')); // true
```

➡️ `#password` – приватное свойство, доступ к которому возможен только внутри класса.

---

#### **3.2. Наследование (Inheritance)**

Наследование позволяет одному классу расширять другой, повторно используя его свойства и методы.

```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }

    makeSound() {
        console.log('Какой-то звук...');
    }
}

class Dog extends Animal {
    makeSound() {
        console.log('Гав-гав!');
    }
}

const dog = new Dog('Бобик');
dog.makeSound(); // Гав-гав!
```

➡️ `Dog` наследует `Animal`, но переопределяет метод `makeSound`.

---

#### **3.3. Полиморфизм (Polymorphism)**

Полиморфизм позволяет методам вести себя по-разному в зависимости от контекста.

```javascript
class Bird {
    fly() {
        console.log('Птица летит...');
    }
}

class Eagle extends Bird {
    fly() {
        console.log('Орел парит высоко в небе!');
    }
}

const bird = new Bird();
const eagle = new Eagle();

bird.fly(); // Птица летит...
eagle.fly(); // Орел парит высоко в небе!
```

➡️ Оба объекта имеют метод `fly`, но реализуют его по-разному.

---

#### **3.4. Абстракция (Abstraction)**

Абстракция позволяет скрывать сложные детали реализации, оставляя только важные части.

```javascript
class Car {
    constructor(model) {
        this.model = model;
    }

    start() {
        this.#checkEngine();
        console.log(`${this.model} заводится...`);
    }

    #checkEngine() {
        console.log('Проверка двигателя...');
    }
}

const car = new Car('Tesla');
car.start();
// Проверка двигателя...
// Tesla заводится...

car.#checkEngine(); // Ошибка! Приватный метод
```

➡️ Внешнему коду не нужно знать, как работает `#checkEngine()`.

---

### 4. **Отличие Абстракции от Инкапсуляции**

Абстракция и инкапсуляция — это два ключевых принципа ООП, но они решают разные задачи.

#### **4.1. Инкапсуляция (Encapsulation)**

➡️ **Скрытие данных** внутри объекта и предоставление доступа только через определённые методы.

**Пример инкапсуляции**

```javascript
class User {
    #password; // Приватное свойство

    constructor(name, password) {
        this.name = name;
        this.#password = password;
    }

    checkPassword(password) {
        return this.#password === password;
    }
}

const user = new User('Alice', '12345');
console.log(user.name); // "Alice"
console.log(user.#password); // ❌ Ошибка! Доступ запрещён
console.log(user.checkPassword('12345')); // ✅ true
```

**Инкапсуляция:**

-   **Скрывает детали реализации** (`#password` недоступен напрямую).
-   **Защищает данные от случайного изменения**.
-   **Позволяет управлять доступом** к данным через методы (`checkPassword`).

---

#### **4.2. Абстракция (Abstraction)**

1. **Скрытие сложной логики**, оставляя только важные детали.

**Пример абстракции**

```javascript
class Car {
    constructor(model) {
        this.model = model;
    }

    start() {
        this.#checkEngine();
        console.log(`${this.model} заводится...`);
    }

    #checkEngine() {
        console.log('Проверка двигателя...');
    }
}

const car = new Car('Tesla');
car.start();
// Проверка двигателя...
// Tesla заводится...

car.#checkEngine(); // ❌ Ошибка! Доступ запрещён
```

**Преимущества:**

-   **Скрывает сложные детали** (`#checkEngine` остаётся внутри класса).
-   **Предоставляет только важные функции** (`start()` – единственная точка взаимодействия).
-   **Упрощает использование** объекта, скрывая ненужную информацию.

2. **Повышение уровня абстракции** снижает связанность модулей.

Вместо того чтобы менять `status` объекта `Message` напрямую (`message.status = "read"`), мы используем метод `showMessage()`. Это **инкапсулирует** логику изменения статуса и делает код более гибким.

**2.1. Плохой пример (жесткая связанность)**

```javascript
class Message {
    constructor(text) {
        this.text = text;
        this.status = 'unread'; // по умолчанию сообщение не прочитано
    }
}

const message = new Message('Hello, world!');

// Изменение статуса напрямую (жесткая связанность)
message.status = 'read';

console.log(message); // { text: 'Hello, world!', status: 'read' }
```

**Проблемы:**

-   **Прямой доступ к `status`**: любой код может менять его произвольно.
-   **Нельзя добавить логику** при изменении статуса (например, логирование или валидацию).
-   **Сложно поддерживать** код, если логику изменения статуса нужно изменить.

---

**2.2. Хороший пример (пониженная связанность)**

```javascript
class Message {
    constructor(text) {
        this.text = text;
        this.#status = 'unread'; // по умолчанию
    }

    // Метод для безопасного изменения статуса
    markAsRead() {
        if (this.#status !== 'read') {
            this.#status = 'read';
            console.log('Message marked as read.');
        }
    }

    showMessage() {
        console.log(this.text);
        this.markAsRead(); // Абстрагируем логику изменения статуса
    }
}

// Используем класс
const message = new Message('Hello, world!');

// Отображаем сообщение и автоматически помечаем как прочитанное
message.showMessage(); // Выведет: "Hello, world!" и "Message marked as read."

console.log(message); // { text: 'Hello, world!', status: 'read' }
```

**Преимущества:**

-   **Инкапсуляция**: изменение статуса скрыто внутри класса.
-   **Гибкость**: можно легко добавить логику (логирование, валидацию, оповещения).
-   **Меньше зависимости от внутренней структуры**: если статус изменится (например, на `"seen"` вместо `"read"`), нам не нужно менять код во многих местах.
-   **Абстракция через метод `showMessage()`** снижает связанность.
-   **Внешний код больше не меняет `status` напрямую**, что делает систему более устойчивой к изменениям.

---

#### **4.3. Основные различия**

| Характеристика       | Инкапсуляция                         | Абстракция                        |
| -------------------- | ------------------------------------ | --------------------------------- |
| **Что делает?**      | Скрывает данные                      | Скрывает сложность                |
| **Как достигается?** | Приватные свойства и методы          | Простые и понятные интерфейсы     |
| **Цель**             | Защита данных и управление доступом  | Упрощение использования объекта   |
| **Пример**           | `#password` нельзя изменить напрямую | `start()` скрывает сложную логику |

---

#### **4.4. Простая аналогия**

**Инкапсуляция** – это закрытая коробка с данными (можно взаимодействовать только через отверстие).  
**Абстракция** – это автомобиль, где водитель управляет машиной (газ, тормоз), но не думает о работе двигателя.

---

#### **4.5. Вывод**

🔹 **Инкапсуляция** – это технический механизм защиты данных.  
🔹 **Абстракция** – это концепция упрощения, скрывающая ненужные детали.

Они работают вместе: **инкапсуляция защищает детали, а абстракция показывает только важные части объекта.**

---

### 5. **ООП в реальном мире**

Применение ООП в JavaScript:

-   **Разработка веб-приложений** (React, Vue, Angular используют классы)
-   **Создание игр** (например, классы `Character`, `Enemy`, `Weapon`)
-   **Работа с API** (например, класс `HttpClient` для запросов)

---

### **Заключение**

-   **ООП** помогает организовывать код, делает его понятным и расширяемым.
-   Основные принципы **Инкапсуляция, Наследование, Полиморфизм и Абстракция** позволяют легко управлять сложными системами.
-   JavaScript поддерживает ООП через **объекты, прототипы и классы**.

---

## **Задачи**

### **Инкапсуляция, приватные поля и методы**

1. Создайте класс `BankAccount`, который содержит приватное поле `_balance`. Реализуйте методы `deposit(amount)` и `withdraw(amount)`, обеспечивающие доступ к балансу.
2. Добавьте в класс `User` приватное поле `_password`. Реализуйте метод `checkPassword(inputPassword)`, который возвращает `true`, если введённый пароль совпадает с сохранённым.
3. Реализуйте класс `Counter` с приватным полем `_count` и методами `increment()` и `getCount()`, предотвращающими прямое изменение `_count`.
4. Создайте класс `Car` с приватными полями `_speed` и `_fuel`. Добавьте метод `drive(distance)`, уменьшающий `fuel` и учитывающий скорость.
5. Используйте `#` для объявления приватных полей в классе `User`. Реализуйте методы `setName(name)` и `getName()`.

---

### **Геттеры и сеттеры**

1. Создайте класс `Person` с геттером `fullName`, который объединяет `firstName` и `lastName`.
2. Реализуйте класс `Temperature`, содержащий поле `_celsius`. Добавьте геттер `fahrenheit` и сеттер `fahrenheit`, который пересчитывает температуру в Цельсиях.
3. Напишите класс `Rectangle` с геттерами `area` и `perimeter`, которые вычисляют площадь и периметр.
4. Создайте класс `Product`, в котором сеттер `price` не позволяет устанавливать цену ниже 0.
5. Реализуйте класс `User` с геттером `maskedEmail`, который скрывает часть почты (например, `"joh***@mail.com"`).

---

### **Символы как ключи**

1. Создайте объект `user`, у которого одно из свойств хранится в `Symbol()`.
2. Реализуйте класс `SecretData`, который использует `Symbol()` для хранения конфиденциальных данных.
3. Напишите функцию `generateUniqueID()`, которая использует `Symbol()` для создания уникальных идентификаторов пользователей.
4. Используйте `Symbol.iterator` для создания итератора в классе `Collection`.
5. Создайте объект с методами, один из которых должен быть скрытым через `Symbol()`.

---

### **Динамическое создание классов**

1. Напишите функцию `createUserClass()`, которая возвращает динамически созданный класс `User`.
2. Реализуйте функцию `generateModelClass(name, fields)`, которая создаёт класс с заданными полями.
3. Используйте `class extends` внутри функции, чтобы динамически создавать подклассы.
4. Напишите фабрику классов, которая создаёт классы с определёнными методами, переданными в параметры.
5. Динамически создайте класс `Vehicle` с разными свойствами в зависимости от переданного типа транспорта.

---

### **Коллекция `Map`, `WeakMap`**

1. Создайте `Map`, который хранит цены товаров. Реализуйте методы `addProduct(name, price)`, `getPrice(name)`, `deleteProduct(name)`.
2. Напишите функцию, которая преобразует объект в `Map`.
3. Используйте `WeakMap` для хранения приватных данных внутри класса `User`.
4. Реализуйте кэширование результатов функции с помощью `Map`.
5. Напишите программу, которая считает частоту слов в тексте, используя `Map`.

---

### **Объект `Proxy`**

1. Создайте прокси-объект, который логирует все обращения к свойствам объекта.
2. Реализуйте Proxy, который запрещает удаление свойств объекта.
3. Напишите Proxy, который добавляет защиту на изменение данных объекта.
4. Реализуйте Proxy для массива, который перехватывает доступ к индексам.
5. Используйте Proxy для автоприведения строк в число при обращении к объекту.

---

### **Оператор `with`**

1. Напишите функцию, использующую `with()` для работы со вложенным объектом настроек.
2. Используйте `with()` для упрощения доступа к свойствам объекта `config`.
3. Проверьте, как `with()` влияет на производительность в сравнении с обычным доступом.
4. Напишите код, который показывает, почему `with()` не рекомендуется к использованию.
5. Создайте программу, которая использует `with()` для обработки данных пользователя.

---

### **Основы ООП**

1. Создайте класс `Animal` с методом `makeSound()` и унаследуйте от него `Dog`, `Cat`.
2. Реализуйте класс `Shape` с методами `getArea()` и `getPerimeter()`, а затем создайте классы `Circle` и `Rectangle`.
3. Используйте принципы инкапсуляции, создавая класс `BankAccount`.
4. Напишите класс `Vehicle`, который будет базовым для `Car` и `Bike`. Реализуйте полиморфизм.
5. Создайте фабричный метод, который динамически создаёт объекты разных типов (`Car`, `Truck`).
