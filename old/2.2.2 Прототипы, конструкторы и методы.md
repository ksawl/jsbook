# **2.2.2 Прототипы, конструкторы и методы**

> [Index](./0%20Index.md)
> || [2.2 Объекты](./2.2%20Объекты.md)

---

## |1| **Инстанс объекта (экземпляр объекта)**

Инстанс объекта (или экземпляр объекта) — это конкретный объект, созданный на основе класса или конструктора. Каждый инстанс обладает свойствами и методами, определёнными в классе или конструкторе, но может иметь свои уникальные значения свойств.

### **1. Что такое инстанс объекта?**

Инстанс объекта — это конкретная реализация объекта, созданная с использованием:

-   **Класса** (в современном JavaScript).
-   **Функции-конструктора** (в классическом JavaScript).

Каждый инстанс имеет:

-   Собственные свойства (уникальные для каждого объекта).
-   Методы, определённые в классе или конструкторе.

---

### **2. Создание инстанса**

#### **2.1. Создание инстанса через класс**

Классы в JavaScript предоставляют удобный способ создания инстансов.

**Пример:**

```javascript
class User {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    greet() {
        console.log(`Hello, my name is ${this.name}!`);
    }
}

// Создание инстанса
const user1 = new User('Alice', 25);
const user2 = new User('Bob', 30);

console.log(user1.name); // Alice
console.log(user2.name); // Bob
user1.greet(); // Hello, my name is Alice!
user2.greet(); // Hello, my name is Bob!
```

#### **2.2. Создание инстанса через функцию-конструктор**

До появления классов в JavaScript инстансы создавались с помощью функций-конструкторов.

**Пример:**

```javascript
function User(name, age) {
    this.name = name;
    this.age = age;

    this.greet = function () {
        console.log(`Hello, my name is ${this.name}!`);
    };
}

// Создание инстанса
const user1 = new User('Alice', 25);
const user2 = new User('Bob', 30);

console.log(user1.name); // Alice
console.log(user2.name); // Bob
user1.greet(); // Hello, my name is Alice!
user2.greet(); // Hello, my name is Bob!
```

---

### **3. Особенности инстансов**

#### **3.1. Уникальность свойств**

Каждый инстанс имеет свои собственные свойства, которые могут отличаться от свойств других инстансов.

**Пример:**

```javascript
console.log(user1.name); // Alice
console.log(user2.name); // Bob
```

#### **3.2. Общие методы**

Методы, определённые в классе или прототипе функции-конструктора, являются общими для всех инстансов. Это позволяет экономить память, так как методы не дублируются для каждого объекта.

**Пример:**

```javascript
console.log(user1.greet === user2.greet); // true (один и тот же метод)
```

#### **3.3. Прототипное наследование**

Инстансы наследуют методы и свойства от прототипа класса или функции-конструктора.

**Пример:**

```javascript
class User {
    constructor(name) {
        this.name = name;
    }
    greet() {
        console.log(`Hello, ${this.name}!`);
    }
}

const user = new User('Alice');
console.log(user.hasOwnProperty('greet')); // false (метод находится в прототипе)
```

---

### **4. Проверка инстанса**

#### **4.1. Оператор `instanceof`**

Оператор `instanceof` проверяет, является ли объект инстансом определённого класса или конструктора.

**Пример:**

```javascript
console.log(user1 instanceof User); // true
console.log(user1 instanceof Object); // true (все объекты наследуют от Object)
```

#### **4.2. Метод `Object.getPrototypeOf()`**

Позволяет получить прототип объекта.

**Пример:**

```javascript
console.log(Object.getPrototypeOf(user1) === User.prototype); // true
```

---

### **5. Примеры использования**

#### **5.1. Создание инстансов с разными свойствами**

```javascript
class Car {
    constructor(brand, model) {
        this.brand = brand;
        this.model = model;
    }
    drive() {
        console.log(`Driving ${this.brand} ${this.model}`);
    }
}

const car1 = new Car('Toyota', 'Corolla');
const car2 = new Car('Honda', 'Civic');

car1.drive(); // Driving Toyota Corolla
car2.drive(); // Driving Honda Civic
```

#### **5.2. Использование наследования**

```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }
    speak() {
        console.log(`${this.name} makes a noise.`);
    }
}

class Dog extends Animal {
    speak() {
        console.log(`${this.name} barks.`);
    }
}

const dog = new Dog('Rex');
dog.speak(); // Rex barks.
```

---

## |2| **Прототипы и наследование**

Прототипы и наследование — это ключевые концепции JavaScript, которые позволяют объектам наследовать свойства и методы от других объектов. В отличие от классического наследования, используемого в таких языках, как Java или C++, JavaScript использует прототипное наследование. Это означает, что объекты могут напрямую наследовать от других объектов.

### **1. Что такое прототип?**

Каждый объект в JavaScript имеет скрытое свойство [[Prototype]], которое ссылается на другой объект, называемый прототипом. Когда вы пытаетесь получить доступ к свойству или методу объекта, JavaScript сначала ищет его в самом объекте. Если свойство не найдено, поиск продолжается в прототипе объекта, затем в прототипе прототипа и так далее, пока не будет достигнут `null` (конец цепочки прототипов).

---

### **2. Как проверить прототип объекта?**

#### **2.1. Свойство `__proto__`**

Свойство `__proto__` (нестандартное, но поддерживаемое во всех браузерах) позволяет получить или установить прототип объекта.

**Пример:**

```javascript
console.log(user.__proto__ === Object.prototype); // true
```

#### **2.2. Метод `Object.getPrototypeOf()`**

Метод `Object.getPrototypeOf()` возвращает прототип объекта.

**Пример:**

```javascript
console.log(Object.getPrototypeOf(user) === Object.prototype); // true
```

---

### **3. Прототип `Object.prototype`**

В JavaScript прототип `Object.prototype` находится в верхушке цепочки прототипов для большинства объектов. Это означает, что почти все сущности в JavaScript наследуют методы и свойства от `Object.prototype`. Давайте рассмотрим, у каких именно сущностей присутствует прототип `Object.prototype`.

---

#### **3.1. Объекты, созданные через литерал `{}` или `new Object()`**

Любой объект, созданный через литерал `{}` или конструктор `new Object()`, имеет прототип `Object.prototype`.

**Пример:**

```javascript
const obj = {};
console.log(obj.__proto__ === Object.prototype); // true
```

---

#### **3.2. Массивы (`Array`)**

Массивы в JavaScript являются объектами, и их прототип `Array.prototype` наследует от `Object.prototype`.

**Пример:**

```javascript
const arr = [1, 2, 3];
console.log(arr.__proto__ === Array.prototype); // true
console.log(arr.__proto__.__proto__ === Object.prototype); // true
```

---

#### **3.3. Функции (`Function`)**

Функции в JavaScript также являются объектами. Их прототип `Function.prototype` наследует от `Object.prototype`.

**Пример:**

```javascript
function foo() {}
console.log(foo.__proto__ === Function.prototype); // true
console.log(foo.__proto__.__proto__ === Object.prototype); // true
```

---

#### **3.4. Даты (`Date`)**

Объекты `Date` наследуют от `Date.prototype`, который, в свою очередь, наследует от `Object.prototype`.

**Пример:**

```javascript
const date = new Date();
console.log(date.__proto__ === Date.prototype); // true
console.log(date.__proto__.__proto__ === Object.prototype); // true
```

---

#### **3.5. Регулярные выражения (`RegExp`)**

Объекты `RegExp` наследуют от `RegExp.prototype`, который наследует от `Object.prototype`.

**Пример:**

```javascript
const regex = /abc/;
console.log(regex.__proto__ === RegExp.prototype); // true
console.log(regex.__proto__.__proto__ === Object.prototype); // true
```

---

#### **3.6. Обёртки примитивов (`String`, `Number`, `Boolean`)**

Когда примитивные значения (строки, числа, булевы значения) используются как объекты (например, при вызове методов), JavaScript автоматически создаёт для них объекты-обёртки. Эти объекты наследуют от соответствующих прототипов (`String.prototype`, `Number.prototype`, `Boolean.prototype`), которые, в свою очередь, наследуют от `Object.prototype`.

**Пример:**

```javascript
const str = 'Hello';
console.log(str.__proto__ === String.prototype); // true
console.log(str.__proto__.__proto__ === Object.prototype); // true

const num = 42;
console.log(num.__proto__ === Number.prototype); // true
console.log(num.__proto__.__proto__ === Object.prototype); // true

const bool = true;
console.log(bool.__proto__ === Boolean.prototype); // true
console.log(bool.__proto__.__proto__ === Object.prototype); // true
```

---

#### **3.7. Объекты, созданные с помощью `Object.create(null)`**

Объекты, созданные с помощью `Object.create(null)`, не имеют прототипа, то есть их `[[Prototype]]` равен `null`. Такие объекты не наследуют от `Object.prototype`.

**Пример:**

```javascript
const obj = Object.create(null);
console.log(obj.__proto__); // undefined
```

---

#### **3.8. Исключения: `null` и `undefined`**

-   `null` и `undefined` — это примитивные значения, и они не имеют прототипов.
-   Попытка доступа к свойствам или методам `null` или `undefined` приведёт к ошибке.

**Пример:**

```javascript
console.log(null.__proto__); // Ошибка: Cannot read properties of null
console.log(undefined.__proto__); // Ошибка: Cannot read properties of undefined
```

##### **3.8.1. `null`:**

-   У значения `null` **нет прототипа**.
-   `null` представляет отсутствие объекта или значения.
-   При попытке обратиться к прототипу `null`, например, `Object.getPrototypeOf(null)`, результатом будет **`null`**, а не объект.

**Пример:**

```javascript
console.log(Object.getPrototypeOf(null)); // null
```

-   В контексте цепочки прототипов `null` — это "дно". Если вы создаете объект и вызываете его прототип по цепочке (например, через `Object.getPrototypeOf()`), цепочка рано или поздно заканчивается на `null`.

---

##### **3.8.2. `undefined`:**

-   Значение `undefined` вообще **не имеет прототипа** и **не является объектом**.
-   При попытке получить прототип `undefined` возникает ошибка.

**Пример:**

```javascript
try {
    console.log(Object.getPrototypeOf(undefined));
} catch (error) {
    console.error(error.message); // Cannot convert undefined or null to object
}
```

---

##### **Почему так?**

1. **`null`**:

    - Это значение специально создано для обозначения "пустого" объекта или "ничего". Поэтому оно может возвращать `null` как свое "прототипное дно".

2. **`undefined`**:
    - Это значение означает "неопределено". Оно используется для переменных, которым ничего не присвоено. Как и у других примитивов, у него нет ни прототипа, ни внутренней структуры объекта.

---

##### Таблица для сравнения:

| Значение    | Тип         | Прототип           | Примечание                             |
| ----------- | ----------- | ------------------ | -------------------------------------- |
| `null`      | `object`    | `null`             | Прямо указывает на отсутствие объекта. |
| `undefined` | `undefined` | Ошибка при запросе | Обозначает отсутствие значения.        |

---

#### **3.9. Итог**

-   **Прототип `Object.prototype`** присутствует у большинства сущностей в JavaScript, включая:
    -   Объекты, созданные через `{}` или `new Object()`.
    -   Массивы (`Array`).
    -   Функции (`Function`).
    -   Даты (`Date`).
    -   Регулярные выражения (`RegExp`).
    -   Обёртки примитивов (`String`, `Number`, `Boolean`).
-   **Исключения**:
    -   Объекты, созданные через `Object.create(null)`, не имеют прототипа.
    -   Примитивы `null` и `undefined` не имеют прототипов.

---

### **4. Добавление методов в прототип**

Объекты в JavaScript можно создавать разными способами. В зависимости от способа методы могут:

-   **Храниться внутри самого объекта** (что приводит к дублированию метода в каждом экземпляре).
-   **Попадать в прототип** (разделяться между всеми экземплярами, экономя память).

**Способы создания объектов**

1. Литерал объекта `{}`
2. `new Object()`
3. `new Object({...})`
4. `Object.create(proto)`
5. Функция-конструктор `function User()`
6. Класс `class User {}`

---

#### **1. Литерал объекта `{}`**

```javascript
const user = {
    name: 'Alice',
    sayHello() {
        console.log(`Hello, my name is ${this.name}`);
    },
};
```

**Где хранится метод `sayHello()`?**

-   В самом объекте `user`, **он не в прототипе**.
-   Если создать новый объект `user2`, метод придется **копировать вручную**.

```javascript
console.log(user.hasOwnProperty('sayHello')); // true
console.log(user.__proto__.sayHello); // undefined

const user2 = { ...user };
console.log(user.sayHello === user2.sayHello); // false (методы разные!)
```

**Как это исправить?**

Несмотря на это можно добавить прототип вручную используя для этого `Object.setPrototypeOf()`, для этого надо вынести методы в отдельный объект, который добавить в прототип к объекту со свойствами. Это может быть удобно для разделения структуры данных от методов.

```js
const userProto = {
    sayHello() {
        console.log(`Hello from prototype, my name is ${this.name}`);
    },
};
const user = {
    name: 'Alice',
};

// Устанавливаем новый прототип с методом sayHello
Object.setPrototypeOf(user, userProto);

user.sayHello(); // "Hello from prototype, my name is Alice"
```

**Вывод:**

-   Методы, объявленные в объекте через литерал, **не попадают в прототип**.
-   Можно добавить прототип через `Object.setPrototypeOf()`

---

#### **2. `new Object()`**

```javascript
const user = new Object();
user.name = 'Alice';
user.sayHello = function () {
    console.log(`Hello, my name is ${this.name}`);
};
```

**Где хранится метод?**

-   В самом объекте `user`.
-   `Object.prototype` доступен, но метод `sayHello()` туда **не попадает**.

```javascript
console.log(user.hasOwnProperty('sayHello')); // true
console.log(user.__proto__.sayHello); // undefined
```

**Вывод:**

-   `new Object()` создает объект, но **методы вручную добавляются внутрь**.
-   Чтобы метод был в `prototype`, его надо добавить явно:

```javascript
Object.prototype.globalMethod = function () {
    console.log('I am in prototype!');
};

console.log(user.globalMethod); // работает, т.к. `Object.prototype` в цепочке
```

---

#### **3. `new Object({...})`**

```javascript
const user = new Object({ name: 'Alice', age: 25 });

console.log(user.name); // "Alice"
console.log(user.age); // 25
```

**Где методы?**

-   `new Object({...})` аналогичен `Object({...})` и **просто создает объект**, переданный в параметры.
-   Методы передаются только если они уже есть в переданном объекте.

```javascript
const user = new Object({
    name: 'Alice',
    sayHello() {
        console.log(`Hello, my name is ${this.name}`);
    },
});

console.log(user.hasOwnProperty('sayHello')); // true
console.log(user.__proto__.sayHello); // undefined
```

**Вывод:**

-   Метод `sayHello()` **не в прототипе**, а **в самом объекте**.
-   Чтобы методы были в `prototype`, используйте `Object.create(proto)`, функцию-конструктор или `class`.

---

#### **4. `Object.create(null)`**

```javascript
const user = Object.create(null); // объект без прототипа
user.name = 'Alice';
user.sayHello = function () {
    console.log(`Hello, my name is ${this.name}`);
};
```

**Где хранится метод?**

-   Он также **не в прототипе**, а прямо в `user`.
-   `Object.create(null)` создает объект **без прототипа**, поэтому даже `Object.prototype` тут недоступен.

---

#### **5. `Object.create(proto)`**

```javascript
const protoUser = {
    sayHello() {
        console.log('Hello from prototype!');
    },
};

const user = Object.create(protoUser);
user.name = 'Alice';
```

**Где хранится метод `sayHello()`?**

-   В `protoUser`, который **стал прототипом** для `user`.
-   `user` **не содержит `sayHello()`, но наследует его**.

```javascript
console.log(user.sayHello); // [Function: sayHello]
console.log(user.hasOwnProperty('sayHello')); // false (в прототипе)
console.log(Object.getPrototypeOf(user) === protoUser); // true
```

**Вывод:**

-   `Object.create(proto)` создает объект, **указывая его прототип**.
-   Это полезно для **наследования без классов**.

---

#### **6. Функция-конструктор и `prototype`**

При использовании **функции-конструктора** методы объекта можно добавлять в `prototype`, чтобы **не дублировать их в каждом объекте**.

**1. Пример без `prototype` (плохой вариант)**

```javascript
function User(name) {
    this.name = name;
    this.sayHello = function () {
        console.log(`Hello, my name is ${this.name}`);
    };
}

const user1 = new User('Alice');
const user2 = new User('Bob');

console.log(user1.sayHello === user2.sayHello); // false (методы разные!)
```

**Недостатки:**

-   У **каждого экземпляра** `User` создается **своя копия** метода `sayHello()`, что расходует память.

**2. Пример с `prototype` (хороший вариант)**

```javascript
function User(name) {
    this.name = name;
}

// Метод добавляем в прототип
User.prototype.sayHello = function () {
    console.log(`Hello, my name is ${this.name}`);
};

const user1 = new User('Alice');
const user2 = new User('Bob');

console.log(user1.sayHello === user2.sayHello); // true (метод один для всех!)
```

**Где `sayHello()`?**

-   В `User.prototype`, а не в самих объектах.

```javascript
console.log(user1.hasOwnProperty('sayHello')); // false
console.log(user1.__proto__.sayHello); // [Function: sayHello]
console.log('sayHello' in user1); // true (есть в прототипе)
console.log(Object.getPrototypeOf(user1) === User.prototype); // true
```

**Вывод:**

-   Метод `sayHello()` **не копируется** в каждый объект.
-   Он **хранится в `User.prototype`** и доступен всем экземплярам.
-   Это **экономит память и ускоряет работу**.

> [!NOTE]
>
> **Когда метод добавляется в `prototype`?**
>
> -   Если он **добавлен в `prototype` вручную** (`User.prototype.method = function() {}`).
> -   Если он **объявлен внутри `class`** (см. далее).

---

#### **7. Классы (`class`)**

В **ES6-классах** методы автоматически попадают в `prototype`.

```javascript
class User {
    constructor(name) {
        this.name = name;
    }

    sayHello() {
        console.log(`Hello, my name is ${this.name}`);
    }
}

const user1 = new User('Alice');
const user2 = new User('Bob');

console.log(user1.sayHello === user2.sayHello); // true
```

**Где `sayHello()`?**

```javascript
console.log(User.prototype); // { sayHello: [Function: sayHello], constructor: [Function: User] }
console.log(User.prototype.sayHello); // [Function: sayHello]
console.log(user1.hasOwnProperty('sayHello')); // false
console.log('sayHello' in user1); // true (в прототипе)
```

**Вывод:**

-   Внутри `class` методы **автоматически добавляются** в `User.prototype`.
-   Это делает их **разделяемыми** между всеми объектами.
-   `sayHello()` не находится в объекте `user1`, а в `User.prototype`.

---

#### **Когда методы НЕ попадают в `prototype`?**

**1. Когда метод объявлен прямо в объекте**

```javascript
const user = {
    name: 'Alice',
    sayHello: function () {
        console.log('Hello!');
    },
};
console.log(user.hasOwnProperty('sayHello')); // true (в самом объекте)
```

**2. Когда метод объявлен в `constructor` без `prototype`**

```javascript
function User(name) {
    this.name = name;
    this.sayHello = function () {
        console.log('Hello!');
    };
}
console.log(new User('Alice').hasOwnProperty('sayHello')); // true
```

> `sayHello()` создается **в каждом экземпляре отдельно**.

**3. Когда метод `static` (он остается в самом классе, а не в `prototype`)**

```javascript
class User {
    static sayHi() {
        console.log('Hi!');
    }
}

console.log(User.prototype.sayHi); // undefined
console.log(User.sayHi); // [Function: sayHi]
```

> `static`-методы хранятся в **самом классе**, а не в `prototype`.

**4. Когда метод присвоен через `this` внутри `class`.**

```javascript
class User {
    constructor(name) {
        this.sayHello = function () {
            console.log('Hello!');
        };
    }
}
```

> Такой метод **не попадает в `prototype`**, а создается в каждом объекте отдельно.

**Вывод:**

**Методы НЕ попадают в `prototype`, если:**

-   Методы в **литералах объектов**,
-   Они объявлены **внутри конструктора**.
-   Они являются **`static`** (**статические методы**)
-   Они присвоены **в `this` внутри класса**.

---

#### **Заключение**

| **Способ создания объекта** | **Метод в `prototype`?**                 |
| --------------------------- | ---------------------------------------- |
| Литерал `{}`                | ❌ Нет                                   |
| `new Object()`              | ❌ Нет                                   |
| `new Object({...})`         | ❌ Нет                                   |
| `Object.create(null)`       | ❌ Нет                                   |
| `Object.create(proto)`      | ✅ Да (если `proto` содержит методы)     |
| Функция-конструктор         | ✅ Да (если явно добавлен в `prototype`) |
| `class`                     | ✅ Да (автоматически)                    |

---

### **5. Цепочка прототипов**

Когда вы пытаетесь получить доступ к свойству или методу объекта, JavaScript сначала ищет его в самом объекте. Если свойство не найдено, поиск продолжается в прототипе объекта, затем в прототипе прототипа и так далее, пока не будет достигнут `null` (конец цепочки прототипов).

**Пример:**

```javascript
const user = {
    name: 'Alice',
};

console.log(user.toString()); // [object Object] (метод найден в Object.prototype)
```

---

### **6. Изменение прототипа объекта**

#### **6.1. Использование `Object.setPrototypeOf()`**

Метод `Object.setPrototypeOf()` позволяет изменить прототип объекта.

**Пример:**

```javascript
const animal = {
    speak() {
        console.log('Some sound');
    },
};

const dog = {
    name: 'Rex',
};

Object.setPrototypeOf(dog, animal);
dog.speak(); // Some sound (метод унаследован от animal)
```

#### **6.2. Использование `Object.create()`**

Метод `Object.create()` создаёт новый объект с указанным прототипом.

**Пример:**

```javascript
const animal = {
    speak() {
        console.log('Some sound');
    },
};

const dog = Object.create(animal);
dog.name = 'Rex';
dog.speak(); // Some sound (метод унаследован от animal)
```

#### **6.3. Использование свойства `__proto__`**

```js
const animal = {
    speak() {
        console.log('Some sound');
    },
};

const dog = {};
dog.__proto__ = animal; // Устанавливаем прототип
dog.speak(); // Some sound
```

#### **6.4. Использование конструкторов**

Функции-конструкторы позволяют создавать объекты с общим прототипом. Прототип функции-конструктора доступен через свойство `prototype`.

```js
function Animal(name) {
    this.name = name;
}

Animal.prototype.speak = function () {
    console.log(`${this.name} makes a sound`);
};

const dog = new Animal('Rex');
dog.speak(); // Rex makes a sound
```

---

### **7. Примеры**

#### **7.1. Наследование методов от `Object.prototype`**

```javascript
const user = {
    name: 'Alice',
};

console.log(user.hasOwnProperty('name')); // true (метод унаследован от Object.prototype)
console.log(user.toString()); // [object Object] (метод унаследован от Object.prototype)
```

#### **7.2. Изменение прототипа**

```javascript
const animal = {
    speak() {
        console.log('Some sound');
    },
};

const dog = {
    name: 'Rex',
};

Object.setPrototypeOf(dog, animal);
dog.speak(); // Some sound
```

---

### **8. Итог**

-   Почти все сущности в JavaScript наследуют методы и свойства от `Object.prototype`.
-   Прототип позволяет объекту наследовать свойства и методы от другого объекта.
-   Цепочка прототипов определяет порядок поиска свойств и методов.
-   Прототип объекта можно изменить с помощью `Object.setPrototypeOf()`, `Object.create()`, свойства `__proto__` или конструктор.

---

## |3| **Функции-конструкторы**

Функция-конструктор — это обычная функция, которая используется для создания и инициализации объектов. Когда функция вызывается с ключевым словом `new`, она выполняет специальные шаги для создания нового объекта. Функции-конструкторы являются основой для реализации объектно-ориентированного программирования (ООП) в JavaScript, особенно до появления классов в ES6..

```js
function Person(name, age) {
    this.name = name;
    this.age = age;

    this.greet = function () {
        console.log(`Hello, my name is ${this.name}`);
    };
}

const alice = new Person('Alice', 25);
alice.greet(); // Hello, my name is Alice
```

Здесь:

-   `Person` — это функция-конструктор.
-   `new Person("Alice", 25)` создаёт новый объект и вызывает функцию `Person` с `this`, указывающим на этот объект.
-   Свойства `name` и `age` добавляются в новый объект.

### **1. Особенности функций-конструкторов**

#### **1.1. Именование**

Функции-конструкторы принято называть с заглавной буквы, чтобы отличать их от обычных функций.

**Пример:**

```js
function Car(brand, model) {
    this.brand = brand;
    this.model = model;
}
```

#### **1.2. Возврат значения**

Если функция-конструктор явно возвращает объект, он будет использован вместо созданного объекта. Если возвращается примитивное значение, оно игнорируется.

**Пример:**

```js
function Person(name) {
    this.name = name;
    return { custom: 'object' }; // Возвращается этот объект
}

const person = new Person('Alice');
console.log(person); // { custom: "object" }
```

#### **1.3. Добавление методов**

Методы можно добавлять к объекту через `this` внутри функции-конструктора.

**Пример:**

```javascript
function Person(name, age) {
    this.name = name;
    this.age = age;

    this.greet = function () {
        console.log(`Привет, меня зовут ${this.name}, мне ${this.age} лет.`);
    };
}

const person1 = new Person('Мария', 25);
person1.greet(); // Привет, меня зовут Мария, мне 25 лет.
```

#### **1.4. Вызов без `new`**

Если функция-конструктор вызывается без `new`, `this` будет ссылаться на глобальный объект (в браузере — `window`), что может привести к ошибкам.

**Пример:**

```js
function Person(name) {
    this.name = name;
}

const person = Person('Alice'); // Без new
console.log(person); // undefined
console.log(window.name); // Alice (в браузере)
```

#### **1.5. Статические методы и свойства**

Статические методы и свойства принадлежат самой функции-конструктору, а не её экземплярам. Они полезны для реализации функциональности, которая не зависит от конкретного объекта.

**Пример:**

```javascript
function Person(name, age) {
    this.name = name;
    this.age = age;
}

// Статическое свойство
Person.species = 'Homo sapiens';

// Статический метод
Person.compareAges = function (person1, person2) {
    return person1.age - person2.age;
};

const person1 = new Person('Алексей', 30);
const person2 = new Person('Мария', 25);

console.log(Person.species); // Homo sapiens
console.log(Person.compareAges(person1, person2)); // 5 (Алексей старше Марии на 5 лет)
```

### **2. Свойство `.prototype`**

Свойство `.prototype` — это важная концепция в JavaScript, которая используется для реализации наследования и совместного использования методов между объектами. Оно тесно связано с прототипным наследованием и функциями-конструкторами.

Добавление методов внутри функции-конструктора имеет недостаток: каждый объект будет иметь свою копию метода, что может привести к избыточному использованию памяти. Чтобы методы были общими для всех объектов, созданных через конструктор, их добавляют в `.prototype`.

#### **2.1. Что такое `.prototype`?**

-   **`.prototype`** — это свойство, которое есть только у функций (кроме стрелочных функций). Оно указывает на объект, который будет использоваться как прототип для всех объектов, созданных с помощью этой функции через `new`.
-   Когда функция используется как конструктор (с ключевым словом `new`), объект, на который указывает `.prototype`, становится прототипом созданного объекта.

---

#### **2.2. Как работает `.prototype`?**

##### **1. Функции-конструкторы**

Когда функция используется как конструктор (с `new`), объект, на который указывает `.prototype`, становится прототипом созданного объекта.

**Пример:**

```javascript
function Person(name) {
    this.name = name;
}

// Добавляем метод в прототип
Person.prototype.greet = function () {
    console.log(`Hello, my name is ${this.name}`);
};

const alice = new Person('Alice');
alice.greet(); // Hello, my name is Alice
```

Здесь:

-   `Person.prototype` — это объект, который будет прототипом для всех объектов, созданных через `new Person()`.
-   Метод `greet` добавляется в `Person.prototype`, поэтому все объекты, созданные через `new Person()`, могут использовать этот метод.

---

##### **2. Цепочка прототипов**

Когда вы пытаетесь получить доступ к свойству или методу объекта, JavaScript сначала ищет его в самом объекте. Если свойство не найдено, поиск продолжается в прототипе объекта (то есть в `Person.prototype`), затем в прототипе прототипа и так далее, пока не будет достигнут `null`.

**Пример:**

```javascript
console.log(alice.hasOwnProperty('name')); // true (свойство есть в объекте)
console.log(alice.hasOwnProperty('greet')); // false (метод находится в прототипе)
```

---

#### **2.3. Примеры использования `.prototype`**

##### **1. Добавление методов в прототип**

Методы, добавленные в `.prototype`, доступны всем объектам, созданным через конструктор.

**Пример:**

```javascript
function Car(brand) {
    this.brand = brand;
}

Car.prototype.drive = function () {
    console.log(`Driving ${this.brand}`);
};

const toyota = new Car('Toyota');
toyota.drive(); // Driving Toyota
```

##### **2. Наследование через прототипы**

Прототипы позволяют реализовать наследование. Например, можно создать новый конструктор, который наследует методы и свойства от другого конструктора.

**Пример:**

```javascript
function Animal(name) {
    this.name = name;
}

Animal.prototype.speak = function () {
    console.log(`${this.name} makes a sound`);
};

function Dog(name, breed) {
    Animal.call(this, name); // Вызов конструктора родителя
    this.breed = breed;
}

// Наследование прототипа
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

Dog.prototype.bark = function () {
    console.log(`${this.name} barks!`);
};

const dog = new Dog('Rex', 'German Shepherd');
dog.speak(); // Rex makes a sound (метод унаследован от Animal)
dog.bark(); // Rex barks! (метод класса Dog)
```

##### **3. Проверка типа объекта**

Для проверки, был ли объект создан с помощью определенного конструктора, можно использовать оператор `instanceof`.

**Пример:**

```javascript
console.log(dog1 instanceof Dog); // true
console.log(dog1 instanceof Animal); // true
console.log(dog1 instanceof Object); // true
```

---

#### **2.4. Отличие `.prototype` от `__proto__`**

-   **`.prototype`** — это свойство функции, которое указывает на объект, используемый как прототип для объектов, созданных через эту функцию.
-   **`__proto__`** — это свойство объекта, которое указывает на его прототип.

**Пример:**

```javascript
function Person(name) {
    this.name = name;
}

const alice = new Person('Alice');

console.log(Person.prototype === alice.__proto__); // true
```

---

#### **2.5. Когда использовать `.prototype`?**

-   **Для добавления методов**: Если вы хотите, чтобы все объекты, созданные через конструктор, имели доступ к определённым методам, добавьте их в `.prototype`.
-   **Для реализации наследования**: Используйте `.prototype` для создания цепочек прототипов и наследования свойств и методов.

---

### **3. Ключевое слово `new`**

Ключевое слово `new` в JavaScript используется для создания инстанса (экземпляра) объекта на основе функции-конструктора или класса. Когда функция вызывается с `new`, она выполняет специальные шаги для создания и инициализации нового объекта.

#### **3.1. Как работает `new`?**

Когда функция вызывается с `new`, происходит следующее:

1. **Создаётся новый пустой объект**.
2. **Устанавливается прототип нового объекта**:
    - Прототипом нового объекта становится `prototype` функции-конструктора. Например, если функция-конструктор называется `User`, то созданный объект будет иметь прототип `User.prototype`.

```js
const newObject = Object.create(User.prototype);
```

3. **Выполняется тело функции-конструктора**:
    - Вызов функции-конструктора передает аргументы и связывает `this` с только что созданным объектом.
    - Конструктор получает доступ к этому объекту и может добавлять свойства или методы.
4. **Возвращается новый объект**:
    - Если функция не возвращает явно другой объект, возвращается созданный объект.

---

#### **3.2. Пример использования `new`**

**1. Создание инстанса через функцию-конструктор**

```javascript
function User(name, age) {
    this.name = name;
    this.age = age;

    this.greet = function () {
        console.log(`Hello, my name is ${this.name}!`);
    };
}

// Создание инстанса
const user = new User('Alice', 25);
console.log(user.name); // Alice
user.greet(); // Hello, my name is Alice!
```

**2. Создание инстанса через класс**

```javascript
class User {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    greet() {
        console.log(`Hello, my name is ${this.name}!`);
    }
}

// Создание инстанса
const user = new User('Alice', 25);
console.log(user.name); // Alice
user.greet(); // Hello, my name is Alice!
```

---

#### **3.3. Что происходит под капотом?**

Когда вызывается `new User("Alice", 25)`, JavaScript выполняет следующие шаги:

**Шаг 1: Создание нового объекта**

```javascript
const user = {};
```

**Шаг 2: Установка прототипа**

```javascript
Object.setPrototypeOf(user, User.prototype);
```

или "Шаг 1" и "Шаг 2" можно объединить

```js
const user = Object.create(User.prototype);
```

**Шаг 3: Вызов функции-конструктора**

```javascript
User.call(user, 'Alice', 25);
```

Инициализация свойств:

**Шаг 4: Внутри конструктора выполняется:**

```js
this.name = 'Alice';
this.age = 25;
```

**Шаг 5: Возврат объекта**

```javascript
return user;
```

**Итоговый объект:**

```js
user = {
    name: 'Alice',
    age: 25,
    __proto__: User.prototype, // Указывает на прототип конструктора
};
```

Метод `great()` доступен через цепочку прототипов:

```js
user.great(); // Hello, my name is Alice!
```

---

#### **3.4. Пример ручной реализации `new`**

Чтобы лучше понять, как работает `new`, можно реализовать его функциональность вручную.

```javascript
function myNew(constructor, ...args) {
    // Шаг 1: Создание нового объекта
    const obj = {};

    // Шаг 2: Установка прототипа
    Object.setPrototypeOf(obj, constructor.prototype);

    // Шаг 3: Вызов функции-конструктора с привязкой `this` к новому объекту
    const result = constructor.apply(obj, args);

    // Шаг 4: Возврат объекта (если конструктор не возвращает свой объект)
    return result instanceof Object ? result : obj;
}

// Использование
function User(name, age) {
    this.name = name;
    this.age = age;
}

const user = myNew(User, 'Alice', 25);
console.log(user.name); // Alice
```

---

#### **3.5. Особенности использования `new`**

**1. Возврат значения из конструктора**

-   Если конструктор явно возвращает объект, он будет использован вместо созданного объекта.

**Пример:**

```javascript
function User(name) {
    this.name = name;
    return { custom: 'object' }; // Возвращается этот объект
}

const user = new User('Alice');
console.log(user); // { custom: "object" }
```

-   Если возвращается примитивное значение, оно игнорируется, и возвращается новый объект:

```js
class User {
    constructor(name) {
        this.name = name;
        return 42; // Игнорируется
    }
}
const user3 = new User('Charlie');
console.log(user3); // User { name: 'Charlie' }
```

**2. Вызов без `new`**

Если функция-конструктор вызывается без `new`, `this` будет ссылаться на глобальный объект (в браузере — `window`), что может привести к ошибкам.

**Пример:**

```javascript
function User(name) {
    this.name = name;
}

const user = User('Alice'); // Без new
console.log(user); // undefined
console.log(window.name); // Alice (в браузере)
```

---

#### **3.6. Примеры использования**

**1. Создание инстанса с методами**

```javascript
class Car {
    constructor(brand, model) {
        this.brand = brand;
        this.model = model;
    }
    drive() {
        console.log(`Driving ${this.brand} ${this.model}`);
    }
}

const car = new Car('Toyota', 'Corolla');
car.drive(); // Driving Toyota Corolla
```

**2. Наследование с `new`**

```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }
    speak() {
        console.log(`${this.name} makes a noise.`);
    }
}

class Dog extends Animal {
    speak() {
        console.log(`${this.name} barks.`);
    }
}

const dog = new Dog('Rex');
dog.speak(); // Rex barks.
```

### **4. Ограничения функций-конструкторов**

-   **Сложность с наследованием**: Наследование через прототипы может быть сложным для понимания.
-   **Отсутствие приватных свойств**: Все свойства и методы, добавленные через `this`, являются публичными.
-   **Путаница с `this`**: Если функция-конструктор вызывается без `new`, `this` будет ссылаться на глобальный объект (в нестрогом режиме) или `undefined` (в строгом режиме).

---

### **5. Классы (ES6)**

С появлением классов в ES6 функции-конструкторы стали менее популярными, так как классы предоставляют более удобный и понятный синтаксис для создания объектов и работы с наследованием.

**Пример с классом:**

```javascript
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    greet() {
        console.log(`Привет, меня зовут ${this.name}, мне ${this.age} лет.`);
    }
}

const person1 = new Person('Алексей', 30);
person1.greet(); // Привет, меня зовут Алексей, мне 30 лет.
```

---

### **Итог**

-   **Функции-конструкторы** — это функции, которые используются с оператором `new` для создания объектов.
-   Они позволяют добавлять свойства и методы через `this` и прототипы.
-   Наследование реализуется через прототипы.
-   С появлением классов в ES6 функции-конструкторы стали менее популярными, но они всё ещё важны для понимания основ JavaScript.

**Пример функции-конструктора:**

```javascript
function Car(brand, model) {
    this.brand = brand;
    this.model = model;
}

Car.prototype.displayInfo = function () {
    console.log(`Марка: ${this.brand}, Модель: ${this.model}`);
};

const car1 = new Car('Toyota', 'Corolla');
car1.displayInfo(); // Марка: Toyota, Модель: Corolla
```

---

## |4| **Классы**

Классы в JavaScript — это синтаксический сахар над прототипным наследованием. Они предоставляют более удобный и понятный способ создания объектов с общими свойствами и методами. Классы были введены в стандарте ECMAScript 2015 (ES6) и стали популярным инструментом для организации кода в стиле объектно-ориентированного программирования (ООП).

---

### **1. Синтаксис классов**

Класс объявляется с помощью ключевого слова `class`. Внутри класса можно определить:

-   **Конструктор** (`constructor`) — метод, который вызывается при создании нового объекта.
-   **Методы** — функции, которые будут доступны объектам класса.
-   **Статические методы** — методы, которые принадлежат самому классу, а не его экземплярам.

**Пример:**

```javascript
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    greet() {
        console.log(`Hello, my name is ${this.name}`);
    }
}

const alice = new Person('Alice', 25);
alice.greet(); // Hello, my name is Alice
```

#### **1.1. Почему классы синтаксический сахар?**

1. **Упрощает работу с прототипами**:

    - Без классов разработчикам приходилось вручную управлять прототипами и конструкторами.
    - Классы делают это автоматически и более интуитивно.

2. **Добавляет ясность**:

    - Синтаксис классов более знаком тем, кто работает с ООП-языками (например, Java, C++, Python).
    - Это улучшает читаемость и поддерживаемость кода.

3. **Не добавляет новых возможностей**:

    - Классы — это просто другой способ работы с тем же прототипным механизмом.
    - Всё, что можно сделать с классами, можно было бы реализовать и через прототипы.

#### **1.2. Особенности классов как синтаксического сахара**

1. **Методы классов добавляются в прототип**:

    ```javascript
    class Example {
        method() {}
    }

    console.log(Example.prototype.method); // Функция
    ```

    Методы не копируются в каждый экземпляр объекта, а хранятся в прототипе.

2. **Классы имеют строгий режим**:

    - Весь код внутри классов работает в **strict mode** автоматически.

3. **Классы не поднимаются (hoisting)**:

    - В отличие от функций, классы нельзя использовать до их объявления.

    ```javascript
    const obj = new MyClass(); // Ошибка: Cannot access 'MyClass' before initialization
    class MyClass {}
    ```

4. **Синтаксис для наследования**:

    - Наследование через `extends` и вызов родительского конструктора с `super` — это удобный сахар для прототипного наследования.

    ```javascript
    class Animal {
        constructor(name) {
            this.name = name;
        }

        speak() {
            console.log(`${this.name} издаёт звук.`);
        }
    }

    class Dog extends Animal {
        speak() {
            console.log(`${this.name} гавкает.`);
        }
    }

    const dog = new Dog('Рекс');
    dog.speak(); // Рекс гавкает.
    ```

    Под капотом это также реализуется через прототипы.

#### **1.3. Преимущества синтаксического сахара классов**

-   Читаемый и лаконичный код.
-   Легче понять разработчикам, знакомым с ООП.
-   Упрощает наследование и работу с прототипами.

---

#### **1.4. Недостатки классов**

1. **Скрытая реализация**:

    - Новички могут думать, что JavaScript полностью перешёл на классическую модель ООП, хотя он остаётся прототипным языком.

2. **Меньшая гибкость**:

    - Прототипная модель в чистом виде иногда позволяет более динамичные подходы, которые в классах не так очевидны.

---

### **2. Основные компоненты классов**

В JavaScript свойства в классах можно объявлять несколькими способами, в зависимости от того, где они находятся:

1. **Через `this` в конструкторе**
2. **Свойства экземпляра в теле класса**
3. **Статические свойства**
4. **Приватные свойства**
5. **Свойства-аксессоры (`getter` и `setter`)**

#### **2.1. Объявление свойств через `this` в конструкторе**

Традиционный способ объявления свойств – это определение их в конструкторе с помощью `this`.

**Пример**

```javascript
class User {
    constructor(name, age) {
        this.name = name; // Обычное свойство
        this.age = age; // Обычное свойство
    }
}

const user1 = new User('Alice', 25);
console.log(user1.name); // "Alice"
console.log(user1.age); // 25
```

**Особенности**:

-   **Наследование** - Такие свойства принадлежат каждому экземпляру класса.
-   **Изменяемость** - Их можно свободно изменять.
-   **Гибкость** – можно передавать динамические данные при создании объекта.
-   **Удобно, когда свойства обязательны** – можно требовать их при создании экземпляра.
-   **Больше кода** – требуется писать конструктор и явно инициализировать свойства.

---

#### **2.2. Объявление свойств в теле класса**

Начиная с ES2020, можно объявлять свойства прямо в теле класса, без конструктора.

**Пример**

```javascript
class User {
    name = 'Unknown'; // Свойство экземпляра со значением по умолчанию
    age = 18; // Свойство экземпляра

    constructor(name, age) {
        if (name) this.name = name;
        if (age) this.age = age;
    }
}

const user1 = new User();
console.log(user1.name); // "Unknown"
console.log(user1.age); // 18
```

**Особенности**:

-   **Проще и компактнее** – не нужно объявлять конструктор, если не требуется дополнительная логика.
-   **Свойства создаются раньше конструктора** – удобнее, если есть значения по умолчанию.
-   **Лучшая читаемость** – сразу видно, какие свойства есть у экземпляра.
-   **Нельзя динамически устанавливать значения при создании объекта** – свойства будут всегда иметь значение по умолчанию, пока не изменятся вручную.

---

#### **2.3. Статические свойства (`static`)**

Статические свойства принадлежат **самому классу**, а не его экземплярам.

**Пример**

```javascript
class User {
    static role = 'user'; // Статическое свойство

    constructor(name) {
        this.name = name;
    }
}

console.log(User.role); // "user"

const user1 = new User('Alice');
console.log(user1.role); // undefined (у экземпляра нет доступа к статическим свойствам)
```

**Особенности**:

-   Доступны только у класса (`User.role`), но не у его экземпляров (`user1.role`).
-   Можно использовать, например, для хранения констант.

---

#### **2.4. Приватные свойства (`#`)**

Приватные свойства доступны **только внутри класса**. Они начинаются с `#`.

**Пример**

```javascript
class BankAccount {
    #balance = 0; // Приватное свойство

    constructor(initialBalance) {
        if (initialBalance >= 0) this.#balance = initialBalance;
    }

    getBalance() {
        return this.#balance;
    }
}

const account = new BankAccount(100);
console.log(account.getBalance()); // 100
console.log(account.#balance); // ❌ Ошибка: нельзя обратиться к приватному свойству
```

**Особенности**:

-   Нельзя обратиться извне (`account.#balance`).
-   Используется для скрытия данных.

---

#### **2.5. Свойства-аксессоры (`getter` и `setter`)**

Позволяют контролировать доступ к свойствам.

**Пример**

```javascript
class User {
    constructor(name) {
        this._name = name;
    }

    get name() {
        return this._name.toUpperCase();
    }

    set name(newName) {
        if (newName.length < 3) {
            console.log('Имя слишком короткое!');
            return;
        }
        this._name = newName;
    }
}

const user = new User('Alice');
console.log(user.name); // "ALICE"

user.name = 'Bo'; // "Имя слишком короткое!"
console.log(user.name); // "ALICE"
```

**Особенности**:

-   `get` – позволяет **читать** свойство как обычное.
-   `set` – позволяет **изменять** свойство с дополнительными проверками.

#### **2.6. Методы**

Методы — это функции, определённые внутри класса. Они доступны всем объектам, созданным на основе этого класса.

**Пример:**

```javascript
class Car {
    constructor(brand, model) {
        this.brand = brand;
        this.model = model;
    }

    drive() {
        console.log(`Driving ${this.brand} ${this.model}`);
    }
}

const toyota = new Car('Toyota', 'Corolla');
toyota.drive(); // Driving Toyota Corolla
```

#### **2.7. Метод конструктор (`constructor`)**

Конструктор — это специальный метод, который вызывается при создании нового объекта с помощью `new`. Он используется для инициализации свойств объекта.

**Пример:**

```javascript
class Car {
    constructor(brand, model) {
        this.brand = brand;
        this.model = model;
    }
}

const toyota = new Car('Toyota', 'Corolla');
console.log(toyota.brand); // Toyota
```

---

### **3. Наследование классов**

Наследование классов в JavaScript — это механизм, который позволяет одному классу (дочернему) наследовать свойства и методы другого класса (родительского). Это одна из ключевых концепций объектно-ориентированного программирования (ООП), которая помогает создавать иерархии классов, повторно использовать код и организовывать его структуру. В JavaScript наследование реализуется с помощью ключевого слова `extends`.

#### **3.1. Основы наследования**

Наследование позволяет дочернему классу использовать свойства и методы родительского класса, а также добавлять или переопределять их.

```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }

    speak() {
        console.log(`${this.name} makes a sound`);
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name); // Вызов конструктора родительского класса
        this.breed = breed;
    }

    bark() {
        console.log(`${this.name} barks!`);
    }
}

const dog = new Dog('Rex', 'German Shepherd');
dog.speak(); // Rex makes a sound (метод унаследован от Animal)
dog.bark(); // Rex barks! (метод класса Dog)
```

Что происходит в этом примере:

-   Класс `Dog` наследует от класса `Animal` с помощью `extends`.
-   Конструктор `Dog` вызывает конструктор `Animal` через `super(name)`.
-   Метод `speak` переопределен в классе `Dog`.

#### **3.2. Ключевое слово extends**

Ключевое слово `extends` используется для создания дочернего класса, который наследует свойства и методы родительского класса.

**Синтаксис:**

```js
class ChildClass extends ParentClass {
    // Тело класса
}
```

**Пример:**

```js
class Vehicle {
    constructor(wheels) {
        this.wheels = wheels;
    }

    drive() {
        console.log(`Едем на ${this.wheels} колесах.`);
    }
}

class Car extends Vehicle {
    constructor(wheels, brand) {
        super(wheels); // Вызов конструктора Vehicle
        this.brand = brand;
    }
}

const myCar = new Car(4, 'Toyota');
myCar.drive(); // "Едем на 4 колесах."
console.log(myCar.brand); // "Toyota"
```

#### **3.3. Ключевое слово `super`**

Ключевое слово `super` используется для вызова конструктора или методов родительского класса.

**Использование super в конструкторе:**

В дочернем классе конструктор должен вызвать `super()` до использования `this`.

`super()` вызывает конструктор родительского класса.

**Пример:**

```js
class Animal {
    constructor(name) {
        this.name = name;
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name); // Вызов конструктора Animal
        this.breed = breed;
    }
}
```

**Использование super в методах:**

`super.methodName()` позволяет вызвать метод родительского класса.

**Пример:**

```js
class Animal {
    speak() {
        console.log('Издает звук.');
    }
}

class Dog extends Animal {
    speak() {
        super.speak(); // Вызов метода speak из Animal
        console.log('Лает.');
    }
}

const myDog = new Dog();
myDog.speak();
// Вывод:
// "Издает звук."
// "Лает."
```

#### **3.4. Переопределение методов**

Дочерний класс может переопределить методы родительского класса. Это позволяет изменять или расширять поведение унаследованных методов.

**Пример:**

```javascript
class Cat extends Animal {
    speak() {
        console.log(`${this.name} meows`);
    }
}

const cat = new Cat('Whiskers');
cat.speak(); // Whiskers meows
```

#### **3.5. Наследование статических методов и свойств**

Статические методы и свойства также наследуются дочерними классами.

**Пример:**

```javascript
class MathUtils {
    static add(a, b) {
        return a + b;
    }
}

class AdvancedMath extends MathUtils {
    static multiply(a, b) {
        return a * b;
    }
}

console.log(AdvancedMath.add(2, 3)); // 5 (наследуется от MathUtils)
console.log(AdvancedMath.multiply(2, 3)); // 6 (новый статический метод)
```

#### **3.6. Цепочка прототипов**

Наследование в JavaScript основано на цепочке прототипов. Когда дочерний класс наследует от родительского, его прототип (`prototype`) ссылается на прототип родительского класса.

**Пример:**

```javascript
class Animal {}
class Dog extends Animal {}

console.log(Dog.prototype.__proto__ === Animal.prototype); // true
```

#### **3.7. Наследование от встроенных классов**

JavaScript позволяет наследовать от встроенных классов, таких как `Array`, `Error`, `Map` и других.

**Пример:**

```javascript
class MyArray extends Array {
    // Добавляем новый метод
    sum() {
        return this.reduce((acc, val) => acc + val, 0);
    }
}

const myArray = new MyArray(1, 2, 3);
console.log(myArray.sum()); // 6
```

#### **3.8. Примеры использования**

**Наследование и переопределение методов**

```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }

    speak() {
        console.log(`${this.name} makes a sound`);
    }
}

class Dog extends Animal {
    speak() {
        console.log(`${this.name} barks!`);
    }
}

const dog = new Dog('Rex');
dog.speak(); // Rex barks!
```

#### **3.9. Итог**

**1. Преимущества наследования**

1. **Повторное использование кода**: Наследование позволяет избежать дублирования кода.
2. **Иерархия классов**: Создание иерархий классов делает код более структурированным.
3. **Расширяемость**: Дочерние классы могут добавлять или изменять поведение родительских классов.

**2. Недостатки наследования**

1. **Жесткая связь**: Наследование создает тесную связь между классами, что может усложнить поддержку кода.
2. **Сложность иерархий**: Глубокие иерархии классов могут стать сложными для понимания.
3. **Ограниченная гибкость**: В некоторых случаях композиция (использование объектов внутри других объектов) может быть более гибкой, чем наследование.

**3. Альтернативы наследованию**

В некоторых случаях вместо наследования лучше использовать композицию или миксины.

**Пример композиции:**

```javascript
class Engine {
    start() {
        console.log('Двигатель запущен.');
    }
}

class Car {
    constructor() {
        this.engine = new Engine();
    }

    start() {
        this.engine.start();
        console.log('Машина завелась.');
    }
}

const myCar = new Car();
myCar.start();
// Вывод:
// "Двигатель запущен."
// "Машина завелась."
```

**Заключение**

Наследование классов в JavaScript — это мощный инструмент для создания иерархий классов и повторного использования кода. Оно реализуется с помощью ключевых слов `extends` и `super`. Однако важно помнить о потенциальных недостатках наследования, таких как жесткая связь и сложность иерархий. В некоторых случаях композиция или миксины могут быть более подходящими альтернативами.

Используйте наследование, когда оно действительно упрощает структуру кода, и не забывайте о других подходах, таких как композиция, для повышения гибкости и поддерживаемости вашего кода.

---

### **4. Статические методы**

Статические методы — это методы, которые принадлежат самому классу, а не его экземплярам. Они вызываются через класс, а не через объект, созданный на его основе. Статические методы используются для функциональности, которая не зависит от конкретного экземпляра объекта.

#### **4.1. Синтаксис статических методов**

Статические методы объявляются с помощью ключевого слова `static` внутри класса. Без этого ключевого слова метод будет считаться методом экземпляра и будет доступен только через объекты, созданные на основе класса.

**Пример:**

```javascript
class MyClass {
    // Статический метод
    static staticMethod() {
        console.log('Это статический метод');
    }

    // Метод экземпляра
    instanceMethod() {
        console.log('Это метод экземпляра');
    }
}

// Вызов статического метода
MyClass.staticMethod(); // "Это статический метод"

// Вызов метода экземпляра
const instance = new MyClass();
instance.instanceMethod(); // "Это метод экземпляра"
```

---

#### **4.2. Почему статические методы могут объявляться только с помощью static?**

Ключевое слово `static` явно указывает, что метод принадлежит классу, а не его экземплярам. Это важно для:

-   **Четкого разделения:** Методы экземпляра и статические методы имеют разные контексты и области применения. Ключевое слово `static` помогает явно указать, что метод относится к классу.
-   **Семантики:** Без `static` метод по умолчанию считается методом экземпляра, и его нельзя вызвать через класс.
-   **Совместимости с ООП:** В других языках программирования (например, Java, C++) статические методы также объявляются с помощью ключевого слова `static`. Это делает синтаксис JavaScript более универсальным и понятным для разработчиков.

---

#### **4.3. Особенности статических методов**

**1. Принадлежность классу**

Статические методы принадлежат классу, а не его экземплярам. Это означает, что они вызываются через имя класса, а не через объект.

**Пример:**

```javascript
class Person {
    static greet() {
        console.log('Hello!');
    }
}

Person.greet(); // Hello!

const person = new Person();
person.greet(); // Ошибка: person.greet is not a function
```

**2. Отсутствие доступа к `this`**

В статических методах `this` ссылается на сам класс, а не на экземпляр объекта. Поэтому статические методы не могут обращаться к свойствам или методам экземпляра.

**Пример:**

```javascript
class Person {
    constructor(name) {
        this.name = name;
    }

    static greet() {
        console.log(`Hello, ${this.name}`); // Ошибка: this.name — undefined
    }
}

Person.greet(); // Hello, undefined
```

**3. Использование для утилитарных функций**

Статические методы часто используются для функций, которые не требуют создания экземпляра объекта, например, для математических операций, работы с датами и т.д.

**Пример:**

```javascript
class DateUtils {
    static getCurrentDate() {
        return new Date().toISOString();
    }
}

console.log(DateUtils.getCurrentDate()); // 2023-10-05T12:34:56.789Z
```

**4. Динамическое добавление**

Статические методы можно добавить в класс после его создания, но это делается через прямое присваивание свойству класса. Однако такой подход не рекомендуется, так как он нарушает структуру класса и усложняет чтение кода.

**Пример:**

```js
class MyClass {}

// Добавление статического метода после создания класса
MyClass.staticMethod = function () {
    console.log('Это статический метод, добавленный позже');
};

MyClass.staticMethod(); // "Это статический метод, добавленный позже"
```

---

#### **4.3. Примеры использования**

**1. Создание фабричных методов**

Статические методы могут использоваться для создания объектов с определёнными параметрами.

**Пример:**

```javascript
class User {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    static createAdmin() {
        return new User('Admin', 30);
    }
}

const admin = User.createAdmin();
console.log(admin.name); // Admin
```

**2. Реализация синглтона**

Статические методы могут использоваться для реализации паттерна "синглтон" (одиночка), когда класс имеет только один экземпляр.

**Пример:**

```javascript
class Singleton {
    constructor() {
        if (Singleton.instance) {
            return Singleton.instance;
        }
        Singleton.instance = this;
    }

    static getInstance() {
        if (!Singleton.instance) {
            Singleton.instance = new Singleton();
        }
        return Singleton.instance;
    }
}

const instance1 = Singleton.getInstance();
const instance2 = Singleton.getInstance();

console.log(instance1 === instance2); // true
```

**3. Математические операции**

Статические методы удобны для реализации математических операций, которые не зависят от состояния объекта.

**Пример:**

```javascript
class MathUtils {
    static sum(a, b) {
        return a + b;
    }

    static multiply(a, b) {
        return a * b;
    }

    static square(x) {
        return x * x;
    }
}

console.log(MathUtils.sum(2, 3)); // 5
console.log(MathUtils.multiply(2, 3)); // 6
console.log(MathUtils.square(5)); // 25
```

---

#### **4.4. Статические методы и наследование**

Статические методы наследуются дочерними классами. Это означает, что дочерний класс может вызывать статические методы родительского класса.

**Пример:**

```javascript
class Animal {
    static describe() {
        console.log('This is an animal');
    }
}

class Dog extends Animal {}

Dog.describe(); // This is an animal
```

Так же дочерний класс может вызывать статические методы родительского класса с помощью `super`.

```js
class Parent {
    static staticMethod() {
        console.log('Статический метод родителя');
    }
}

class Child extends Parent {
    static childStaticMethod() {
        super.staticMethod(); // Вызов статического метода родителя
        console.log('Статический метод ребенка');
    }
}

Child.childStaticMethod();
// Вывод:
// "Статический метод родителя"
// "Статический метод ребенка"
```

---

#### **4.5. Имитация статических методов**

В JavaScript статические методы — это методы, которые принадлежат **классу**, а не его экземплярам. Однако, если мы говорим о литералах объекта или объектах, созданных через `Object()`, концепция статических методов напрямую не применима, так как эти объекты не являются классами. Тем не менее, мы можем имитировать поведение статических методов с помощью различных подходов.

1. **Литералы объекта и статические методы**

Литералы объекта — это простой способ создания объектов в JavaScript. Однако в литералах объекта нет понятия "статический метод", так как они не являются классами. Тем не менее, мы можем добавить методы, которые будут вести себя как статические, если они не зависят от состояния объекта.

**Пример:**

```javascript
const myObject = {
    // Обычный метод
    instanceMethod() {
        console.log('Это метод экземпляра');
    },

    // Метод, который ведет себя как статический
    staticMethod: function () {
        console.log('Это метод, похожий на статический');
    },
};

// Вызов обычного метода
myObject.instanceMethod(); // "Это метод экземпляра"

// Вызов метода, похожего на статический
myObject.staticMethod(); // "Это метод, похожий на статический"
```

В этом примере `staticMethod` не является статическим в классическом понимании, но он не зависит от состояния объекта и может быть вызван напрямую через объект.

---

2. **Объекты, созданные через `Object()`**

Объекты, созданные с помощью конструктора `Object()`, также не поддерживают статические методы, так как они не являются классами. Однако мы можем добавить методы, которые будут вести себя как статические.

**Пример:**

```javascript
const myObject = new Object();

// Добавляем обычный метод
myObject.instanceMethod = function () {
    console.log('Это метод экземпляра');
};

// Добавляем метод, похожий на статический
myObject.staticMethod = function () {
    console.log('Это метод, похожий на статический');
};

// Вызов обычного метода
myObject.instanceMethod(); // "Это метод экземпляра"

// Вызов метода, похожего на статический
myObject.staticMethod(); // "Это метод, похожий на статический"
```

---

3. **Имитация статических методов в объектах**

Если мы хотим имитировать статические методы в объектах, мы можем использовать следующие подходы:

a) **Добавление методов в прототип**

Мы можем добавить методы в прототип объекта, чтобы они были доступны всем экземплярам, но не зависели от состояния конкретного объекта.

```javascript
function MyObject() {
    // Конструктор
}

// Добавляем метод в прототип
MyObject.prototype.instanceMethod = function () {
    console.log('Это метод экземпляра');
};

// Добавляем метод, похожий на статический
MyObject.staticMethod = function () {
    console.log('Это метод, похожий на статический');
};

// Создаем экземпляр
const instance = new MyObject();

// Вызов обычного метода
instance.instanceMethod(); // "Это метод экземпляра"

// Вызов метода, похожего на статический
MyObject.staticMethod(); // "Это метод, похожий на статический"
```

b) **Использование модулей**

Мы можем использовать модули для создания функций, которые не зависят от состояния объекта и могут быть вызваны напрямую.

```javascript
// Модуль с методами
const MyModule = {
    staticMethod() {
        console.log('Это метод, похожий на статический');
    },
};

// Вызов метода
MyModule.staticMethod(); // "Это метод, похожий на статический"
```

c) **Использование фабрик объектов**

Фабрики объектов позволяют создавать объекты с методами, которые не зависят от состояния.

```javascript
function createObject() {
    return {
        instanceMethod() {
            console.log('Это метод экземпляра');
        },

        staticMethod: function () {
            console.log('Это метод, похожий на статический');
        },
    };
}

const obj = createObject();
obj.instanceMethod(); // "Это метод экземпляра"
obj.staticMethod(); // "Это метод, похожий на статический"
```

---

4. **Преимущества и недостатки имитации статических методов**

**Преимущества:**

-   **Гибкость**: Мы можем добавлять методы, которые не зависят от состояния объекта.
-   **Простота**: Подходы с использованием модулей или фабрик объектов просты в реализации.

**Недостатки:**

-   **Отсутствие строгой семантики**: Эти методы не являются статическими в классическом понимании.
-   **Ограниченная поддержка**: Некоторые подходы (например, добавление методов в прототип) могут быть менее удобными для использования.

---

#### **4.6. Итог**

**Преимущества статических методов**

-   **Удобство:** Статические методы вызываются напрямую через класс, без необходимости создавать экземпляр.

-   **Изоляция:** Они не зависят от состояния объекта, что делает их полезными для служебных функций.

-   **Производительность:** Поскольку статические методы не привязаны к экземплярам, они могут быть более эффективными в некоторых сценариях.

**Ограничения статических методов**

-   **Нет доступа к this:** В статических методах this ссылается на класс, а не на экземпляр. Поэтому они не могут обращаться к свойствам или методам экземпляра.

-   **Нельзя использовать в экземплярах:** Статические методы нельзя вызвать через объект, созданный на основе класса.

В JavaScript статические методы поддерживаются только в классах с помощью ключевого слова `static`. Однако в литералах объекта и объектах, созданных через `Object()`, мы можем имитировать статические методы, добавляя функции, которые не зависят от состояния объекта. Эти подходы обеспечивают гибкость, но не имеют строгой семантики статических методов, как в классах.

Если вам нужны настоящие статические методы, используйте классы. Если вы работаете с объектами, выбирайте подходы, такие как модули или фабрики объектов, чтобы имитировать статическое поведение.

---

### **5. Ключевое слово `super`**

Ключевое слово `super` в JavaScript используется для доступа к методам и свойствам родительского класса (или прототипа) из дочернего класса. Оно играет важную роль в объектно-ориентированном программировании (ООП) и особенно полезно при работе с наследованием. Давайте разберем, как работает `super`, его синтаксис, особенности и примеры использования.

#### 1. **Основное назначение `super`**

Ключевое слово `super` используется в двух контекстах:

1. **В конструкторе дочернего класса**: для вызова конструктора родительского класса.
2. **В методах дочернего класса**: для вызова методов родительского класса.

---

#### 2. **Использование `super` в конструкторе**

Когда вы создаете дочерний класс, который наследует от родительского класса, вам может понадобиться вызвать конструктор родительского класса, чтобы инициализировать унаследованные свойства. Для этого используется `super()`.

**Пример:**

```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name); // Вызов конструктора родительского класса
        this.breed = breed;
    }
}

const myDog = new Dog('Rex', 'German Shepherd');
console.log(myDog.name); // "Rex"
console.log(myDog.breed); // "German Shepherd"
```

**Особенности:**

-   **Обязательность вызова `super()`**: Если дочерний класс имеет собственный конструктор, то вызов `super()` обязателен до использования `this`. В противном случае будет ошибка.
-   **Порядок вызова**: `super()` должен быть вызван до обращения к `this`, так как `this` не будет доступен до инициализации родительского класса.

---

#### 3. **Использование `super` в методах**

Ключевое слово `super` также используется для вызова методов родительского класса из дочернего класса. Это полезно, когда вы хотите расширить или переопределить поведение родительского метода.

**Пример:**

```javascript
class Animal {
    speak() {
        console.log('Animal makes a sound');
    }
}

class Dog extends Animal {
    speak() {
        super.speak(); // Вызов метода родительского класса
        console.log('Dog barks');
    }
}

const myDog = new Dog();
myDog.speak();
// Вывод:
// "Animal makes a sound"
// "Dog barks"
```

**Особенности:**

-   **Доступ к методам родителя**: `super.methodName()` позволяет вызвать метод родительского класса, даже если он переопределен в дочернем классе.
-   **Расширение функциональности**: Вы можете добавить новую логику в дочерний метод, сохранив при этом поведение родительского метода.

---

#### 4. **Использование `super` в статических методах**

`super` также работает в статических методах, позволяя вызывать статические методы родительского класса.

**Пример:**

```javascript
class Animal {
    static info() {
        return 'This is an Animal class';
    }
}

class Dog extends Animal {
    static info() {
        return super.info() + ' extended by Dog class';
    }
}

console.log(Dog.info()); // "This is an Animal class extended by Dog class"
```

**Особенности:**

-   **Статический контекст**: В статических методах `super` ссылается на статические методы родительского класса, а не на его экземпляры.

---

#### 5. **Использование `super` с полями класса**

Начиная с ES2022, JavaScript поддерживает публичные и приватные поля класса. `super` можно использовать для доступа к полям родительского класса.

**Пример:**

```javascript
class Animal {
    name = 'Animal';
}

class Dog extends Animal {
    name = 'Dog';

    printNames() {
        console.log(super.name); // "Animal"
        console.log(this.name); // "Dog"
    }
}

const myDog = new Dog();
myDog.printNames();
```

**Особенности:**

-   **Доступ к полям родителя**: `super.fieldName` позволяет получить доступ к полям родительского класса.
-   **Переопределение полей**: Поля дочернего класса могут переопределять поля родительского класса.

---

#### 6. **Особенности работы `super`**

1. **Строгий режим**: `super` работает только в строгом режиме (`'use strict'`), который автоматически включается в классах и модулях.
2. **Ограничение на использование вне классов**: `super` можно использовать только внутри классов, которые наследуют другой класс.
3. **Ссылка на прототип**: `super` внутри методов ссылается на прототип родительского класса, а не на сам класс.

---

#### 7. **Примеры использования `super`**

**Пример 1: Расширение конструктора**

```javascript
class Vehicle {
    constructor(wheels) {
        this.wheels = wheels;
    }
}

class Car extends Vehicle {
    constructor(wheels, brand) {
        super(wheels); // Вызов конструктора Vehicle
        this.brand = brand;
    }
}

const myCar = new Car(4, 'Toyota');
console.log(myCar.wheels); // 4
console.log(myCar.brand); // "Toyota"
```

**Пример 2: Переопределение метода**

```javascript
class Bird {
    fly() {
        console.log('Bird is flying');
    }
}

class Penguin extends Bird {
    fly() {
        console.log('Penguin cannot fly');
    }

    tryToFly() {
        super.fly(); // Вызов метода fly из Bird
    }
}

const myPenguin = new Penguin();
myPenguin.tryToFly(); // "Bird is flying"
myPenguin.fly(); // "Penguin cannot fly"
```

**Пример 3: Использование в статических методах**

```javascript
class MathOperations {
    static add(a, b) {
        return a + b;
    }
}

class AdvancedMath extends MathOperations {
    static add(a, b) {
        return super.add(a, b) * 2; // Использование родительского метода
    }
}

console.log(AdvancedMath.add(2, 3)); // 10
```

---

#### 8. **Преимущества и недостатки `super`**

**Преимущества:**

-   **Упрощение наследования**: `super` делает наследование более удобным и читаемым.
-   **Доступ к родительским методам**: Позволяет использовать функциональность родительского класса без дублирования кода.
-   **Поддержка статических методов и полей**: `super` работает как в статических, так и в обычных методах.

---

#### **Заключение**

**Недостатки:**

-   **Ограниченный контекст**: `super` можно использовать только внутри классов.
-   **Обязательность вызова в конструкторе**: Если дочерний класс имеет конструктор, вызов `super()` обязателен.

Ключевое слово `super` — это мощный инструмент для работы с наследованием в JavaScript. Оно позволяет:

-   Вызывать конструктор родительского класса.
-   Обращаться к методам и свойствам родительского класса.
-   Расширять и переопределять поведение родительских методов.

Использование `super` делает код более структурированным и удобным для работы с иерархией классов. Однако важно помнить о его ограничениях, таких как обязательность вызова в конструкторе и работа только в контексте классов.

---

## |5| **Трейлингные (висящие) запятые в функциях и объектах.**

### **1. Что такое трейлингные запятые?**

Трейлингная (висящая) запятая — это запятая, которая ставится после последнего элемента в перечислении (массивы, объекты, параметры функций). Она не влияет на выполнение кода, но делает его более удобочитаемым и упрощает редактирование.

**Пример:**

```js
const obj = {
    name: 'Alice',
    age: 25,
}; // запятая после последнего свойства
```

### **2. Трейлингные запятые в объектах**

В объектах трейлингные запятые разрешены в списке свойств:

```js
const user = {
    name: 'Alice',
    age: 25,
    city: 'New York', // последняя запятая
};
console.log(user);
```

**Преимущества:**

-   Упрощает добавление новых свойств (не нужно править предыдущую строку).
-   Уменьшает вероятность ошибок при объединении кода.

### **3. Трейлингные запятые в массивах**

```js
const numbers = [
    1,
    2,
    3,
    4, // последняя запятая
];
console.log(numbers);
```

**Важно:** при итерации массива (`forEach`, `map`) лишний `undefined`-элемент не создаётся.

### **4. Трейлингные запятые в функциях**

В ES2017 (ES8) была добавлена поддержка трейлингных запятых в параметрах функций:

```plaintext
function greet(name, age,) {
    console.log(`Hello, ${name}. Age: ${age}`);
}
greet('Alice', 25);
```

Но в стрелочных функциях в **rest-параметрах** трейлингная запятая запрещена:

```plaintext
const sum = (...numbers,) => numbers.reduce((acc, num) => acc + num, 0); // Ошибка
```

### **5. Где трейлингные запятые запрещены?**

-   В JSON (он не поддерживает запятые после последнего элемента):
    ```json
    {
        "name": "Alice",
        "age": 25
    } // запятая после 25 вызовет ошибку
    ```
-   В параметрах стрелочных функций с `rest`-параметрами (см. выше).

### **Вывод**

Трейлингные запятые — это стиль кодирования, который делает код более удобочитаемым и удобным в редактировании. Они особенно полезны в больших объектах и массивах, упрощая их модификацию и сравнение изменений в системах контроля версий.

---

## |6| **Пользовательские ошибки.**

В JavaScript встроены стандартные ошибки, такие как `TypeError`, `SyntaxError`, `ReferenceError` и другие. Однако иногда нам нужно создавать собственные ошибки, чтобы более точно описывать исключительные ситуации в нашем коде.

### **1. Что такое пользовательская ошибка?**

Пользовательская ошибка — это ошибка, созданная разработчиком для обработки специфических ситуаций в коде. Она помогает лучше отлаживать программу и дает более понятные сообщения об ошибках.

#### **Пример стандартной ошибки и пользовательской ошибки**

Использование стандартной ошибки без пояснения:

```js
function divide(a, b) {
    if (b === 0) {
        throw new Error('Ошибка! Деление на ноль.');
    }
    return a / b;
}

console.log(divide(10, 0)); // Ошибка! Деление на ноль.
```

Создание пользовательского класса ошибки:

```js
class DivisionByZeroError extends Error {
    constructor() {
        super('Нельзя делить на ноль!');
        this.name = 'DivisionByZeroError';
    }
}

function divide(a, b) {
    if (b === 0) {
        throw new DivisionByZeroError();
    }
    return a / b;
}

console.log(divide(10, 0)); // Uncaught DivisionByZeroError: Нельзя делить на ноль!
```

Это делает код более читаемым и понятным.

---

### **2. Создание пользовательских ошибок**

В JavaScript можно создавать собственные ошибки с помощью `class MyError extends Error`.

Наши ошибки должны поддерживать базовые свойства, такие как `message`, `name` и, желательно, `stack`. Но также они могут иметь свои собственные свойства. Например, объекты `HttpError` могут иметь свойство `statusCode` со значениями `404`, `403` или `500`.

JavaScript позволяет вызывать `throw` с любыми аргументами, то есть технически наши классы ошибок не нуждаются в наследовании от `Error`. Но если использовать наследование, то появляется возможность идентификации объектов ошибок посредством `obj instanceof Error`. Так что лучше применять наследование.

По мере роста приложения, наши собственные ошибки образуют иерархию, например, `HttpTimeoutError` может наследовать от `HttpError` и так далее.

Класс `Error` встроенный, вот его примерный код, просто чтобы мы понимали, что расширяем:

```js
// "Псевдокод" встроенного класса Error, определённого самим JavaScript
class Error {
    constructor(message) {
        this.message = message;
        this.name = "Error"; // (разные имена для разных встроенных классов ошибок)
        this.stack = <стек вызовов>; // нестандартное свойство, но обычно поддерживается
    }
}
```

#### **Шаги для создания пользовательской ошибки:**

1. **Создаем класс ошибки**
2. **Расширяем (`extends`) класс `Error`**
3. **Определяем конструктор с нужными параметрами**
4. **Вызываем `super(message)`, передавая сообщение**
5. **Присваиваем `this.name` для удобства логирования**

#### **Пример: создание ошибки при недостатке средств на балансе**

```js
class InsufficientFundsError extends Error {
    constructor(balance, amount) {
        super(`Недостаточно средств: баланс ${balance}, требуется ${amount}`); // (1)
        this.name = 'InsufficientFundsError'; // (2)
        this.balance = balance;
        this.amount = amount;
    }
}

function withdraw(balance, amount) {
    if (amount > balance) {
        throw new InsufficientFundsError(balance, amount);
    }
    return balance - amount;
}

try {
    console.log(withdraw(100, 200)); // Ошибка
} catch (error) {
    console.error(error.name); // InsufficientFundsError
    console.error(error.message); // Недостаточно средств: баланс 100, требуется 200
}
```

Обратите внимание: в строке `(1)` вызываем родительский конструктор. JavaScript требует от нас вызова `super` в дочернем конструкторе, так что это обязательно. Родительский конструктор устанавливает свойство `message`.

Родительский конструктор также устанавливает свойство `name` для "`Error`", поэтому в строке `(2)` мы сбрасываем его на правильное значение.

---

### **3. Как правильно выбрасывать и обрабатывать пользовательские ошибки?**

При выбрасывании ошибок (`throw`) важно использовать `try...catch`, чтобы код не завершался аварийно.

#### **Пример: обработка ошибок**

```js
try {
    throw new Error('Это пользовательская ошибка!');
} catch (error) {
    console.log('Произошла ошибка:', error.message);
} finally {
    console.log('Этот код выполнится всегда!');
}
```

**`finally`** — полезен, если нужно выполнить очистку ресурсов, даже если возникла ошибка.

#### **Пример: практическое применение**

В качестве примера рассмотрим функцию `readUser(json)`, которая должна читать данные пользователя в формате `JSON`.

Пример того, как может выглядеть корректный json:

```js
let json = `{ "name": "John", "age": 30 }`;
```

Внутри будем использовать `JSON.parse`. При получении некорректного `json` он будет генерировать ошибку `SyntaxError`. Но даже если `json` синтаксически верен, то это не значит, что это будет корректный пользователь, верно? Могут быть пропущены необходимые данные. Например, могут отсутствовать свойства `name` и `age`, которые являются необходимыми для наших пользователей.

Наша функция `readUser(json)` будет не только читать JSON-данные, но и проверять их («валидировать»). Если необходимые поля отсутствуют или данные в неверном формате, то это будет ошибкой. Но не синтаксической ошибкой `SyntaxError`, потому что данные синтаксически корректны. Это будет другая ошибка.

Назовём её ошибкой валидации `ValidationError` и создадим для неё класс. Ошибка этого вида должна содержать информацию о поле, которое является источником ошибки.

```js
class ValidationError extends Error {
    constructor(message) {
        super(message);
        this.name = 'ValidationError';
    }
}

// Использование
function readUser(json) {
    let user = JSON.parse(json);

    if (!user.age) {
        throw new ValidationError('Нет поля: age');
    }
    if (!user.name) {
        throw new ValidationError('Нет поля: name');
    }

    return user;
}

// Рабочий пример с try..catch

try {
    let user = readUser('{ "age": 25 }');
} catch (err) {
    if (err instanceof ValidationError) {
        alert('Некорректные данные: ' + err.message); // Некорректные данные: Нет поля: name
    } else if (err instanceof SyntaxError) {
        // (*)
        alert('JSON Ошибка Синтаксиса: ' + err.message);
    } else {
        throw err; // неизвестная ошибка, пробросить исключение (**)
    }
}
```

Блок `try..catch` в коде выше обрабатывает и нашу `ValidationError`, и встроенную `SyntaxError` из `JSON.parse`.

Обратите внимание, как мы используем `instanceof` для проверки конкретного типа ошибки в строке `(*)`.

Мы можем также проверить тип, используя `err.name`:

```js
// ...
// вместо (err instanceof SyntaxError)
} else if (err.name == "SyntaxError") { // (*)
// ...
```

Версия с `instanceof` гораздо лучше, потому что в будущем мы собираемся расширить `ValidationError`, сделав его подтипы, такие как `PropertyRequiredError`. И проверка `instanceof` продолжит работать для новых наследованных классов. Так что это на будущее.

Также важно, что если `catch` встречает неизвестную ошибку, то он пробрасывает её в строке `(**)`. Блок `catch` знает, только как обрабатывать ошибки валидации и синтаксические ошибки, а другие виды ошибок (из-за опечаток в коде и другие непонятные) он должен выпустить наружу.

---

### **4. Добавление пользовательских полей в ошибки**

Можно добавлять собственные свойства, чтобы передавать дополнительную информацию.

#### **Пример: ошибка авторизации**

```js
class AuthError extends Error {
    constructor(username, message = 'Ошибка авторизации') {
        super(`${message}: ${username}`);
        this.name = 'AuthError';
        this.username = username;
        this.date = new Date();
    }
}

try {
    throw new AuthError('user123');
} catch (error) {
    console.log(error.name); // AuthError
    console.log(error.message); // Ошибка авторизации: user123
    console.log(error.username); // user123
    console.log(error.date); // Текущая дата
}
```

---

### **5. Наследование пользовательских ошибок**

Можно создавать иерархию пользовательских ошибок для разных ситуаций.

#### **Пример: иерархия ошибок**

```js
class AppError extends Error {
    constructor(message) {
        super(message);
        this.name = 'AppError';
    }
}

class DatabaseError extends AppError {
    constructor(query) {
        super(`Ошибка базы данных при запросе: ${query}`);
        this.name = 'DatabaseError';
        this.query = query;
    }
}

class NetworkError extends AppError {
    constructor(url) {
        super(`Ошибка сети при обращении к ${url}`);
        this.name = 'NetworkError';
        this.url = url;
    }
}

try {
    throw new DatabaseError('SELECT * FROM users');
} catch (error) {
    if (error instanceof DatabaseError) {
        console.error('Ошибка базы данных:', error.message);
    } else if (error instanceof NetworkError) {
        console.error('Ошибка сети:', error.message);
    } else {
        console.error('Неизвестная ошибка:', error.message);
    }
}
```

Такой подход помогает четко разделять типы ошибок.

#### **Пример: упрощение наследования**

Обратите внимание, что свойство `this.name` в конструкторе присвоено вручную. Правда, немного утомительно – присваивать `this.name = <class name>` в каждом классе пользовательской ошибки. Можно этого избежать, если сделать наш собственный «базовый» класс ошибки, который будет ставить `this.name = this.constructor.name`. И затем наследовать все ошибки уже от него.

Давайте назовём его `MyError`.

Вот упрощённый код с `MyError` и другими пользовательскими классами ошибок:

```js
class MyError extends Error {
    constructor(message) {
        super(message);
        this.name = this.constructor.name;
    }
}

class ValidationError extends MyError {}

class PropertyRequiredError extends ValidationError {
    constructor(property) {
        super('Нет свойства: ' + property);
        this.property = property;
    }
}

// name корректное
alert(new PropertyRequiredError('field').name); // PropertyRequiredError
```

Теперь пользовательские ошибки стали намного короче, особенно `ValidationError`, так как мы избавились от строки "`this.name = ...`" в конструкторе.

---

### **6. Обёртывание исключений**

Назначение функции `readUser` в приведённом выше коде – это «чтение данных пользователя». В процессе могут возникнуть различные виды ошибок. Сейчас у нас есть `SyntaxError` и `ValidationError`, но в будущем функция `readUser` может расшириться и, возможно, генерировать другие виды ошибок.

Код, который вызывает `readUser`, должен обрабатывать эти ошибки.

Сейчас в нём используются проверки `if` в блоке `catch`, которые проверяют класс и обрабатывают известные ошибки и пробрасывают дальше неизвестные. Но если функция `readUser` генерирует несколько видов ошибок, то мы должны спросить себя: действительно ли мы хотим проверять все типы ошибок поодиночке во всех местах в коде, где вызывается `readUser`?

Часто ответ «Нет»: внешний код хочет быть на один уровень выше всего этого. Он хочет иметь какую-то обобщённую ошибку чтения данных. Почему именно это произошло – часто не имеет значения (об этом говорится в сообщении об ошибке). Или даже лучше, если есть способ получить подробности об ошибке, но только если нам это нужно.

Итак, давайте создадим новый класс `ReadError` для представления таких ошибок. Если ошибка возникает внутри `readUser`, мы её перехватим и сгенерируем `ReadError`. Мы также сохраним ссылку на исходную ошибку в свойстве `cause`. Тогда внешний код должен будет только проверить наличие `ReadError`.

Этот код определяет ошибку `ReadError` и демонстрирует её использование в `readUser` и `try..catch`:

```js
class ReadError extends Error {
    constructor(message, cause) {
        super(message);
        this.cause = cause;
        this.name = 'ReadError';
    }
}

class ValidationError extends Error {
    /*...*/
}
class PropertyRequiredError extends ValidationError {
    /* ... */
}

function validateUser(user) {
    if (!user.age) {
        throw new PropertyRequiredError('age');
    }

    if (!user.name) {
        throw new PropertyRequiredError('name');
    }
}

function readUser(json) {
    let user;

    try {
        user = JSON.parse(json);
    } catch (err) {
        if (err instanceof SyntaxError) {
            throw new ReadError('Синтаксическая ошибка', err);
        } else {
            throw err;
        }
    }

    try {
        validateUser(user);
    } catch (err) {
        if (err instanceof ValidationError) {
            throw new ReadError('Ошибка валидации', err);
        } else {
            throw err;
        }
    }
}

try {
    readUser('{bad json}');
} catch (e) {
    if (e instanceof ReadError) {
        alert(e);
        // Исходная ошибка: SyntaxError:Unexpected token b in JSON at position 1
        alert('Исходная ошибка: ' + e.cause);
    } else {
        throw e;
    }
}
```

В приведённом выше коде `readUser` работает так, как описано – функция распознаёт синтаксические ошибки и ошибки валидации и выдаёт вместо них ошибки `ReadError` (неизвестные ошибки, как обычно, пробрасываются).

Внешний код проверяет только `instanceof ReadError`. Не нужно перечислять все возможные типы ошибок

Этот подход называется «обёртывание исключений», потому что мы берём «исключения низкого уровня» и «оборачиваем» их в `ReadError`, который является более абстрактным и более удобным для использования в вызывающем коде. Такой подход широко используется в объектно-ориентированном программировании.

---

### **7. Советы по работе с пользовательскими ошибками**

✅ **Используйте осмысленные названия классов ошибок**  
❌ `throw new Error("Что-то пошло не так");`  
✔️ `throw new ValidationError("Некорректный email");`

✅ **Добавляйте `this.name = "MyError"`** для удобного логирования.

✅ **Создавайте иерархию ошибок** для сложных приложений.

✅ **Добавляйте пользовательские свойства** (`statusCode`, `username`, `query`).

✅ **Используйте `instanceof`** для проверки типа ошибки.

---

### **Вывод**

Мы можем наследовать свои классы ошибок от `Error` и других встроенных классов ошибок, но нужно позаботиться о свойстве `name` и не забыть вызвать `super`.
Мы можем использовать `instanceof` для проверки типа ошибок. Это также работает с наследованием. Но иногда у нас объект ошибки, возникшей в сторонней библиотеке, и нет простого способа получить класс. Тогда для проверки типа ошибки можно использовать свойство `name`.
Обёртывание исключений является распространённой техникой: функция ловит низкоуровневые исключения и создаёт одно «высокоуровневое» исключение вместо разных низкоуровневых. Иногда низкоуровневые исключения становятся свойствами этого объекта, как `err.cause` в примерах выше, но это не обязательно.
Пользовательские ошибки помогают делать код более понятным, облегчая отладку и обработку исключений. Используйте их для обработки специфических ситуаций в вашем коде, создавайте иерархию ошибок и не забывайте обрабатывать их в `try...catch`.

---

## **Задачи**

### **Инстанс объекта**

1. Создайте объект `car` с полями `brand`, `model`, `year`. Создайте экземпляр объекта `car` с конкретными значениями и выведите его свойства в консоль.
2. Реализуйте функцию-конструктор `Person`, которая принимает `name` и `age`. Создайте несколько инстансов этого конструктора и проверьте их свойства.
3. Создайте объект с методом, который возвращает строку с информацией о нём. Вызовите метод для конкретного экземпляра объекта.
4. Используя `instanceof`, проверьте, что инстанс, созданный через функцию-конструктор, принадлежит соответствующему классу.
5. Создайте объект `book` с методами `setTitle` и `getTitle`. Создайте инстанс этого объекта и измените название книги через метод `setTitle`.
6. Создайте функцию-конструктор `Animal`, которая принимает параметры `name` и `species`. Добавьте метод `describe`, который выводит информацию о животном. Создайте инстансы и вызовите метод.
7. Напишите функцию-конструктор `Rectangle` для создания объекта прямоугольника с заданной длиной и шириной. Добавьте метод для расчёта площади.
8. Создайте объект `user` с методом `greet`. Используя `Object.create()`, создайте инстанс `admin`, который наследует свойства `user`.
9. Создайте функцию-конструктор с параметром по умолчанию. Проверьте, что инстанс создаётся корректно как с параметром, так и без него.
10. Создайте объект с вложенными свойствами. Скопируйте этот объект с помощью метода `Object.assign()` и проверьте изменения в копии.

---

### **Прототипы и наследование**

1. Создайте функцию-конструктор `Person` и добавьте метод `greet` в её прототип. Создайте несколько инстансов и вызовите этот метод.
2. Создайте прототип `Vehicle` с методом `start`. Создайте объект `car`, наследующий этот прототип, и вызовите метод `start`.
3. Реализуйте наследование с помощью `Object.create()`. Создайте объект `animal` с методом `speak`. Унаследуйте от него объект `dog`, добавив метод `bark`.
4. Добавьте метод в прототип объекта после создания инстанса и проверьте, что он доступен этому инстансу.
5. Создайте цепочку прототипов: объект `shape` с методом `getType`, объект `circle`, который наследует `shape`, и экземпляр `smallCircle`, который наследует `circle`.
6. Используя `isPrototypeOf`, проверьте, является ли один объект прототипом другого.
7. Создайте объект `parent` с методом `sayHello`. Унаследуйте объект `child` от `parent`, переопределив метод `sayHello`.
8. Реализуйте многоуровневое наследование: `Vehicle` → `Car` → `ElectricCar`. Убедитесь, что методы верхнего уровня доступны на нижнем.
9. Добавьте к прототипу встроенного объекта `Array` новый метод, который возвращает сумму всех элементов.
10. Напишите функцию, которая выводит всю цепочку прототипов объекта.

---

### **Функции-конструкторы**

1. **Создание простого объекта через функцию-конструктор**

Создайте функцию-конструктор `Person`, которая принимает два параметра: `name` и `age`. На основе этой функции создайте объект и выведите его свойства в консоль.

**Пример результата:**

```javascript
const person1 = new Person('Иван', 30);
console.log(person1.name); // "Иван"
console.log(person1.age); // 30
```

2. **Добавление метода в прототип**

Добавьте метод `greet` в прототип функции-конструктора `Person`, который выводит в консоль приветствие вида: `"Привет, меня зовут [name]!"`.

**Пример использования:**

```javascript
const person = new Person('Анна', 25);
person.greet(); // "Привет, меня зовут Анна!"
```

3. **Расширение функциональности**

Создайте функцию-конструктор `Rectangle`, которая принимает параметры `width` и `height`. Добавьте в прототип метод `getArea`, который вычисляет площадь прямоугольника.

**Пример использования:**

```javascript
const rect = new Rectangle(10, 5);
console.log(rect.getArea()); // 50
```

4. **Проверка свойства через `hasOwnProperty`**

Создайте объект через функцию-конструктор `Car` с параметрами `brand` и `model`. Проверьте, являются ли свойства `brand` и `model` собственными свойствами объекта.

**Пример результата:**

```javascript
const car = new Car('Toyota', 'Camry');
console.log(car.hasOwnProperty('brand')); // true
console.log(car.hasOwnProperty('toString')); // false
```

5. **Унаследование через прототипы**

Создайте функцию-конструктор `Animal` с методом `speak`, который выводит в консоль: `"Животное говорит"`. Создайте функцию-конструктор `Dog`, унаследуйте её от `Animal` и переопределите метод `speak` так, чтобы он выводил: `"Собака лает"`.

**Пример использования:**

```javascript
const dog = new Dog('Шарик');
dog.speak(); // "Собака лает"
```

6. **Создание статического метода**

Добавьте статический метод `createRandom` к функции-конструктору `User`, который создает объект `User` с произвольным именем и возрастом.

**Пример использования:**

```javascript
const randomUser = User.createRandom();
console.log(randomUser); // { name: 'СлучайноеИмя', age: 25 }
```

7. **Использование свойства `instanceof`**

Создайте два конструктора: `Circle` и `Square`. Создайте объекты через эти конструкторы и проверьте с помощью оператора `instanceof`, к какому типу они принадлежат.

**Пример использования:**

```javascript
const circle = new Circle(5);
console.log(circle instanceof Circle); // true
console.log(circle instanceof Square); // false
```

8. **Использование `call` внутри конструктора**

Создайте функцию-конструктор `Employee`, которая принимает `name` и `position`. Создайте другой конструктор `Manager`, который вызывает `Employee` с помощью метода `call` и добавляет дополнительное свойство `team`.

**Пример использования:**

```javascript
const manager = new Manager('Алексей', 'Руководитель', 'Команда A');
console.log(manager);
// { name: 'Алексей', position: 'Руководитель', team: 'Команда A' }
```

9. **Создание фабричной функции**

Напишите функцию `createUser`, которая возвращает объект, созданный через функцию-конструктор `User`, с переданными параметрами `name` и `age`.

**Пример использования:**

```javascript
const user = createUser('Мария', 20);
console.log(user); // { name: 'Мария', age: 20 }
```

10. **Инициализация объекта с уникальным ID**

Создайте функцию-конструктор `Item`, которая автоматически присваивает каждому создаваемому объекту уникальный идентификатор `id`. Для этого используйте статическое свойство конструктора.

**Пример использования:**

```javascript
const item1 = new Item('Стол');
const item2 = new Item('Стул');
console.log(item1.id); // 1
console.log(item2.id); // 2
```

---

### **Классы**

1. Создайте класс `Person` с конструктором, принимающим `name` и `age`. Создайте экземпляр класса и выведите свойства в консоль.
2. Напишите класс `Rectangle` с методами для расчёта площади и периметра. Создайте несколько экземпляров с разными размерами.
3. Реализуйте класс `Animal` с методом `makeSound`. Унаследуйте от него класс `Dog`, добавив метод `bark`.
4. Напишите класс с приватным свойством (используя символ) и методом для его изменения.
5. Реализуйте статический метод в классе `MathUtils` для вычисления среднего арифметического массива чисел.
6. Напишите класс с методом-акцессором (`getter` и `setter`) для работы с приватным свойством.
7. Создайте класс с методом, который использует аргументы по умолчанию. Создайте несколько экземпляров и вызовите метод с разными параметрами.
8. Реализуйте наследование: создайте класс `Vehicle` с методом `start`, унаследуйте `Car`, добавив метод `drive`, и создайте инстанс `Car`.
9. Создайте класс с использованием полей класса для инициализации свойств (JavaScript 2022).
10. Реализуйте класс `Counter` с методом `increment` и статическим методом `reset`. Убедитесь, что статический метод недоступен для экземпляров.

---

### **Пользовательские ошибки**

1. **Простая пользовательская ошибка**  
   Создайте класс `CustomError`, который расширяет `Error`, и выбрасывайте ошибку с произвольным сообщением.

2. **Обработка пользовательской ошибки**  
   Создайте функцию, которая выбрасывает ошибку `ValidationError`, если переданное значение пустое (`""` или `null`). Оберните вызов функции в `try...catch` и обработайте ошибку.

3. **Ошибка при делении на ноль**  
   Создайте класс `DivisionByZeroError` и выбрасывайте ошибку при попытке деления на 0.

4. **Ошибка авторизации**  
   Создайте класс `AuthError`, который принимает `username` и выбрасывает ошибку, если имя пользователя отсутствует.

5. **Ошибка при недостатке средств**  
   Создайте класс `InsufficientFundsError`, который принимает текущий баланс и запрашиваемую сумму. Если сумма превышает баланс, выбрасывайте ошибку.

6. **Наследование пользовательских ошибок**  
   Создайте базовый класс `AppError`, а затем два класса: `NetworkError` и `DatabaseError`. Пусть они наследуются от `AppError` и добавляют свои параметры.

7. **Проверка типа ошибки**  
   Напишите код, в котором выбрасывается ошибка `NetworkError`. В `catch`-блоке используйте `instanceof`, чтобы различать `NetworkError` и другие ошибки.

8. **Ошибка некорректного формата JSON**  
   Создайте класс `JsonParseError`, который расширяет `Error`, и выбрасывайте ошибку, если строка JSON невалидна.

9. **Ошибка при неверном пароле**  
   Создайте класс `PasswordError`, который выбрасывает ошибку, если переданный пароль короче 8 символов.

10. **Логирование ошибок в файл**  
    Создайте класс `AppError` и функцию, которая обрабатывает ошибки, записывая их в `console.error` с указанием времени ошибки.

11. **Наследование от SyntaxError**
    Создайте класс `FormatError`, который наследует от встроенного класса `SyntaxError`.

    Класс должен поддерживать свойства `message`, `name` и `stack`.

    Пример использования:

    ```js
    let err = new FormatError('ошибка форматирования');

    alert(err.message); // ошибка форматирования
    alert(err.name); // FormatError
    alert(err.stack); // stack

    alert(err instanceof FormatError); // true
    alert(err instanceof SyntaxError); // true (потому что наследует от SyntaxError)
    ```

---
