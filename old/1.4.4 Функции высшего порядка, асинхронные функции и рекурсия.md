# **1.4.4. Функции высшего порядка, асинхронные функции и рекурсия**

> [Index](./0%20Index.md)
> || [1.4 Функции](./1.4%20Функции.md)

---

## |1| **Функции высшего порядка (Higher-Order Functions)**

Функции высшего порядка — это одна из ключевых концепций функционального программирования в JavaScript. Они позволяют писать более гибкий, модульный и выразительный код.

---

### 1. **Что такое функции высшего порядка?**

Функция высшего порядка — это функция, которая:

1. **Принимает другие функции как аргументы**.
2. **Возвращает функцию как результат**.

Функции высшего порядка позволяют абстрагировать действия и создавать более универсальный код.

---

### 2. **Примеры использования**

#### a) **Функция, принимающая другую функцию как аргумент**

Рассмотрим пример функции, которая принимает другую функцию и применяет её к каждому элементу массива.

```javascript
function applyToArray(arr, fn) {
    const result = [];
    for (let i = 0; i < arr.length; i++) {
        result.push(fn(arr[i]));
    }
    return result;
}

const numbers = [1, 2, 3, 4];
const doubled = applyToArray(numbers, function (x) {
    return x * 2;
});

console.log(doubled); // [2, 4, 6, 8]
```

Здесь:

-   `applyToArray` — это функция высшего порядка, которая принимает массив и функцию `fn`.
-   Функция `fn` применяется к каждому элементу массива.

---

#### b) **Функция, возвращающая другую функцию**

Рассмотрим пример функции, которая возвращает другую функцию.

```javascript
function createMultiplier(multiplier) {
    return function (x) {
        return x * multiplier;
    };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```

Здесь:

-   `createMultiplier` — это функция высшего порядка, которая возвращает новую функцию.
-   Возвращаемая функция "запоминает" значение `multiplier` благодаря замыканию.

---

### 3. **Методы массивов: `map`, `filter`, `reduce`**

Методы массивов `map`, `filter` и `reduce` — это встроенные функции высшего порядка в JavaScript. Они позволяют работать с массивами в функциональном стиле.

---

#### a) **Метод `map`**

Метод `map` применяет функцию к каждому элементу массива и возвращает новый массив с результатами.

**Пример:**

```javascript
const numbers = [1, 2, 3, 4];
const doubled = numbers.map(function (x) {
    return x * 2;
});

console.log(doubled); // [2, 4, 6, 8]
```

С использованием стрелочной функции:

```javascript
const doubled = numbers.map((x) => x * 2);
console.log(doubled); // [2, 4, 6, 8]
```

---

#### b) **Метод `filter`**

Метод `filter` создает новый массив, содержащий только те элементы, для которых переданная функция возвращает `true`.

**Пример:**

```javascript
const numbers = [1, 2, 3, 4];
const evenNumbers = numbers.filter(function (x) {
    return x % 2 === 0;
});

console.log(evenNumbers); // [2, 4]
```

С использованием стрелочной функции:

```javascript
const evenNumbers = numbers.filter((x) => x % 2 === 0);
console.log(evenNumbers); // [2, 4]
```

---

#### c) **Метод `reduce`**

Метод `reduce` применяет функцию к аккумулятору и каждому элементу массива, возвращая одно результирующее значение.

**Пример:**

```javascript
const numbers = [1, 2, 3, 4];
const sum = numbers.reduce(function (acc, x) {
    return acc + x;
}, 0);

console.log(sum); // 10
```

С использованием стрелочной функции:

```javascript
const sum = numbers.reduce((acc, x) => acc + x, 0);
console.log(sum); // 10
```

---

### 4. **Практическое применение функций высшего порядка**

#### a) **Обработка данных**

Функции высшего порядка часто используются для обработки данных, например, фильтрации, преобразования или агрегации.

**Пример:**

```javascript
const users = [
    { name: 'Алексей', age: 30 },
    { name: 'Мария', age: 25 },
    { name: 'Иван', age: 35 },
];

// Фильтрация пользователей старше 30 лет
const olderUsers = users.filter((user) => user.age > 30);
console.log(olderUsers); // [{ name: 'Иван', age: 35 }]

// Преобразование массива пользователей в массив имен
const userNames = users.map((user) => user.name);
console.log(userNames); // ['Алексей', 'Мария', 'Иван']

// Вычисление среднего возраста пользователей
const totalAge = users.reduce((acc, user) => acc + user.age, 0);
const averageAge = totalAge / users.length;
console.log(averageAge); // 30
```

---

#### b) **Создание универсальных функций**

Функции высшего порядка позволяют создавать универсальные функции, которые можно повторно использовать в разных контекстах.

**Пример:**

```javascript
function createLogger(prefix) {
    return function (message) {
        console.log(`[${prefix}] ${message}`);
    };
}

const infoLogger = createLogger('INFO');
const errorLogger = createLogger('ERROR');

infoLogger('Запуск приложения'); // [INFO] Запуск приложения
errorLogger('Ошибка загрузки'); // [ERROR] Ошибка загрузки
```

---

#### c) **Композиция функций**

Функции высшего порядка позволяют комбинировать функции для создания более сложной логики.

#### Пример:

```javascript
function compose(f, g) {
    return function (x) {
        return f(g(x));
    };
}

const addOne = (x) => x + 1;
const double = (x) => x * 2;

const addOneThenDouble = compose(double, addOne);
console.log(addOneThenDouble(5)); // 12
```

---

### 5. **Итог**

-   **Функции высшего порядка** — это функции, которые принимают другие функции как аргументы или возвращают функции.
-   Они позволяют писать более гибкий и модульный код.
-   Встроенные методы массивов (`map`, `filter`, `reduce`) — это примеры функций высшего порядка.
-   Функции высшего порядка широко используются для обработки данных, создания универсальных функций и композиции.

Примеры:

```javascript
// map
const numbers = [1, 2, 3, 4];
const doubled = numbers.map((x) => x * 2);

// filter
const evenNumbers = numbers.filter((x) => x % 2 === 0);

// reduce
const sum = numbers.reduce((acc, x) => acc + x, 0);

// Создание универсальной функции
function createMultiplier(multiplier) {
    return function (x) {
        return x * multiplier;
    };
}

const double = createMultiplier(2);
console.log(double(5)); // 10
```

---

## |2| **Асинхронность в JavaScript**

Асинхронность — это способ выполнения кода, при котором операции могут выполняться параллельно или в фоновом режиме, не блокируя основной поток выполнения. Это особенно важно в JavaScript, который является однопоточным языком, то есть может выполнять только одну операцию за раз. Асинхронность позволяет эффективно работать с задачами, которые требуют времени, такими как сетевые запросы, чтение файлов или таймеры.

---

### **Инструменты для работы с асинхронными операциями**

В JavaScript существует несколько инструментов для работы с асинхронными операциями. Вот основные из них:

#### 1. **Колбэки (Callbacks)**

-   Функции, которые передаются в качестве аргументов и вызываются после завершения асинхронной операции.
-   Пример: `setTimeout`, `fs.readFile` (в Node.js).

#### 2. **Промисы (Promises)**

-   Объекты, представляющие результат асинхронной операции, которая может завершиться успешно или с ошибкой.
-   Пример: `fetch`, `axios`.

#### 3. **Асинхронные функции и `async/await`**

-   Синтаксический сахар над промисами, который делает асинхронный код более читаемым и похожим на синхронный.
-   Пример: `async function`, `await`.

#### 4. **Генераторы (Generators)**

-   Функции, которые могут приостанавливать и возобновлять свое выполнение, что позволяет управлять асинхронным кодом.
-   Пример: `function*`, `yield`.

#### 5. **События (Events)**

-   Механизм, при котором код реагирует на события, такие как клики мыши, завершение загрузки данных и т.д.
-   Пример: `EventEmitter` (в Node.js), `addEventListener`.

#### 6. **Потоки (Streams)**

-   Используются для обработки данных по частям, что полезно при работе с большими объемами данных.
-   Пример: `ReadableStream`, `WritableStream`.

#### 7. **Web Workers**

-   Позволяют выполнять код в отдельном потоке, что полезно для выполнения тяжелых вычислений без блокировки основного потока.
-   Пример: `Worker`.

#### 8. **Асинхронные итераторы (Async Iterators)**

-   Позволяют работать с асинхронными источниками данных, такими как потоки или запросы к базе данных.
-   Пример: `for await...of`.

В этом документе мы рассмотрим некоторые из них

---

## |3| **Функции-колбэки (Callback Functions)**

Функции-колбэки — это одна из ключевых концепций в JavaScript. Они широко используются для обработки асинхронных операций, событий, а также в методах массивов и других встроенных функциях.

---

### 1. **Что такое колбэк?**

Колбэк (callback) — это функция, которая передается в качестве аргумента другой функции и вызывается внутри неё. Колбэки позволяют передавать логику или поведение в другую функцию, что делает код более гибким и модульным.

> [!TIP]
>
> Функция – это значение, представляющее «действие»
> Обычные значения, такие как строки или числа представляют собой данные.
>
> Функции, с другой стороны, можно воспринимать как действия.
>
> Мы можем передавать их из переменной в переменную и запускать, когда захотим.

---

### 2. **Пример простого колбэка**

Рассмотрим пример, где функция принимает колбэк и вызывает его.

```javascript
function greet(name, callback) {
    console.log(`Привет, ${name}!`);
    callback(); // Вызов колбэка
}

function sayGoodbye() {
    console.log('Пока!');
}

greet('Алексей', sayGoodbye);
// Вывод:
// Привет, Алексей!
// Пока!
```

Здесь:

-   Функция `greet` принимает два аргумента: `name` и `callback`.
-   После вывода приветствия вызывается колбэк `sayGoodbye`.

---

### 3. **Более сложный пример**

Давайте рассмотрим больше примеров передачи функции в виде значения и использования функциональных выражений.

Давайте напишем функцию `ask(question, yes, no)` с тремя параметрами:

-   `question` - Текст вопроса
-   `yes` - Функция, которая будет вызываться, если ответ будет «Yes»
-   `no` - Функция, которая будет вызываться, если ответ будет «No»

Наша функция должна задать вопрос `question` и, в зависимости от того, как ответит пользователь, вызвать `yes()` или `no()`:

```js
function ask(question, yes, no) {
    if (confirm(question)) yes();
    else no();
}

function showOk() {
    alert('Вы согласны.');
}

function showCancel() {
    alert('Вы отменили выполнение.');
}

// использование: функции showOk, showCancel передаются в качестве аргументов ask
ask('Вы согласны?', showOk, showCancel);
```

На практике подобные функции очень полезны. Основное отличие «реальной» функции `ask` от примера выше будет в том, что она использует более сложные способы взаимодействия с пользователем, чем простой вызов `confirm`. В браузерах такие функции обычно отображают красивые диалоговые окна. Но это уже другая история.

Аргументы `showOk` и `showCancel` функции `ask` называются **функциями-колбэками** или просто колбэками.

Ключевая идея в том, что мы передаём функцию и ожидаем, что она вызовется обратно (от англ. **«call back»** – обратный вызов) когда-нибудь позже, если это будет необходимо. В нашем случае, `showOk` становится колбэком для ответа `«yes»`, а `showCancel` – для ответа `«no»`.

Мы можем переписать этот пример значительно короче, используя **Function Expression**:

```js
function ask(question, yes, no) {
    if (confirm(question)) yes();
    else no();
}

ask(
    'Вы согласны?',
    function () {
        alert('Вы согласились.');
    },
    function () {
        alert('Вы отменили выполнение.');
    },
);
// С использованием стрелочных функций
ask(
    'Вы согласны?',
    () => alert('Вы согласились.'),
    () => alert('Вы отменили выполнение.'),
);
```

Здесь функции объявляются прямо внутри вызова `ask(...)`. У них нет имён, поэтому они называются анонимными. Такие функции недоступны снаружи `ask` (потому что они не присвоены переменным), но это как раз то, что нам нужно.

Подобный код, появившийся в нашем скрипте выглядит очень естественно, в духе JavaScript.

---

### 4. **Колбэки в асинхронных операциях**

Колбэки часто используются для обработки асинхронных операций, таких как:

-   Запросы к серверу (например, с помощью `fetch` или `XMLHttpRequest`).
-   Таймеры (`setTimeout`, `setInterval`).
-   Чтение файлов (в Node.js).

#### Пример с `setTimeout`:

```javascript
function doHomework(subject, callback) {
    console.log(`Я начинаю делать домашку по ${subject}.`);
    setTimeout(() => {
        console.log(`Я закончил делать домашку по ${subject}.`);
        callback(); // Вызов колбэка после завершения
    }, 2000); // Имитация асинхронной операции
}

function celebrate() {
    console.log('Ура! Я свободен!');
}

doHomework('математике', celebrate);
```

**Вывод:**

```
Я начинаю делать домашку по математике.
(через 2 секунды)
Я закончил делать домашку по математике.
Ура! Я свободен!
```

---

### 5. **Колбэки в методах массивов**

Колбэки часто используются в методах массивов, таких как `map`, `filter`, `reduce`, `forEach` и других.

#### Пример с `map`:

```javascript
const numbers = [1, 2, 3, 4];
const doubled = numbers.map(function (number) {
    return number * 2;
});

console.log(doubled); // [2, 4, 6, 8]
```

#### Пример с `filter`:

```javascript
const numbers = [1, 2, 3, 4];
const evenNumbers = numbers.filter(function (number) {
    return number % 2 === 0;
});

console.log(evenNumbers); // [2, 4]
```

---

### 6. **Ошибки и проблемы с колбэками**

#### a) **Callback Hell (Ад колбэков)**

Когда колбэки вложены друг в друга, код становится сложным для чтения и поддержки. Это называется "Callback Hell" или "Пирамида смерти".

**Пример:**

```javascript
doTask1(function (result1) {
    doTask2(result1, function (result2) {
        doTask3(result2, function (result3) {
            doTask4(result3, function (result4) {
                console.log('Все задачи выполнены!');
            });
        });
    });
});
```

#### b) **Решение проблемы**

Для решения проблемы Callback Hell можно использовать:

-   **Промисы (Promises)**.
-   **Async/Await** (синтаксический сахар над промисами).

---

### 7. **Колбэки и контекст `this`**

Если колбэк является методом объекта, важно учитывать контекст `this`. В обычных функциях `this` может потерять контекст, если колбэк вызывается не как метод объекта.

**Пример:**

```javascript
const obj = {
    name: 'Alice',
    greet: function () {
        console.log(`Привет, меня зовут ${this.name}`);
    },
};

setTimeout(obj.greet, 1000); // Привет, меня зовут undefined
```

**Решение:**

-   Использовать стрелочные функции (если подходит).
-   Использовать `bind` для привязки контекста.

```javascript
setTimeout(obj.greet.bind(obj), 1000); // Привет, меня зовут Alice
```

---

### 8. **Преимущества колбэков**

-   **Гибкость**: Колбэки позволяют передавать логику в другую функцию.
-   **Универсальность**: Колбэки используются в асинхронных операциях, обработчиках событий и методах массивов.
-   **Простота**: Колбэки легко понять и использовать в простых сценариях.

---

### 9. **Недостатки колбэков**

-   **Callback Hell**: Вложенные колбэки делают код сложным для чтения и поддержки.
-   **Ошибки**: Легко допустить ошибки, например, забыть вызвать колбэк или вызвать его дважды.
-   **Сложность отладки**: Асинхронные колбэки могут затруднить отладку.

---

### 10. **Альтернативы колбэкам**

Для упрощения работы с асинхронным кодом в современных приложениях используются:

-   **Промисы (Promises)**.
-   **Async/Await**.

#### Пример с промисами:

```javascript
function doHomework(subject) {
    return new Promise((resolve) => {
        console.log(`Я начинаю делать домашку по ${subject}.`);
        setTimeout(() => {
            console.log(`Я закончил делать домашку по ${subject}.`);
            resolve();
        }, 2000);
    });
}

doHomework('математике').then(() => {
    console.log('Ура! Я свободен!');
});
```

#### Пример с async/await:

```javascript
async function homework() {
    await doHomework('математике');
    console.log('Ура! Я свободен!');
}

homework();
```

---

### 11. **Итог**

-   **Колбэк** — это функция, передаваемая в качестве аргумента и вызываемая внутри другой функции.
-   Колбэки используются для обработки асинхронных операций, событий и в методах массивов.
-   Основная проблема колбэков — Callback Hell, которая решается с помощью промисов и async/await.
-   Колбэки остаются важной частью JavaScript, но в современных проектах их часто заменяют на более удобные альтернативы.

Примеры использования колбэков:

```javascript
// Асинхронный колбэк
setTimeout(() => {
    console.log('Прошло 1 секунда');
}, 1000);

// Колбэк в методе массива
const numbers = [1, 2, 3];
const doubled = numbers.map((num) => num * 2);

// Колбэк в обработчике событий
document.getElementById('myButton').addEventListener('click', function () {
    console.log('Кнопка нажата!');
});
```

---

## |4| **Рекурсия в JavaScript**

Рекурсия — это техника программирования, при которой функция вызывает саму себя для решения задачи. Это мощный инструмент, который часто используется для работы с рекурсивными структурами данных, такими как деревья, или для решения задач, которые можно разбить на более простые подзадачи. Давайте разберем эту тему подробно.

---

### 1. **Что такое рекурсия?**

Рекурсия — это процесс, при котором функция вызывает саму себя. Рекурсивная функция обычно состоит из двух частей:

1. **Базовый случай (Base Case)**: Условие, при котором функция завершает выполнение и возвращает результат.
2. **Рекурсивный случай (Recursive Case)**: Часть функции, где она вызывает саму себя с измененными аргументами.

Рекурсия позволяет решать задачи, которые можно разбить на более мелкие и похожие подзадачи.

---

### 2. **Примеры рекурсивных функций**

#### a) **Факториал числа**

Факториал числа `n` (обозначается как `n!`) — это произведение всех натуральных чисел от 1 до `n`. Например, `5! = 5 * 4 * 3 * 2 * 1 = 120`.

**Рекурсивная реализация:**

```javascript
function factorial(n) {
    // Базовый случай: факториал 0 или 1 равен 1
    if (n === 0 || n === 1) {
        return 1;
    }
    // Рекурсивный случай: n! = n * (n-1)!
    return n * factorial(n - 1);
}

console.log(factorial(5)); // 120
```

---

#### b) **Числа Фибоначчи**

Числа Фибоначчи — это последовательность, в которой каждое число равно сумме двух предыдущих: `0, 1, 1, 2, 3, 5, 8, 13, ...`

**Рекурсивная реализация:**

```javascript
function fibonacci(n) {
    // Базовый случай: первые два числа Фибоначчи
    if (n === 0) return 0;
    if (n === 1) return 1;
    // Рекурсивный случай: F(n) = F(n-1) + F(n-2)
    return fibonacci(n - 1) + fibonacci(n - 2);
}

console.log(fibonacci(6)); // 8
```

---

#### c) **Обход дерева**

Рекурсия часто используется для обхода древовидных структур данных, таких как DOM-дерево или JSON.

**Пример:**

```javascript
const tree = {
    value: 1,
    children: [
        {
            value: 2,
            children: [
                { value: 4, children: [] },
                { value: 5, children: [] },
            ],
        },
        {
            value: 3,
            children: [{ value: 6, children: [] }],
        },
    ],
};

function traverseTree(node) {
    console.log(node.value); // Выводим значение текущего узла
    // Рекурсивно обходим всех детей
    node.children.forEach((child) => traverseTree(child));
}

traverseTree(tree);
// Вывод:
// 1
// 2
// 4
// 5
// 3
// 6
```

---

### 3. **Сравнение рекурсии и итерации**

Рекурсия и итерация — это два подхода к решению задач, которые можно описать через повторяющиеся шаги. У каждого из них есть свои преимущества и недостатки.

#### a) **Рекурсия**

-   **Преимущества**:
    -   Код часто проще и читабельнее, особенно для задач, которые естественно рекурсивны (например, обход дерева).
    -   Позволяет легко разбивать задачи на подзадачи.
-   **Недостатки**:
    -   Может привести к переполнению стека вызовов (stack overflow) при глубокой рекурсии.
    -   Обычно менее эффективен по памяти и производительности по сравнению с итерацией.

#### b) **Итерация**

-   **Преимущества**:
    -   Обычно более эффективен по памяти и производительности.
    -   Не имеет риска переполнения стека.
-   **Недостатки**:
    -   Код может быть сложнее для задач, которые естественно рекурсивны.
    -   Требует явного управления состоянием (например, с помощью циклов и переменных).

---

#### c) **Пример сравнения: Факториал**

**Рекурсивная реализация:**

```javascript
function factorialRecursive(n) {
    if (n === 0 || n === 1) return 1;
    return n * factorialRecursive(n - 1);
}
```

**Итеративная реализация:**

```javascript
function factorialIterative(n) {
    let result = 1;
    for (let i = 2; i <= n; i++) {
        result *= i;
    }
    return result;
}
```

**Сравнение:**

-   Рекурсивная версия проще для понимания, но может вызвать переполнение стека при больших значениях `n`.
-   Итеративная версия более эффективна и безопасна для больших значений `n`.

---

### 4. **Хвостовая рекурсия (Tail Recursion)**

Хвостовая рекурсия — это особый вид рекурсии, при котором рекурсивный вызов является последней операцией в функции. Это означает, что функция возвращает результат рекурсивного вызова без выполнения каких-либо дополнительных вычислений. Хвостовая рекурсия важна, потому что она может быть оптимизирована компиляторами и интерпретаторами для предотвращения переполнения стека вызовов.

---

#### **Что такое хвостовая рекурсия?**

В хвостовой рекурсии рекурсивный вызов выполняется в "хвосте" функции, то есть это последнее действие перед возвратом результата. Это позволяет компилятору или интерпретатору оптимизировать выполнение, заменяя текущий стек вызовов новым, вместо добавления нового вызова в стек.

**Пример хвостовой рекурсии:**

```javascript
function factorialTailRecursive(n, acc = 1) {
    if (n === 0 || n === 1) return acc;
    return factorialTailRecursive(n - 1, n * acc);
}

console.log(factorialTailRecursive(5)); // 120
```

Здесь:

-   `acc` (аккумулятор) используется для хранения промежуточного результата.
-   Рекурсивный вызов `factorialTailRecursive(n - 1, n * acc)` является последней операцией в функции.

---

#### **Почему хвостовая рекурсия важна?**

a) **Оптимизация хвостовой рекурсии**
В некоторых языках программирования (например, Scheme, Haskell) хвостовая рекурсия оптимизируется компилятором. Это означает, что вместо создания нового кадра стека для каждого рекурсивного вызова, текущий кадр стека переиспользуется. Это предотвращает переполнение стека (stack overflow) и делает рекурсию более эффективной.

b) **JavaScript и хвостовая рекурсия**
В JavaScript поддержка оптимизации хвостовой рекурсии зависит от движка. Например:

-   В **Safari** (движок JavaScriptCore) оптимизация хвостовой рекурсии поддерживается.
-   В **Chrome** (движок V8) и **Firefox** (движок SpiderMonkey) такая оптимизация отсутствует (на момент 2023 года).

---

#### **Примеры хвостовой рекурсии**

##### a) **Факториал**

**Обычная рекурсия:**

```javascript
function factorial(n) {
    if (n === 0 || n === 1) return 1;
    return n * factorial(n - 1); // Не хвостовая рекурсия
}
```

**Хвостовая рекурсия:**

```javascript
function factorialTailRecursive(n, acc = 1) {
    if (n === 0 || n === 1) return acc;
    return factorialTailRecursive(n - 1, n * acc); // Хвостовая рекурсия
}
```

Здесь:

-   `acc` — аккумулятор, который хранит промежуточный результат.
-   Рекурсивный вызов является последней операцией.

---

##### b) **Сумма чисел от 1 до n**

**Обычная рекурсия:**

```javascript
function sum(n) {
    if (n === 1) return 1;
    return n + sum(n - 1); // Не хвостовая рекурсия
}
```

**Хвостовая рекурсия:**

```javascript
function sumTailRecursive(n, acc = 0) {
    if (n === 0) return acc;
    return sumTailRecursive(n - 1, acc + n); // Хвостовая рекурсия
}
```

---

##### c) **Числа Фибоначчи**

**Обычная рекурсия:**

```javascript
function fibonacci(n) {
    if (n === 0) return 0;
    if (n === 1) return 1;
    return fibonacci(n - 1) + fibonacci(n - 2); // Не хвостовая рекурсия
}
```

**Хвостовая рекурсия:**

```javascript
function fibonacciTailRecursive(n, a = 0, b = 1) {
    if (n === 0) return a;
    if (n === 1) return b;
    return fibonacciTailRecursive(n - 1, b, a + b); // Хвостовая рекурсия
}
```

Здесь:

-   `a` и `b` — аккумуляторы, которые хранят два предыдущих числа Фибоначчи.
-   Рекурсивный вызов является последней операцией.

---

#### **Преимущества хвостовой рекурсии**

1. **Экономия памяти**: Оптимизация хвостовой рекурсии позволяет избежать накопления кадров стека, что предотвращает переполнение стека.
2. **Улучшение производительности**: Переиспользование кадра стека делает выполнение более эффективным.
3. **Читаемость кода**: Хвостовая рекурсия часто делает код более понятным, так как аккумуляторы явно передаются между вызовами.

---

#### **Ограничения хвостовой рекурсии в JavaScript**

-   **Отсутствие поддержки в большинстве движков**: На момент 2023 года оптимизация хвостовой рекурсии поддерживается только в Safari (JavaScriptCore). В Chrome (V8) и Firefox (SpiderMonkey) такая оптимизация отсутствует.
-   **Необходимость явного использования аккумуляторов**: Хвостовая рекурсия требует явного управления состоянием через аккумуляторы, что может усложнить код.

---

#### **Как проверить поддержку хвостовой рекурсии?**

Вы можете проверить, поддерживает ли ваш движок оптимизацию хвостовой рекурсии, с помощью следующего кода:

```javascript
function testTailRecursion(n) {
    if (n === 0) return 'done';
    return testTailRecursion(n - 1);
}

try {
    console.log(testTailRecursion(100000)); // Большое число для проверки
} catch (e) {
    console.log('Хвостовая рекурсия не оптимизирована');
}
```

-   Если код выполняется без ошибок, хвостовая рекурсия оптимизирована.
-   Если возникает ошибка переполнения стека, оптимизация отсутствует.

---

#### **Итог**

-   **Хвостовая рекурсия** — это рекурсия, при которой рекурсивный вызов является последней операцией в функции.
-   Она может быть оптимизирована компиляторами для предотвращения переполнения стека.
-   В JavaScript поддержка хвостовой рекурсии зависит от движка (на момент 2023 года поддерживается только в Safari).
-   Хвостовая рекурсия полезна для написания эффективного и читаемого кода, но требует явного использования аккумуляторов.

Примеры:

```javascript
// Факториал с хвостовой рекурсией
function factorialTailRecursive(n, acc = 1) {
    if (n === 0 || n === 1) return acc;
    return factorialTailRecursive(n - 1, n * acc);
}

// Сумма чисел с хвостовой рекурсией
function sumTailRecursive(n, acc = 0) {
    if (n === 0) return acc;
    return sumTailRecursive(n - 1, acc + n);
}

// Числа Фибоначчи с хвостовой рекурсией
function fibonacciTailRecursive(n, a = 0, b = 1) {
    if (n === 0) return a;
    if (n === 1) return b;
    return fibonacciTailRecursive(n - 1, b, a + b);
}
```

---

### 5. **Итог**

-   **Рекурсия** — это техника, при которой функция вызывает саму себя для решения задачи.
-   Рекурсивная функция состоит из **базового случая** и **рекурсивного случая**.
-   Рекурсия полезна для задач, которые можно разбить на более мелкие подзадачи, таких как обход деревьев или вычисление факториала.
-   Рекурсия и итерация имеют свои преимущества и недостатки. Рекурсия часто проще для понимания, но может быть менее эффективной.
-   **Хвостовая рекурсия** — это оптимизированная форма рекурсии, которая может избежать переполнения стека.

Примеры:

```javascript
// Факториал
function factorial(n) {
    if (n === 0 || n === 1) return 1;
    return n * factorial(n - 1);
}

// Числа Фибоначчи
function fibonacci(n) {
    if (n === 0) return 0;
    if (n === 1) return 1;
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// Обход дерева
function traverseTree(node) {
    console.log(node.value);
    node.children.forEach((child) => traverseTree(child));
}
```

---

## |5| **Динамические функции**

Динамические функции в JavaScript — это функции, которые создаются во время выполнения программы, а не на этапе написания кода. Они могут быть полезны в различных сценариях, таких как динамическая генерация кода, метапрограммирование, или когда логика функции зависит от внешних данных. В JavaScript есть несколько способов создания динамических функций, и каждый из них имеет свои особенности, преимущества и недостатки.

### 1. **Создание через `new Function`**

Конструктор `new Function` позволяет создать функцию из строки. Это самый гибкий способ создания динамических функций, так как тело функции передается в виде строки.

**Синтаксис:**

```javascript
const func = new Function([arg1, arg2, ...], functionBody);
```

-   `arg1, arg2, ...` — имена аргументов функции (строки).
-   `functionBody` — тело функции в виде строки.

**Пример:**

```javascript
// Динамически создаем функцию
const sum = new Function('a', 'b', 'return a + b;');

console.log(sum(2, 3)); // 5
```

**Преимущества:**

-   **Максимальная гибкость**: Можно генерировать любую логику на основе строк.
-   **Динамическое создание**: Функция может быть создана на основе данных, полученных во время выполнения.

**Недостатки:**

-   **Потенциально небезопасно**: Если строка кода поступает из ненадежного источника, это может привести к уязвимостям (например, инъекциям кода).
-   **Сложность отладки**: Код, сгенерированный из строк, сложнее отлаживать.
-   **Производительность**: Функции, созданные через `new Function`, не оптимизируются движком JavaScript так же хорошо, как обычные функции.

---

### 2. **Создание через `eval`**

Функция `eval` выполняет строку как JavaScript-код. Ее можно использовать для создания функций, но это крайне не рекомендуется из-за серьезных проблем с безопасностью и производительностью.

**Пример:**

```javascript
const funcBody = 'console.log("Hello, world!");';
const func = eval(`(function() { ${funcBody} })`);

func(); // "Hello, world!"
```

**Преимущества:**

-   **Максимальная гибкость**: Можно выполнить любой код на основе строк.

**Недостатки:**

-   **Опасность**: `eval` выполняет любой переданный код, что делает его уязвимым для инъекций.
-   **Производительность**: Код, выполняемый через `eval`, не оптимизируется движком JavaScript.
-   **Сложность отладки**: Отладка такого кода сложна.

---

### 3. **Создание через шаблонные строки**

Шаблонные строки (**template literals**) позволяют встраивать выражения в строки. Их можно использовать для генерации кода функции, который затем выполняется через `new Function` или `eval`.

**Пример:**

```javascript
const operation = 'multiply';
const funcBody = `
    if (operation === 'add') {
        return a + b;
    } else if (operation === 'multiply') {
        return a * b;
    }
    return NaN;
`;

const func = new Function('a', 'b', 'operation', funcBody);

console.log(func(2, 3, 'add')); // 5
console.log(func(2, 3, operation)); // 6
console.log(func(2, 3, 'sum')); // NaN
```

**Преимущества:**

-   **Гибкость**: Можно генерировать сложную логику на основе шаблонов.
-   **Читаемость**: Шаблонные строки делают код более структурированным.

**Недостатки:**

-   **Опасность**: Если используется `eval`, сохраняются те же риски, что и с `new Function`.
-   **Сложность отладки**: Отладка сгенерированного кода может быть сложной.

---

### 4. **Создание через замыкания**

Замыкания позволяют создавать функции, которые "запоминают" контекст, в котором они были созданы. Это можно использовать для создания динамических функций, которые зависят от внешних данных.

**Пример:**

```javascript
function createMultiplier(factor) {
    return function (number) {
        return number * factor;
    };
}

const double = createMultiplier(2);
console.log(double(5)); // 10
```

**Преимущества:**

-   **Безопасность**: Нет риска инъекций, так как код не генерируется из строк.
-   **Простота**: Код остается понятным и структурированным.
-   **Производительность**: Функции, созданные через замыкания, оптимизируются движком JavaScript.

**Недостатки:**

-   **Ограниченная гибкость**: Логика функции должна быть заранее определена, хотя и может зависеть от параметров.

---

### 5. **Создание через объекты `Function` и `Proxy`**

Прокси (`Proxy`) позволяют перехватывать и изменять поведение объектов. Их можно использовать для создания динамических функций, которые изменяют свое поведение в зависимости от контекста.

**Пример:**

```javascript
const handler = {
    apply(target, thisArg, argumentsList) {
        const [a, b] = argumentsList;
        return a + b;
    },
};

const dynamicFunc = new Proxy(function () {}, handler);

console.log(dynamicFunc(2, 3)); // 5
```

**Преимущества:**

-   **Гибкость**: Можно динамически изменять поведение функций.
-   **Метапрограммирование**: Прокси позволяют реализовать сложные сценарии, такие как ленивая загрузка или валидация.

**Недостатки:**

-   **Сложность**: Код с прокси может стать сложным для понимания.
-   **Производительность**: Прокси добавляют накладные расходы на выполнение.

---

### 6. **Создание через `Function.prototype`**

Можно динамически добавлять методы в прототип функции, чтобы изменять ее поведение.

**Пример:**

```javascript
function dynamicFunc() {}

dynamicFunc.prototype.execute = function (a, b) {
    return a + b;
};

const instance = new dynamicFunc();
console.log(instance.execute(2, 3)); // 5
```

**Преимущества:**

-   **Гибкость**: Можно добавлять методы на лету.
-   **Простота**: Не требует использования сложных конструкций.

**Недостатки:**

-   **Ограниченная гибкость**: Логика функции должна быть заранее определена.

---

### Заключение

Динамические функции в JavaScript предоставляют мощный инструмент для создания гибкого и адаптивного кода. Однако выбор подхода зависит от конкретной задачи:

-   **`new Function`** и **`eval`** предоставляют максимальную гибкость, но могут быть небезопасными и сложными для отладки.
-   **Замыкания** — это безопасный и структурированный способ, но он ограничен в гибкости.
-   **Прокси** позволяют изменять поведение функций на лету, но добавляют накладные расходы.
-   **Шаблонные строки** делают код более читаемым, но также могут быть небезопасными при использовании `eval`.

Если важна безопасность и читаемость, лучше использовать замыкания. Если нужна максимальная гибкость, можно рассмотреть `new Function` или шаблоны, но с осторожностью.

---

## **Задачи**

### **Функции высшего порядка (Higher-Order Functions)**

#### **Задача 1. Использование `.map` для преобразования массива**

У вас есть массив чисел. Используя метод `.map`, создайте новый массив, в котором все числа увеличены на 10.

**Пример:**

```javascript
const numbers = [1, 2, 3, 4, 5];
const result = /* Ваш код */;
console.log(result); // [11, 12, 13, 14, 15]
```

---

#### **Задача 2. Фильтрация массива с помощью `.filter`**

Дан массив строк. Оставьте только те строки, длина которых больше 5 символов.

**Пример:**

```javascript
const words = ['apple', 'banana', 'kiwi', 'cherry', 'grape'];
const result = /* Ваш код */;
console.log(result); // ['banana', 'cherry']
```

---

#### **Задача 3. Подсчет суммы элементов с помощью `.reduce`**

Дан массив чисел. Используя метод `.reduce`, найдите сумму всех элементов массива.

**Пример:**

```javascript
const numbers = [10, 20, 30, 40];
const sum = /* Ваш код */;
console.log(sum); // 100
```

---

#### **Задача 4. Создание функции высшего порядка**

Напишите функцию `applyOperation`, которая принимает два аргумента: массив чисел и функцию-операцию (например, удвоение). Функция должна вернуть новый массив с применением переданной операции к каждому элементу.

**Пример:**

```javascript
function applyOperation(array, operation) {
    // Ваш код
}

const numbers = [1, 2, 3];
const result = applyOperation(numbers, (x) => x * 2);
console.log(result); // [2, 4, 6]
```

---

#### **Задача 5. Композиция функций**

Напишите две функции:

1. `add5`, которая прибавляет 5 к числу.
2. `multiplyBy3`, которая умножает число на 3.

Создайте функцию высшего порядка `compose`, которая принимает две функции и число. Она должна сначала применить одну функцию, а затем другую.

**Пример:**

```javascript
function add5(num) {
    return num + 5;
}

function multiplyBy3(num) {
    return num * 3;
}

function compose(func1, func2, num) {
    // Ваш код
}

const result = compose(add5, multiplyBy3, 2);
console.log(result); // 21 (2 + 5 = 7; 7 * 3 = 21)
```

---

#### **Задача 6. Сортировка строк**

Написать функцию, которая принимает массив строк и возвращает массив строк, отсортированных по длине.

**Пример:**

```javascript
const words = ['apple', 'banana', 'kiwi', 'cherry', 'grape'];
const result = /* Ваш код */;
console.log(result); // ['cherry', 'banana', 'grape', 'apple', 'kiwi']
```

---

### **Функции-колбэки (Callback Functions)**

#### **Задача 1. Асинхронный таймер**

Напишите функцию `delayedMessage`, которая принимает два аргумента: сообщение и время задержки в миллисекундах. После указанной задержки функция должна вывести сообщение в консоль. Используйте колбэк для выполнения действия после задержки.

**Пример:**

```javascript
function delayedMessage(message, delay) {
    // Ваш код
}

delayedMessage('Привет, мир!', 2000); // Выведет "Привет, мир!" через 2 секунды
```

---

#### **Задача 2. Колбэк в методе массива**

Дан массив чисел. Напишите функцию `filterEvenNumbers`, которая принимает массив и колбэк-функцию. Колбэк-функция должна возвращать `true` для четных чисел. Используйте метод `filter` для выполнения задачи.

**Пример:**

```javascript
function filterEvenNumbers(array, callback) {
    // Ваш код
}

const numbers = [1, 2, 3, 4, 5, 6];
const result = filterEvenNumbers(numbers, (num) => num % 2 === 0);
console.log(result); // [2, 4, 6]
```

---

#### **Задача 3. Работа с контекстом `this`**

Создайте объект `user` с методом `greet`, который принимает колбэк. Вызовите метод `greet`, передав в него колбэк-функцию, которая выведет сообщение с использованием имени пользователя из контекста `this`.

**Пример:**

```javascript
const user = {
    name: 'Алексей',
    greet(callback) {
        // Ваш код
    },
};

user.greet(function () {
    console.log(`Привет, ${this.name}!`);
});
// Вывод: Привет, Алексей!
```

---

#### **Задача 4. Колбэк и асинхронная операция**

Напишите функцию `loadData`, которая принимает URL и колбэк. Функция должна симулировать загрузку данных (например, с помощью `setTimeout`), а затем вызвать колбэк с "загруженными данными".

**Пример:**

```javascript
function loadData(url, callback) {
    // Ваш код
}

loadData('https://api.example.com/data', (data) => {
    console.log(`Данные загружены: ${data}`);
});
// Вывод через 1 секунду: Данные загружены: данные из https://api.example.com/data
```

---

#### **Задача 5. Условное выполнение колбэков**

Напишите функцию `executeIfTrue`, которая принимает условие (булевое значение), данные и два колбэка: `onTrue` и `onFalse`. Если условие истинно, вызывается `onTrue` с данными, иначе — `onFalse`.

**Пример:**

```javascript
function executeIfTrue(condition, data, onTrue, onFalse) {
    // Ваш код
}

executeIfTrue(
    true,
    'Всё работает!',
    (message) => console.log(`Успех: ${message}`),
    (message) => console.log(`Ошибка: ${message}`),
);
// Вывод: Успех: Всё работает!
```

---

### **Рекурсия в JavaScript**

#### **Задача 1. Сумма чисел до N**

Напишите рекурсивную функцию `sumTo(n)`, которая возвращает сумму всех чисел от 1 до `n`.

**Пример:**

```javascript
function sumTo(n) {
    // Ваш код
}

console.log(sumTo(5)); // 15 (1 + 2 + 3 + 4 + 5)
```

---

#### **Задача 2. Поиск максимального значения в массиве**

Напишите рекурсивную функцию `findMax(arr)`, которая находит максимальное значение в массиве.

**Пример:**

```javascript
function findMax(arr) {
    // Ваш код
}

console.log(findMax([1, 5, 2, 9, 3])); // 9
```

---

#### **Задача 3. Реверс строки**

Реализуйте рекурсивную функцию `reverseString(str)`, которая возвращает строку в обратном порядке.

**Пример:**

```javascript
function reverseString(str) {
    // Ваш код
}

console.log(reverseString('hello')); // "olleh"
```

---

#### **Задача 4. Проверка палиндрома**

Напишите рекурсивную функцию `isPalindrome(str)`, которая проверяет, является ли строка палиндромом (читается одинаково в обе стороны).

**Пример:**

```javascript
function isPalindrome(str) {
    // Ваш код
}

console.log(isPalindrome('racecar')); // true
console.log(isPalindrome('hello')); // false
```

---

#### **Задача 5. Углубленная сумма массива**

Напишите рекурсивную функцию `deepSum(arr)`, которая вычисляет сумму всех чисел в многомерном массиве.

**Пример:**

```javascript
function deepSum(arr) {
    // Ваш код
}

console.log(deepSum([1, [2, [3, 4]], 5])); // 15
```

---

#### **Задача 6. Хвостовая рекурсия для суммы**

Реализуйте функцию `sumTailRec(n, acc = 0)`, которая использует хвостовую рекурсию для вычисления суммы чисел от 1 до `n`.

**Пример:**

```javascript
function sumTailRec(n, acc = 0) {
    // Ваш код
}

console.log(sumTailRec(5)); // 15
```

---

#### **Задача 7. Проверка на вложенность**

Создайте рекурсивную функцию `isNested(arr)`, которая проверяет, есть ли вложенные массивы внутри заданного массива.

**Пример:**

```javascript
function isNested(arr) {
    // Ваш код
}

console.log(isNested([1, 2, 3])); // false
console.log(isNested([1, [2, 3]])); // true
```

---

#### **Задача 8. Генерация последовательностей**

Напишите рекурсивную функцию `generateSequence(n, start = 1)`, которая возвращает массив чисел от `start` до `n`.

**Пример:**

```javascript
function generateSequence(n, start = 1) {
    // Ваш код
}

console.log(generateSequence(5)); // [1, 2, 3, 4, 5]
```

---
