# **2.2.1 Основы работы с объектами**

> [Index](./0%20Index.md)
> || [2.2 Объекты](./2.2%20Объекты.md)

---

## |1| **Введение в объекты**

### 1. **Что такое объект? Определение и свойства**

Объект в JavaScript — это составной тип данных, который используется для хранения коллекции пар **ключ-значение**. Ключи (свойства или методы) объекта — это строки (или символы), а значения могут быть любого типа: числа, строки, массивы, другие объекты, функции и т.д.

**Пример:**

```javascript
const user = {
    name: 'Alice',
    age: 25,
    isAdmin: false,
};
```

Здесь:

-   `name`, `age`, `isAdmin` — ключи (свойства).
-   `"Alice"`, `25`, `false` — значения.

---

### 2. **Сравнение с массивами: ключи и индексы**

-   **Массивы** используют числовые индексы для доступа к элементам.
-   **Объекты** используют строковые ключи (или символы) для доступа к значениям.

**Пример:**

```javascript
const arr = ['Alice', 25, false]; // Массив
const obj = { name: 'Alice', age: 25, isAdmin: false }; // Объект

console.log(arr[0]); // "Alice" (доступ по индексу)
console.log(obj.name); // "Alice" (доступ по ключу)
```

---

### 3. **Создание через литерал объекта: `{ key: value }`**

Литерал объекта — это самый простой и распространённый способ создания объектов в JavaScript. Он позволяет быстро и удобно создавать объекты с набором свойств и методов. Литерал объекта представляет собой пары **ключ-значение**, заключённые в фигурные скобки `{}`.

Литерал объекта `{}` был частью языка с момента его создания. JavaScript был разработан Бренданом Айком в 1995 году, и литерал объекта был одним из базовых синтаксических элементов.

**Особенности:**

-   Литерал объекта — это самый простой и удобный способ создания объекта.
-   Он позволяет сразу определить свойства и методы объекта.
-   Литерал объекта всегда создаёт экземпляр объекта с прототипом Object.prototype.
-

#### **Синтаксис литерала объекта**

Литерал объекта записывается в виде:

```javascript
const obj = {
  key1: value1,
  key2: value2,
  ...
};
```

-   **Ключи (имена свойств)**: Могут быть строками или символами. Если ключ не является **допустимым идентификатором** имя свойства необходимо взять в кавычки.
-   **Значения**: Могут быть любого типа: числа, строки, массивы, другие объекты, функции и т.д.

> [!NOTE]
>
> 1. **Что такое допустимый идентификатор?**
>    Допустимый идентификатор — это имя, которое соответствует правилам именования переменных в JavaScript. Оно должно удовлетворять следующим условиям:
>
> -   Состоит из букв, цифр, символов `_` (подчёркивание) и `$` (доллар).
>     **Примеры:** `name`, `age`, `_private`, `$element`.
> -   Не начинается с цифры.
>     **Пример:** `1key` — недопустимый идентификатор.
> -   Не содержит пробелов или специальных символов (кроме `_` и `$`).
>     **Пример:** `full name` — недопустимый идентификатор.
> -   Не является зарезервированным словом (например, `class`, `function`, `return` и т.д.).
>     **Пример:** `class` — недопустимый идентификатор.
>
> 2. **Примеры допустимых и недопустимых идентификаторов**
>    Допустимые идентификаторы
>
> ```js
> const obj = {
>     name: 'Alice', // Допустимо
>     age: 25, // Допустимо
>     _private: true, // Допустимо
>     $element: 'div', // Допустимо
>     firstName: 'Alice', // Допустимо
> };
> ```
>
> Недопустимые идентификаторы
>
> ```plaintext
> const obj = {
>     'full name': 'Alice Smith', // Недопустимо без кавычек (пробел)
>     '1key': 'value', // Недопустимо без кавычек (начинается с цифры)
>     'class': 'JavaScript', // Недопустимо без кавычек (зарезервированное слово)
> };
> ```

---

#### **Примеры создания объектов**

##### **1. Простой объект**

```javascript
const user = {
    name: 'Alice',
    age: 25,
    isAdmin: false,
};
console.log(user); // { name: "Alice", age: 25, isAdmin: false }
```

##### **2. Объект с методами**

Метод — это функция, которая является значением свойства объекта.

```javascript
const user = {
    name: 'Alice',
    greet: function () {
        console.log(`Hello, ${this.name}!`);
    },
};
user.greet(); // Hello, Alice!
```

##### **3. Объект с вложенными объектами**

Объекты могут содержать другие объекты.

```javascript
const user = {
    name: 'Alice',
    address: {
        city: 'New York',
        zip: '10001',
    },
};
console.log(user.address.city); // New York
```

---

#### **Особенности литерала объекта**

##### **1. Ключи без кавычек**

Если ключ является допустимым идентификатором (не содержит пробелов, не начинается с цифры и т.д.), кавычки можно опустить.

```javascript
const user = {
    name: 'Alice', // Ключ без кавычек
    'full name': 'Alice Smith', // Ключ с пробелом требует кавычек
};
```

##### **2. Динамические ключи**

Ключи могут быть вычисляемыми с помощью квадратных скобок `[]`.

```javascript
const key = 'name';
const user = {
    [key]: 'Alice', // Динамический ключ
};
console.log(user.name); // Alice
console.log(user[key]); // Alice
```

##### **3. Сокращённая запись свойств**

Если имя переменной совпадает с именем ключа, можно использовать сокращённую запись.

```javascript
const name = 'Alice';
const age = 25;
// const user = { name: name, age: age }; // Полная запись
const user = { name, age }; // Сокращённая запись
console.log(user); // { name: "Alice", age: 25 }
```

##### **4. Методы в сокращённой записи**

Методы также можно записывать в сокращённой форме.

```javascript
const user = {
    name: 'Alice',
    // greet: function () { // Полная запись
    greet() {
        console.log(`Hello, ${this.name}!`);
    },
};
user.greet(); // Hello, Alice!
```

---

### 4. **Создание через конструктор `Object`**

Конструктор `Object` — это встроенная функция в JavaScript, которая позволяет создавать объекты. Конструктор `Object()` также был частью языка с момента его создания. Он предоставляет альтернативный способ создания объектов, хотя используется реже, чем литерал объекта.

Хотя в большинстве случаев объекты создаются с помощью литерала `{}`, конструктор `Object` предоставляет дополнительные возможности и методы для работы с объектами. Литерал объекта `{}` подходит для создания объектов с фиксированной структурой, но он не позволяет создавать объект с определенным прототипом. При этом конструктор `Object` может быть полезен, если нужно создать объект с определённым прототипом или использовать статические методы `Object`, такие как `Object.create()`.

**Особенности:**

-   Конструктор `Object()` может быть вызван с ключевым словом `new` или без него.
-   Если передать литерал объекта в `Object()`, он просто вернёт этот объект.
-   Конструктор `Object()` полезен для создания объектов с определённым прототипом или использования статических методов, таких как `Object.create()`.

---

#### **4.1. Создание объектов с помощью `new Object()`**

Конструктор `Object` можно использовать для создания пустого объекта или объекта с определёнными свойствами.

##### **Создание пустого объекта**

```javascript
const obj = new Object();
console.log(obj); // {}
```

##### **Добавление свойств**

После создания объекта можно добавлять свойства с помощью точечной нотации или квадратных скобок.

```javascript
const user = new Object();
user.name = 'Alice';
user['age'] = 25;
console.log(user); // { name: "Alice", age: 25 }
```

---

#### **4.2. Создание объекта с начальными свойствами**

Конструктор `Object` также позволяет передавать начальные свойства в виде объекта.

```javascript
const user = new Object({
    name: 'Alice',
    age: 25,
});
console.log(user); // { name: "Alice", age: 25 }
```

> [!NOTE]
>
> Когда вы передаёте литерал объекта в `new Object()`, это эквивалентно созданию объекта через литерал. Однако это избыточно, так как литерал объекта уже создаёт объект.
> Здесь `new Object()` просто возвращает переданный литерал объекта. Это не добавляет никакой функциональности, но делает код менее читаемым.

---

#### **4.3. Статические методы конструктора `Object`**

Конструктор `Object` предоставляет множество статических методов для работы с объектами. Коротко перечислим основные из них, позже некоторые рассмотрим подробнее.

-   Метод `Object.assign()` копирует свойства из одного или нескольких объектов в целевой объект.
-   Метод `Object.create()` создаёт новый объект с указанным прототипом.
-   Метод `Object.defineProperty()` добавляет или изменяет свойство объекта с указанными дескрипторами.
-   Метод `Object.defineProperties()` позволяет определить несколько свойств сразу.
-   Методы `Object.keys()`, `Object.values()`, `Object.entries()` возвращают массивы ключей, значений или пар ключ-значение объекта.
-   Методы `Object.freeze()`, `Object.seal()`, `Object.preventExtensions()` контролируют изменяемость объекта.
-   Методы `Object.getPrototypeOf()`, `Object.setPrototypeOf()` позволяют работать с прототипами объекта.
-   Метод `hasOwnProperty()` проверяет, содержит ли объект указанное свойство (без учёта унаследованных свойств).

> [!NOTE]
>
> **Статические методы конструктора**
>
> Статические методы — это методы, которые принадлежат самому конструктору (классу), а не его экземплярам. Они вызываются напрямую через конструктор (класс), а не через объект, созданный с его помощью. Статические методы используются для функциональности, которая не зависит от конкретного экземпляра объекта.
>
> **Пример:**
>
> ```javascript
> class MathUtils {
>     static square(x) {
>         return x * x;
>     }
> }
>
> console.log(MathUtils.square(5)); // 25 (вызов статического метода)
> ```
>
> **Ключевые особенности:**
>
> 1. **Принадлежат конструктору/классу**, а не экземплярам.
> 2. **Вызываются через конструктор/класс**, например, `ClassName.method()`.
> 3. **Не имеют доступа к данным экземпляра** (через `this`), так как они работают на уровне класса.
> 4. **Используются для утилитарных функций**, которые не требуют создания экземпляра.
>
> **Пример статического метода в конструкторе:**
>
> ```javascript
> function User(name) {
>     this.name = name;
> }
>
> // Статический метод
> User.createAdmin = function () {
>     return new User('Admin');
> };
>
> const admin = User.createAdmin();
> console.log(admin.name); // Admin
> ```

---

#### **4.4. Когда использовать конструктор `Object`?**

-   **Редкие случаи**: В большинстве случаев объекты создаются с помощью литерала `{}` или `class`.
-   **Динамическое создание объектов**: Если нужно динамически создавать объекты с определёнными свойствами.
-   **Использование статических методов**: Для работы с прототипами, дескрипторами свойств и другими возможностями.

---

#### **4.5. Примеры использования**

##### **Создание объекта с начальными свойствами**

```javascript
const user = new Object({ name: 'Alice', age: 25 });
console.log(user); // { name: "Alice", age: 25 }
```

##### **Использование `Object.assign()`**

```javascript
const target = { a: 1 };
const source = { b: 2 };
const result = Object.assign(target, source);
console.log(result); // { a: 1, b: 2 }
```

##### **Использование `Object.create()`**

Конструктор `Object` может быть полезен, если нужно создать объект с определённым прототипом или использовать статические методы `Object`, такие как `Object.create()`.

```javascript
const proto = {
    greet() {
        console.log('Hello!');
    },
};
const obj = Object.create(proto);
obj.greet(); // Hello!
```

---

### 5. **Создание через классы**

Классы в JavaScript — это синтаксический сахар над прототипным наследованием. Они предоставляют удобный и понятный способ создания объектов с общими свойствами и методами. Классы используются для создания множества объектов с одинаковой структурой и поведением.

#### **Основные концепции:**

1. **Класс**: Шаблон для создания объектов. Классы объявляются с помощью ключевого слова `class`.
2. **Конструктор**: Специальный метод `constructor`, который вызывается через `new` при создании нового объекта (экземпляра класса).
3. **Методы**: Функции, определённые внутри класса, которые могут быть вызваны на экземплярах класса.
4. **Наследование**: Классы могут наследовать свойства и методы от других классов с помощью ключевого слова `extends`.

---

#### **Пример класса:**

```javascript
class User {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    greet() {
        console.log(`Hello, my name is ${this.name}!`);
    }
}

const user = new User('Alice', 25);
user.greet(); // Hello, my name is Alice!
```

---

## |2| **Свойства объектов**

Свойства объектов в JavaScript — это пары ключ-значение, которые определяют состояние и поведение объекта. Каждый объект в JavaScript представляет собой коллекцию свойств, где ключ — это строка (или символ), а значение — любое допустимое значение JavaScript (примитив, объект, функция и т. д.).

---

### 1. **Типы свойств**

В JavaScript свойства объектов можно разделить на два типа:

#### **1.1. Собственные свойства (Own Properties)**

Собственные свойства — это свойства, которые принадлежат самому объекту, а не его прототипу. Они определяются непосредственно в объекте.

Пример:

```javascript
const obj = {
    name: 'Alice', // Собственное свойство
    age: 25, // Собственное свойство
};

console.log(obj.name); // "Alice"
console.log(obj.age); // 25
```

#### **1.2. Унаследованные свойства (Inherited Properties)**

Унаследованные свойства — это свойства, которые объект получает из своего прототипа. Они не принадлежат самому объекту, но доступны через цепочку прототипов.

Пример:

```javascript
const parent = {
    greet() {
        console.log('Hello!');
    },
};

const child = Object.create(parent); // child наследует свойства parent
child.greet(); // "Hello!" (унаследованный метод)
```

---

### 2. **Типы дескрипторов свойств**

Каждое свойство объекта имеет атрибуты, которые определяют его поведение. Эти атрибуты хранятся в **дескрипторе свойства**. Дескрипторы бывают двух типов:

#### **2.1. Дескриптор данных (Data Descriptor)**

Дескриптор данных описывает свойство, которое имеет значение. Он содержит следующие атрибуты:

-   **`value`**: Значение свойства.
-   **`writable`**: Если `true`, значение свойства можно изменить.
-   **`enumerable`**: Если `true`, свойство будет перечисляемым (например, в циклах `for...in`).
-   **`configurable`**: Если `true`, свойство можно удалить или изменить его атрибуты.

Пример:

```javascript
const obj = {};

Object.defineProperty(obj, 'name', {
    value: 'Alice',
    writable: true,
    enumerable: true,
    configurable: true,
});

console.log(obj.name); // "Alice"
```

#### **2.2. Дескриптор доступа (Accessor Descriptor)**

Дескриптор доступа описывает свойство, которое управляется геттером и сеттером. Он содержит следующие атрибуты:

-   **`get`**: Функция, которая возвращает значение свойства.
-   **`set`**: Функция, которая устанавливает значение свойства.
-   **`enumerable`**: Если `true`, свойство будет перечисляемым.
-   **`configurable`**: Если `true`, свойство можно удалить или изменить его атрибуты.

Пример:

```javascript
const obj = {
    _name: 'Alice', // Приватное свойство (условно)
};

Object.defineProperty(obj, 'name', {
    get() {
        return this._name;
    },
    set(value) {
        this._name = value;
    },
    enumerable: true,
    configurable: true,
});

console.log(obj.name); // "Alice"
obj.name = 'Bob';
console.log(obj.name); // "Bob"
```

---

### 3. **Работа со свойствами**

#### **3.1. Добавление свойств**

Свойства можно добавлять или изменять после создания объекта. Свойства можно добавлять в объект напрямую или с помощью методов.

1. **Прямое добавление**

```javascript
const user = {};
user.name = 'Alice';
user.age = 25;
console.log(user); // { name: "Alice", age: 25 }
```

2. **Использование `Object.defineProperty`**

```javascript
const obj = {};
Object.defineProperty(obj, 'name', {
    value: 'Alice',
    writable: true,
    enumerable: true,
    configurable: true,
});
```

#### **3.2. Чтение свойств**

Доступ к свойствам объекта осуществляется через точку.

**Пример:**

```javascript
const user = { name: 'Alice' };
console.log(user.name); // "Alice"
```

Доступ к свойствам также можно получить через квадратные скобки. Это полезно, если ключ содержит пробелы или символы.

**Пример:**

```javascript
const user = { 'full name': 'Alice Smith' };
console.log(user['full name']); // "Alice Smith"
```

#### **3.3. Изменение свойств**

Свойства можно изменять, если они не защищены атрибутом `writable: false`.

```javascript
const obj = { name: 'Alice' };
obj.name = 'Bob';
console.log(obj.name); // "Bob"
```

#### **3.4. Удаление свойств**

Свойства можно удалить с помощью оператора `delete`, если они не защищены атрибутом `configurable: false`.

```javascript
const obj = { name: 'Alice' };
delete obj.name;
console.log(obj.name); // undefined
```

---

### 4. **Перечисление свойств**

#### **4.1. `for...in`**

Цикл `for...in` перебирает все перечисляемые свойства объекта, включая унаследованные.

```javascript
const obj = { name: 'Alice', age: 25 };
for (const key in obj) {
    console.log(key, obj[key]);
}
// Вывод:
// "name Alice"
// "age 25"
```

#### **4.2. `Object.keys()`**

Метод `Object.keys()` возвращает массив ключей собственных перечисляемых свойств объекта.

```javascript
const obj = { name: 'Alice', age: 25 };
console.log(Object.keys(obj)); // ["name", "age"]
```

#### **4.3. `Object.values()`**

Метод `Object.values()` возвращает массив значений собственных перечисляемых свойств объекта.

```javascript
const obj = { name: 'Alice', age: 25 };
console.log(Object.values(obj)); // ["Alice", 25]
```

#### **4.4. `Object.entries()`**

Метод `Object.entries()` возвращает массив пар `[ключ, значение]` для собственных перечисляемых свойств объекта.

```javascript
const obj = { name: 'Alice', age: 25 };
console.log(Object.entries(obj)); // [["name", "Alice"], ["age", 25]]
```

---

### 5. **Проверка наличия свойств**

#### **5.1. Оператор `in`**

Оператор `in` проверяет наличие свойства в объекте, включая унаследованные свойства.

```javascript
const obj = { name: 'Alice' };
console.log('name' in obj); // true
console.log('toString' in obj); // true (унаследованный метод)
```

#### **5.2. Метод `hasOwnProperty()`**

Метод `hasOwnProperty()` проверяет наличие собственного свойства в объекте (без учёта унаследованных свойств).

```javascript
const obj = { name: 'Alice' };
console.log(obj.hasOwnProperty('name')); // true
console.log(obj.hasOwnProperty('toString')); // false
```

---

### 6. **Особые свойства**

#### **6.1. Символьные свойства**

Ключами свойств могут быть не только строки, но и символы (`Symbol`). Символьные свойства часто используются для создания уникальных или скрытых свойств.

```javascript
const id = Symbol('id');
const obj = {
    [id]: 123,
    name: 'Alice',
};

console.log(obj[id]); // 123
console.log(Object.keys(obj)); // ["name"] (символьные свойства не перечисляются)
```

#### **6.2. Вычисляемые имена свойств**

Ключи могут быть динамическими, то есть вычисляемыми во время выполнения.

```javascript
const key = 'name';
const obj = {
    [key]: 'Alice',
};

console.log(obj.name); // "Alice"
```

#### **6.3. Вложенные объекты**

Объекты могут содержать другие объекты.

**Пример:**

```javascript
const user = {
    name: 'Alice',
    address: {
        city: 'New York',
        zip: '10001',
    },
};
console.log(user.address.city); // "New York"
```

---

## |3| **Методы объектов**

Методы объектов — это **функции**, которые хранятся в свойствах объекта. Они позволяют объекту **выполнять действия** и работать с его данными.

### **1. Создание метода в объекте**

Методы можно добавлять в объект **разными способами**:

#### **1.1 Использование обычной функции**

```javascript
const user = {
    name: 'Alice',
    sayHello: function () {
        console.log('Hello!');
    },
};

user.sayHello(); // Выведет: Hello!
```

> `sayHello` — это метод объекта `user`. Он хранится как свойство, значением которого является **функция**.

---

#### **1.2 Использование сокращенного синтаксиса**

В ES6 появился **сокращенный синтаксис** методов:

```javascript
const user = {
    name: 'Alice',
    sayHello() {
        console.log('Hello!');
    },
};

user.sayHello(); // Hello!
```

> Такой синтаксис **эквивалентен** `sayHello: function() {...}` и короче писать.

---

#### **1.3 Добавление метода после создания объекта**

Можно добавить метод **после создания** объекта:

```javascript
const user = { name: 'Alice' };

user.sayHello = function () {
    console.log('Hello!');
};

user.sayHello(); // Hello!
```

> Это удобно, когда нужно динамически добавлять функции в объект.

---

### **2. Встроенные методы объектов**

JavaScript предоставляет несколько встроенных методов работы с объектами.

#### **2.1 Object.keys(obj)**

Возвращает **массив ключей** объекта.

```javascript
const user = { name: 'Alice', age: 25 };
console.log(Object.keys(user)); // ["name", "age"]
```

#### **2.2 Object.values(obj)**

Возвращает **массив значений** объекта.

```javascript
console.log(Object.values(user)); // ["Alice", 25]
```

#### **2.3 Object.entries(obj)**

Возвращает **массив пар `[ключ, значение]`**.

```javascript
console.log(Object.entries(user)); // [["name", "Alice"], ["age", 25]]
```

#### **2.4 Object.assign(target, source)**

Копирует свойства одного объекта в другой.

```javascript
const user = { name: 'Alice' };
const extra = { age: 25 };

const merged = Object.assign(user, extra);
console.log(merged); // { name: "Alice", age: 25 }
```

#### **2.5 Object.freeze(obj)**

**Замораживает** объект (нельзя изменять или добавлять свойства).

```javascript
const user = { name: 'Alice' };
Object.freeze(user);

user.name = 'Bob'; // Ошибка в строгом режиме
console.log(user.name); // "Alice"
```

#### **2.6 Object.seal(obj)**

Запрещает **добавление/удаление** свойств, но можно изменять существующие.

```javascript
const user = { name: 'Alice' };
Object.seal(user);

user.name = 'Bob'; // Можно изменить
delete user.name; // Ошибка
console.log(user); // { name: "Bob" }
```

---

### **4. Наследование методов через `prototype`**

При использовании **функций-конструкторов** методы можно добавлять в `prototype`, чтобы не дублировать их в каждом экземпляре.

```javascript
function User(name) {
    this.name = name;
}

// Добавляем метод в прототип
User.prototype.sayHello = function () {
    console.log(`Hello, my name is ${this.name}`);
};

const user1 = new User('Alice');
const user2 = new User('Bob');

user1.sayHello(); // Hello, my name is Alice
user2.sayHello(); // Hello, my name is Bob
```

> Все объекты, созданные через `new User()`, **разделяют один метод** `sayHello()`, экономя память.

---

### **5. Использование методов внутри классов (ES6)**

Современные классы позволяют определять методы прямо внутри `class`.

```javascript
class User {
    constructor(name) {
        this.name = name;
    }

    sayHello() {
        console.log(`Hello, my name is ${this.name}`);
    }
}

const user = new User('Alice');
user.sayHello(); // Hello, my name is Alice
```

> Этот код удобнее, чем `prototype`, но работает аналогично.

---

### **Вывод**

-   **Методы** — это функции, хранящиеся в свойствах объекта.
-   Они **могут использовать `this`**, чтобы работать с данными объекта.
-   **Встроенные методы** (`Object.keys()`, `Object.assign()`, `Object.freeze()`) помогают манипулировать объектами.
-   Методы могут терять `this`, но `bind()` это исправляет.
-   **Прототипы и классы** позволяют **избегать дублирования методов**.

---

## |4| **Контекст вызова `this`**

Контекст вызова `this` — это ключевое слово в JavaScript, которое ссылается на объект, в контексте которого выполняется функция. Понимание `this` важно для работы с методами объектов, обработчиками событий и другими сценариями, где контекст выполнения может меняться. Значение `this` определяется в момент вызова функции и зависит от того, как функция была вызвана.

---

#### **1. Как работает `this` в методах объекта?**

Поведение `this` одинаково для объектов, созданных через литерал, конструктор Object() или класс.

**В объектах, созданных через литерал:**

Здесь `this` внутри метода `greet` ссылается на объект `user`.

```javascript
const user = {
    name: 'Alice',
    greet() {
        console.log(`Hello, ${this.name}!`);
    },
};
user.greet(); // Hello, Alice!
```

**В объектах, созданных через new Object()**

`this` также ссылается на сам объект.

```js
const user = new Object();
user.name = 'Alice';
user.greet = function () {
    console.log(`Hello, ${this.name}!`);
};
user.greet(); // Hello, Alice!
```

**В объектах, созданных через класс**

`this` ссылается на экземпляр класса.

```js
class User {
    constructor(name) {
        this.name = name;
    }
    greet() {
        console.log(`Hello, ${this.name}!`);
    }
}

const user = new User('Alice');
user.greet(); // Hello, Alice!
```

**В объектах, созданных через конструктор**

В конструкторах `this` ссылается на новый создаваемый объект.

**Пример:**

```javascript
function User(name) {
    this.name = name;
    this.greet = function () {
        console.log(`Hello, ${this.name}!`);
    };
}

const user = new User('Alice');
user.greet(); // Hello, Alice!
```

---

#### **2. Потеря контекста `this`**

Контекст `this` может быть потерян, если метод передаётся как callback или вызывается вне контекста объекта.

**Пример потери контекста:**

```javascript
const user = {
    name: 'Alice',
    greet() {
        console.log(`Hello, ${this.name}!`);
    },
};

const greet = user.greet;
greet(); // Ошибка: this.name — undefined
```

Здесь `greet` вызывается как обычная функция, и `this` ссылается на глобальный объект (в браузере это `window`), а не на `user`.

---

#### **3. Решение проблемы потери контекста**

##### **3.1. Использование `bind()`**

Метод `bind()` создаёт новую функцию с привязанным контекстом.

**Пример:**

```javascript
const boundGreet = user.greet.bind(user);
boundGreet(); // Hello, Alice!
```

##### **3.2. Использование `call()` и `apply()`**

Методы `call()` и `apply()` вызывают функцию с указанным контекстом.

**Пример с `call()`:**

```javascript
user.greet.call(user); // Hello, Alice!
```

**Пример с `apply()`:**

```javascript
user.greet.apply(user); // Hello, Alice!
```

##### **3.3. Использование стрелочных функций**

Стрелочные функции не имеют своего `this`. Они захватывают `this` из внешнего контекста.

**Пример:**

```javascript
const user = {
    name: 'Alice',
    greet: () => {
        console.log(`Hello, ${this.name}!`);
    },
};
user.greet(); // Hello, undefined! (this ссылается на внешний контекст)
```

**Исправленный пример:**

```javascript
const user = {
    name: 'Alice',
    greet() {
        const innerFunc = () => {
            console.log(`Hello, ${this.name}!`);
        };
        innerFunc();
    },
};
user.greet(); // Hello, Alice!
```

---

#### **4. `this` в обработчиках событий**

В обработчиках событий `this` ссылается на элемент, на котором произошло событие.

**Пример:**

```javascript
const button = document.querySelector('button');
button.addEventListener('click', function () {
    console.log(this); // <button>...</button>
});
```

---

#### **5. Итог**

-   `this` ссылается на объект, в контексте которого вызвана функция.
-   В методах объекта `this` ссылается на сам объект.
-   В конструкторах и классах `this` ссылается на новый создаваемый объект.
-   Контекст `this` может быть потерян при передаче метода как callback.
-   Для решения проблемы потери контекста используются `bind()`, `call()`, `apply()` или стрелочные функции.
-   В обработчиках событий `this` ссылается на элемент, на котором произошло событие.

---

## |4| **Работа с объектами в современных стандартах**

### **Литералы объектов: сокращение записи свойств и методов**

Если имя свойства совпадает с именем переменной, можно использовать сокращённую запись.

**Пример:**

```javascript
const name = 'Alice';
const age = 25;
const user = { name, age };
console.log(user); // { name: "Alice", age: 25 }
```

---

### **Spread-оператор для объектов**

Spread оператор (`...`) работает с объектами, начиная с ES2018 (ES9) и может применяться для копирования свойств одного объекта в другой.

#### Пример 1: Копирование объекта

```javascript
const obj1 = { a: 1, b: 2 };
const obj2 = { ...obj1 }; // Копируем свойства obj1 в obj2

console.log(obj2); // { a: 1, b: 2 }
```

Теперь `obj2` — это независимая копия `obj1`.

#### Пример 2: Объединение объектов

```javascript
const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3, d: 4 };
const combined = { ...obj1, ...obj2 };

console.log(combined); // { a: 1, b: 2, c: 3, d: 4 }
```

Если свойства объектов совпадают, значение будет взято из последнего объекта:

```javascript
const obj1 = { a: 1, b: 2 };
const obj2 = { b: 99, c: 3 };
const combined = { ...obj1, ...obj2 };

console.log(combined); // { a: 1, b: 99, c: 3 }
```

Здесь свойство `b` перезаписано значением из `obj2`.

#### Пример 3: Добавление свойств в объект

```javascript
const obj1 = { a: 1, b: 2 };
const obj2 = { ...obj1, c: 3, d: 4 };

console.log(obj2); // { a: 1, b: 2, c: 3, d: 4 }
```

---

### **Деструктуризация объекта**

Для деструктуризации объектов используется оператор `rest` `...`
Здесь `...rest` собирает оставшиеся свойства объекта.

```javascript
const obj = { a: 1, b: 2, c: 3, d: 4 };
const { a, b, ...rest } = obj;

console.log(a); // 1
console.log(b); // 2
console.log(rest); // { c: 3, d: 4 }
```

---

### **Динамические ключи в объектах**

Ключи могут быть вычисляемыми с помощью квадратных скобок.

**Пример:**

```javascript
const key = 'name';
const user = { [key]: 'Alice' };
console.log(user.name); // "Alice"
```

---

### **Опциональная цепочка (Optional Chaining)**

Опциональная цепочка или "Оператор опциональной последовательности" (`?.`) — это синтаксис в JavaScript, который позволяет безопасно обращаться к свойствам объекта или вызова метода, не проверяя, существует ли каждый уровень вложенности. Если какой-то из промежуточных элементов равен `null` или `undefined`, выражение возвращает `undefined` вместо выбрасывания ошибки.

Оператор `?.` проверяет, существует ли объект или его промежуточное значение. Если объект равен `null` или `undefined`, возвращается `undefined`, и выполнение цепочки не продолжается. Это позволяет избежать ошибок вида `TypeError: Cannot read properties of null (or undefined)`.

> [!NOTE]
>
> **Новая возможность**
> Эта возможность была добавлена в язык недавно. В старых браузерах может понадобиться полифил.

#### **1. Синтаксис**

Опциональная цепочка записывается с помощью символа `?.` и может использоваться для:

-   Доступа к свойствам объекта: `obj?.prop`.
-   Вызова методов: `obj.method?.()`.
-   Доступа по скобочной нотации: `obj?.[expr]`.
-   Доступа к элементам массива: `arr?.[index]`.

```js
const user = { name: 'Alice' };

let userName = user?.name;

// Эквивалентно записи
let userName = user === null || user === undefined ? undefined : user.name;

// или
let userName;
if (user && user.name) {
    userName = user.name;
}
```

---

#### **2. Примеры использования**

**2.1. Доступ к свойствам объекта**

Без опциональной цепочки:

```javascript
const user = { name: 'Alice' };
console.log(user.address.city); // Ошибка: Cannot read property 'city' of undefined
```

С опциональной цепочкой:

```javascript
console.log(user.address?.city); // undefined (без ошибки)
```

**2.2. Вызов методов**

Без опциональной цепочки:

```javascript
const user = {
    name: 'John',
    greet() {
        console.log('Hello!');
    },
};
user.greet(); // Hello!
user.logout(); // Ошибка: user.logout is not a function
```

С опциональной цепочкой:

```javascript
user.logout?.(); // undefined (без ошибки)
```

> [!WARNING]
>
> **Примечание:**
> Для существующего свойства, не являющегося функцией, например использование конструкции `user.name?.()` всё равно выбросит `TypeError исключение (user.name не является функцией)`.

**2.3. Доступ по скобочной нотации**

Вы также можете использовать оператор опциональной последовательности, когда обращаетесь к свойству с помощью скобочной нотации:

```js
let nestedProp = obj?.['prop' + 'Name'];
```

```js
const field = 'name';
const user = { age: 32 };

console.log(user?.[field]); // undefined
```

**2.4. Доступ к элементам массива**

Без опциональной цепочки:

```javascript
const arr = [1, 2, 3];
console.log(arr[5].toString()); // Ошибка: Cannot read property 'toString' of undefined
```

С опциональной цепочкой:

```javascript
console.log(arr[5]?.toString()); // undefined (без ошибки)
```

---

#### **3. Как работает опциональная цепочка?**

Опциональная цепочка проверяет, является ли значение перед `?.` равным `null` или `undefined`. Если это так, выражение возвращает `undefined`. В противном случае выполняется доступ к свойству, методу или элементу массива.

**Пример:**

```javascript
const user = { address: { city: 'New York' } };
console.log(user.address?.city); // New York
console.log(user.contacts?.phone); // undefined
```

---

#### **4. Особенности**

**4.1. Короткое замыкание**

Если на каком-то этапе цепочки встречается `null` или `undefined`, дальнейшие проверки не выполняются.

**Пример:**

```javascript
const user = null;
console.log(user?.address?.city); // undefined
```

Во вложенных объектах возможно использование оператора опциональной последовательности неограниченное количество раз:

```js
let customer = {
    name: 'Carl',
    details: {
        age: 82,
        location: 'Paradise Falls', // точный адрес неизвестен
    },
};
let customerCity = customer.details?.address?.city;

// … это также работает с вызовами функций
let duration = vacations.trip?.getTime?.();
```

**4.2. Использование с функциями**

Опциональная цепочка может использоваться для вызова методов, которые могут отсутствовать.

**Пример:**

```javascript
const user = {
    greet() {
        console.log('Hello!');
    },
};
user.greet?.(); // Hello!
user.logout?.(); // undefined (без ошибки)
```

**4.3. Использование с массивами**

Опциональная цепочка позволяет безопасно обращаться к элементам массива.

**Пример:**

```javascript
const arr = [1, 2, 3];
console.log(arr[5]?.toString()); // undefined
```

**4.4. Вместе с оператором "||" (или значение по умолчанию)**

```js
const user = null;
console.log(user?.name || 'Guest'); // "Guest"
```

**4.5. Вместе с оператором "??" (nullish coalescing)**

```js
const user = null;
console.log(user?.name ?? 'Guest'); // "Guest"
```

**4.6. Сокращённое вычисление**

Конструкция `?.` немедленно останавливает вычисление, если левая часть не существует.

Так что если после `?.` есть какие-то вызовы функций или операции, то они не произойдут.

```js
let user = null;
let x = 0;

user?.sayHi(x++); // нет "user", поэтому выполнение не достигает вызова sayHi и x++

alert(x); // 0, значение не увеличилось
```

**4.7. Работа с колбэк-функциями и обработчиками событий**

Если вы используете колбэк-функции или извлекаете методы объекта деструктурирующим присваиванием, Вы можете получить несуществующие значения, которые нельзя вызывать как функции до проверки на их существование. Используя оператор `?.`, вы можете избежать лишних проверок:

```js
// С использованием ES2019
function doSomething(onContent, onError) {
    try {
        // ... делаем что-то с данными
    } catch (err) {
        if (onError) {
            // проверяем, существует ли onError
            onError(err.message);
        }
    }
}
```

```js
// С использованием оператора опциональной последовательности
function doSomething(onContent, onError) {
    try {
        // ... делаем что-то с данными
    } catch (err) {
        onError?.(err.message); // не выбросит исключение, если onError равен undefined
    }
}
```

**4.8. Работа с `Map` объектом**

В этом примере производится обращение к свойству name элемента с ключом `bar` объекта `Map`. Элемент с таким ключом отсутствует, но исключение выброшено не будет; `nameBar` равен `undefined`.

```js
let myMap = new Map();
myMap.set('foo', { name: 'baz', desc: 'inga' });

let nameBar = myMap.get('bar')?.name;
```

> [!WARNING]
>
> **Не злоупотребляйте опциональной цепочкой**
> Нам следует использовать `?.` только там, где нормально, что чего-то не существует.
>
> К примеру, если, в соответствии с логикой нашего кода, объект `user` должен существовать, но `address` является необязательным, то нам следует писать `user.address?.street`, но не `user?.address?.street`.
>
> В этом случае, если вдруг `user` окажется `undefined`, мы увидим программную ошибку по этому поводу и исправим её. В противном случае, если слишком часто использовать `?.`, ошибки могут замалчиваться там, где это неуместно, и их будет сложнее отлаживать.

> [!WARNING]
>
> **Переменная перед `?.` должна быть объявлена**
> Если переменной `user` вообще нет, то `user?.anything` приведёт к ошибке:
>
> ```js
> // ReferenceError: user is not defined
> user?.address;
> ```
>
> Переменная должна быть объявлена (к примеру, как `let/const/var user` или как параметр функции). Опциональная цепочка работает **только с объявленными переменными**.

---

#### **5. Ограничения**

**5.1. Только для чтения: Нельзя использовать ?. для записи в свойства.**

```js

const user = null;
user?.name = 'Bob'; // Ошибка
```

**5.2. Не работает с delete:**

Опциональная цепочка (`?.`) в JavaScript предназначена для безопасного доступа к свойствам объекта, методам или элементам массива, чтобы избежать ошибок, если какой-то из промежуточных элементов равен `null` или `undefined`. Однако она **не работает с оператором `delete`**, и на это есть несколько причин.

```js
const user = { name: 'Alice' };
delete user?.name; // Синтаксическая ошибка
```

**Как работает опциональная цепочка (`?.`)?**

Опциональная цепочка проверяет, существует ли свойство или метод перед тем, как обратиться к нему. Если какой-то из промежуточных элементов равен `null` или `undefined`, выражение возвращает `undefined` вместо выбрасывания ошибки.

**Пример:**

```javascript
const user = { address: { city: 'New York' } };
console.log(user.address?.city); // New York
console.log(user.contacts?.phone); // undefined (без ошибки)
```

**`delete` — это оператор, а не выражение**

Опциональная цепочка (`?.`) работает только с выражениями, которые возвращают значения (например, доступ к свойствам или вызов методов). Оператор `delete` не возвращает значение, а выполняет действие (удаление свойства). Поэтому синтаксически `delete` не может быть совмещён с `?.`.

**Пример неправильного использования:**

```javascript
const user = { address: { city: 'New York' } };
delete user.address?.city; // Синтаксическая ошибка
```

**`delete` уже безопасен**

Оператор `delete` сам по себе безопасен: если свойства не существует, он просто ничего не делает и возвращает `true`. Поэтому нет необходимости использовать опциональную цепочку для `delete`.

**Пример:**

```javascript
const user = { name: 'Alice' };
console.log(delete user.age); // true (свойства age не существует, но ошибки нет)
```

**Логика `delete` противоречит логике `?.`**

Опциональная цепочка (`?.`) возвращает `undefined`, если свойство отсутствует. Однако `delete` должен либо удалить свойство, либо ничего не делать, если свойство отсутствует. Эти две логики несовместимы.

**Как безопасно удалять свойства?**

Если вы хотите безопасно удалить свойство из вложенного объекта, можно использовать обычную проверку на `null`/`undefined`.

**Пример:**

```javascript
const user = { address: { city: 'New York' } };

if (user.address) {
    delete user.address.city;
}

console.log(user.address); // { }
```

**5.3. Не заменяет стандартные проверки на существование объекта:**

Если нужно убедиться, что объект существует и провести дополнительные проверки, `?.` может быть недостаточно.

---

#### **6. Примеры использования**

**6.1. Работа с вложенными объектами**

```javascript
const user = {
    profile: {
        name: 'Alice',
        address: {
            city: 'New York',
        },
    },
};

console.log(user.profile?.address?.city); // New York
console.log(user.profile?.contacts?.phone); // undefined
```

**6.2. Вызов методов, которые могут отсутствовать**

```javascript
const user = {
    greet() {
        console.log('Hello!');
    },
};

user.greet?.(); // Hello!
user.logout?.(); // undefined (без ошибки)
```

**6.3. Работа с API**

При работе с данными, которые могут отсутствовать (например, ответ от API), опциональная цепочка упрощает код.

**Пример:**

```javascript
const response = {
    data: {
        user: {
            name: 'Alice',
        },
    },
};

console.log(response.data?.user?.name); // Alice
console.log(response.data?.posts?.length); // undefined
```

---

## **Задачи**

### **Введение в объекты**

1. **Создание простого объекта**  
   Создайте объект `user`, содержащий свойства:

-   `name` (строка)
-   `age` (число)
-   `isAdmin` (логическое значение)

Выведите этот объект в консоль.

2. **Доступ к свойствам объекта**  
   Используя объект `user` из предыдущей задачи:

-   Выведите имя пользователя (`name`).
-   Увеличьте возраст (`age`) на 1.
-   Измените `isAdmin` на `true`.

Выведите обновленный объект в консоль.

3. **Добавление и удаление свойств**  
   Добавьте в объект `user` новое свойство `email`, затем удалите свойство `isAdmin`.  
   Выведите объект до и после удаления свойства.

4. **Проверка наличия свойства**  
   Напишите функцию `hasProperty(obj, key)`, которая принимает объект и строку (ключ) и возвращает `true`, если в объекте есть такое свойство, и `false`, если нет.

Пример:

```javascript
const user = { name: 'Alice', age: 25 };
console.log(hasProperty(user, 'age')); // true
console.log(hasProperty(user, 'email')); // false
```

5. **Итерация по объекту**  
   Создайте объект `car` с характеристиками машины (`brand`, `model`, `year`).  
   Напишите цикл `for...in`, который перебирает и выводит все свойства и их значения в формате:

```
brand: Toyota
model: Camry
year: 2022
```

---

### **Свойства объектов**

1. **Доступ к свойствам**  
   Создайте объект `book` с полями `title`, `author` и `price`. Выведите значение поля `author` с помощью точки (`.`) и строки (`['']`).

2. **Проверка существования свойства**  
   Создайте объект `person` с полями `name` и `age`. Напишите функцию, которая принимает объект и проверяет, существует ли в нем свойство `address`.

3. **Доступ к свойствам объекта**  
   Создайте объект `person` с двумя свойствами:

-   `firstName: "John"`
-   `lastName: "Doe"`

Выведите в консоль полное имя, используя конкатенацию или шаблонные строки.

4. **Динамическое добавление свойств**  
   Создайте пустой объект `book`.  
   Добавьте в него свойства:

-   `title` (название книги)
-   `author` (автор книги)
-   `year` (год издания)

Выведите объект в консоль.

5. **Использование квадратных скобок**  
   Создайте объект `settings` с двумя свойствами:

-   `theme: "dark"`
-   `language: "en"`

Запросите у пользователя (с помощью `prompt`) ключ свойства, затем выведите его значение (например, `settings["theme"]`).

6. **Замена значения свойства**  
   Создайте объект `user` с полем `isLoggedIn: false`.  
   Напишите функцию `logIn(user)`, которая меняет значение `isLoggedIn` на `true`.  
   Вызовите функцию и выведите объект до и после вызова.

7. **Копирование объекта (поверхностное)**  
   Создайте объект `car` с тремя свойствами.  
   Скопируйте его в новый объект `newCar` с помощью `Object.assign()`.  
   Измените одно из свойств `newCar` и выведите оба объекта в консоль.

---

### **Методы объектов**

1. **Добавление метода**  
   Создайте объект `calculator` с методами `add` и `subtract`, которые принимают два числа и возвращают их сумму и разность соответственно.

2. **Контекст `this` в методах**  
   Создайте объект `user` с полем `name` и методом `greet`, который выводит сообщение `"Hello, my name is {name}"`. Используйте `this` для доступа к имени.

3. **Использование `this` внутри метода**  
   Создайте объект `car` с полями:

-   `brand: "Toyota"`
-   `model: "Camry"`
-   `year: 2020`

Добавьте метод `getInfo()`, который возвращает строку вида:  
`"Автомобиль: Toyota Camry, год выпуска: 2020."`  
Вызовите этот метод.

4. **Добавление метода через `Object.defineProperty()`**  
   Создайте объект `rectangle` с полями `width` и `height`.  
   Используя `Object.defineProperty()`, добавьте метод `getArea()`, который возвращает площадь (`width * height`).  
   Проверьте работу метода.

5. **Динамическое добавление метода**  
   Создайте объект `person` с полем `name: "John"`.  
   Добавьте метод `sayHello()` динамически (после создания объекта), который выводит `"Привет, я John!"`.  
   Вызовите метод.

6. **Клонирование объекта с методами**  
   Создайте объект `calculator` с методами:

-   `add(a, b)`, который возвращает сумму `a + b`
-   `subtract(a, b)`, который возвращает разницу `a - b`

Создайте копию этого объекта с помощью `Object.assign()` и убедитесь, что методы работают в новом объекте.

---

### **Spread-оператор для объектов**

1. **Копирование объекта**  
   Создайте объект `settings` с произвольными полями. Создайте его копию с помощью spread-оператора и добавьте новое поле `theme`.

2. **Объединение объектов**  
   Создайте два объекта: `defaults` с настройками по умолчанию и `userSettings` с пользовательскими настройками. Объедините их в один объект с помощью spread-оператора, приоритет отдать настройкам пользователя.

3. **Клонирование объекта**  
   Создайте объект `user`:

```javascript
const user = { name: 'Alice', age: 25 };
```

Используйте **spread-оператор**, чтобы создать его клон `userClone`.  
Измените свойство `age` в `userClone` и убедитесь, что оригинальный объект `user` не изменился.

4. **Изменение существующего объекта**  
   Создайте объект `settings`:

```javascript
const settings = { theme: 'dark', notifications: true, language: 'English' };
```

Создайте новый объект `updatedSettings`, в котором измените `theme` на `"light"`, используя **spread-оператор**.

5. **Передача объекта в функцию**  
   Создайте объект `product`:

```javascript
const product = { name: 'Laptop', price: 1000, brand: 'Dell' };
```

Создайте функцию `updatePrice`, которая принимает объект и новое значение цены, а затем возвращает новый объект с обновленной ценой, используя **spread-оператор**.

```javascript
function updatePrice(product, newPrice) {
    // Ваша реализация
}
```

Вызовите `updatePrice(product, 1200)` и выведите результат в консоль.

6. **Глубокое копирование вложенного объекта**  
   Создайте объект `person`:

```javascript
const person = {
    name: 'John',
    address: { city: 'New York', zip: 10001 },
};
```

Используйте **spread-оператор** для создания поверхностной копии `personCopy`.  
Измените `personCopy.address.city = "Los Angeles"` и проверьте, изменился ли оригинальный объект `person`.  
Как исправить проблему глубокой копии?

---

### **Деструктуризация объекта**

1. **Извлечение полей**  
   Создайте объект `product` с полями `name`, `price` и `category`. С помощью деструктуризации извлеките `name` и `price`, а затем выведите их в консоль.

2. **Деструктуризация с переименованием**  
   Создайте объект `employee` с полями `firstName` и `lastName`. Извлеките их с помощью деструктуризации, переименовав в `fName` и `lName`.

3. **Деструктуризация с значениями по умолчанию**  
   Дан объект `settings`:

```javascript
const settings = { theme: 'dark', language: 'English' };
```

Используйте **деструктуризацию**, чтобы извлечь `theme`, `language` и `notifications`, задав `notifications` значение по умолчанию `true`.  
Выведите переменные в консоль.

4. **Деструктуризация вложенных объектов**  
   Дан объект `person`:

```javascript
const person = {
    name: 'John',
    address: {
        city: 'Los Angeles',
        zip: 90001,
    },
};
```

Используйте **деструктуризацию**, чтобы извлечь `name` и `city` в отдельные переменные.  
Выведите их в консоль.

5. **Деструктуризация в параметрах функции**  
   Создайте функцию `printUserInfo`, которая принимает объект с полями `name` и `email` и выводит в консоль строку:

```
Пользователь: Alice, Email: alice@example.com
```

Вызовите `printUserInfo({ name: "Alice", email: "alice@example.com" })`.  
Используйте **деструктуризацию параметров** в объявлении функции.

---

### **Динамические ключи в объектах**

1. **Создание динамического ключа**  
   Создайте объект `person` с одним свойством `name`. Добавьте поле с ключом, значение которого задается переменной, например, `const key = 'age';`.

2. **Доступ через переменную**  
   Создайте объект `item` с произвольными полями. Напишите функцию, которая принимает объект и ключ, возвращает значение свойства объекта, соответствующее этому ключу.

3. **Создание объекта с динамическими ключами**  
   Напишите функцию `createUser`, которая принимает `key` (строку) и `value`, а затем создает объект с этим ключом и значением.  
   Пример вызова:

```javascript
const user = createUser('name', 'Alice');
console.log(user); // { name: "Alice" }
```

4. **Генерация ключей в объекте через цикл**  
   Дан массив:

```javascript
const keys = ['name', 'age', 'city'];
const values = ['Bob', 30, 'Paris'];
```

Используйте цикл `for` и динамические ключи, чтобы создать объект:

```javascript
{
  name: "Bob",
  age: 30,
  city: "Paris"
}
```

5. **Изменение значения динамического ключа**  
   Дан объект:

```javascript
const car = { brand: 'Toyota', model: 'Corolla' };
```

Напишите функцию `updateProperty(obj, key, value)`, которая изменяет значение свойства по переданному `key`.  
Пример вызова:

```javascript
updateProperty(car, 'model', 'Camry');
console.log(car); // { brand: "Toyota", model: "Camry" }
```

6. **Динамическое добавление нескольких ключей**  
   Создайте объект `settings`, а затем добавьте в него свойства `theme`, `language` и `notifications`, используя динамические ключи.

```javascript
const settings = {};
const key1 = 'theme';
const key2 = 'language';
const key3 = 'notifications';

// Добавьте свойства
```

Ожидаемый результат:

```javascript
{
  theme: "dark",
  language: "English",
  notifications: true
}
```

7. **Использование символов в качестве динамических ключей**  
   Создайте объект `user` и добавьте к нему динамическое свойство с помощью `Symbol()`.  
   Выведите объект в консоль и убедитесь, что свойство скрыто при обычном выводе `console.log(user)`.  
   Попробуйте получить его значение явно.

Пример:

```javascript
const user = { name: 'Alice' };
const secretKey = Symbol('id');

// Добавьте динамическое свойство
user[secretKey] = 12345;

console.log(user); // ? (Что будет выведено?)
console.log(user[secretKey]); // 12345
```

---

### **Опциональная цепочка '?.'**

1. **Доступ к вложенным свойствам**  
   Создайте объект `order`, содержащий поле `details`, которое в свою очередь имеет поле `price`. Используйте опциональную цепочку для доступа к `price`, даже если поле `details` отсутствует.

2. **Вызов методов с '?.'**  
   Создайте объект `user` с методом `getInfo`, который возвращает строку `"User Info"`. Проверьте, существует ли метод перед вызовом, используя `user?.getInfo?.()`.

3. **Работа с массивом объектов**  
   Создайте массив объектов `users`, где каждый объект имеет поле `name`. Напишите функцию, которая возвращает имя первого пользователя, если массив не пуст, используя `users[0]?.name`.

4. **Безопасный доступ к свойству объекта**  
   Дан объект:

```javascript
const user = { name: 'Alice', address: { city: 'Paris' } };
```

Напишите функцию `getCity(user)`, которая безопасно получает название города (`user.address.city`).  
Если `address` отсутствует, функция должна возвращать `"Unknown"`, не выбрасывая ошибку.

Пример вызова:

```javascript
console.log(getCity(user)); // "Paris"
console.log(getCity({ name: 'Bob' })); // "Unknown"
```

5. **Поиск элемента в массиве с опциональной цепочкой**  
   Дан массив пользователей:

```javascript
const users = [
    { id: 1, name: 'Alice' },
    { id: 2, name: 'Bob' },
];
```

Напишите функцию `findUserName(users, id)`, которая безопасно получает `name` пользователя по его `id`.  
Если пользователь не найден, функция должна возвращать `"Not found"`.

Пример вызова:

```javascript
console.log(findUserName(users, 2)); // "Bob"
console.log(findUserName(users, 5)); // "Not found"
```

6. **Доступ к вложенному свойству без ошибок**  
   Дан объект настроек:

```javascript
const settings = { appearance: { theme: 'dark' } };
```

Напишите код, который безопасно получает значение `settings.appearance.theme`.  
Если `appearance` отсутствует, должен возвращаться `"default"`.

Пример:

```javascript
console.log(settings.appearance?.theme ?? 'default'); // "dark"
console.log({}.appearance?.theme ?? 'default'); // "default"
```

7. **Опциональная цепочка в вызове функций**  
   Дан объект:

```javascript
const config = {
    onInit() {
        console.log('Initializing...');
    },
};
```

Напишите код, который вызывает `config.onInit`, если такой метод существует.  
Если метода нет, код не должен выбрасывать ошибку.

Пример:

```javascript
config.onInit?.(); // "Initializing..."
({}).onInit?.(); // Ничего не происходит, ошибки нет
```
