# **1.1.1. Стандарт ECMAScript (ES)**

> [Index](./0%20Index.md)

**[ECMAScript](https://ru.wikipedia.org/wiki/ECMAScript) (ES)** — это стандарт, определяющий спецификацию языка программирования, который лежит в основе JavaScript. Этот стандарт разрабатывается и поддерживается организацией **ECMA International** в рамках технического комитета **TC39**.

JavaScript, JScript (Microsoft), и ActionScript (Adobe) — реализации ECMAScript.

---

## **История ECMAScript**

| **Версия** | **Год** | **Ключевые особенности**                                                                                 |
| ---------- | ------- | -------------------------------------------------------------------------------------------------------- |
| **ES1**    | 1997    | Первый стандарт, базовая спецификация JavaScript.                                                        |
| **ES2**    | 1998    | Минимальные изменения, добавлены требования для совместимости.                                           |
| **ES3**    | 1999    | Добавлены регулярные выражения, инструкции `try/catch`, более сложные строки (с экранированием).         |
| **ES4**    | Отменён | Планы были слишком амбициозны, проект не был реализован.                                                 |
| **ES5**    | 2009    | Добавлены `strict mode`, методы работы с массивами, `JSON.parse`, `Object.defineProperty`.               |
| **ES6**    | 2015    | Самое большое обновление: `let`, `const`, классы, стрелочные функции, модули, промисы, шаблонные строки. |
| **ES7**    | 2016    | Методы `Array.prototype.includes`, оператор `**` (возведение в степень).                                 |
| **ES8**    | 2017    | Асинхронные функции (`async/await`), методы работы с объектами.                                          |
| **ES9**    | 2018    | Оператор rest/spread для объектов, асинхронные итераторы.                                                |
| **ES10**   | 2019    | Методы `flat` и `flatMap` для массивов, `Object.fromEntries`.                                            |
| **ES11**   | 2020    | `Nullish coalescing (??)`, `Optional chaining (?.)`, глобальный объект `globalThis`.                     |
| **ES12**   | 2021    | Логические операторы присваивания (`&&=`, `                                                              |

---

## **Как работает стандарт**

1. **Разработка и утверждение**:

   - За разработку отвечает комитет TC39, который собирается несколько раз в год.
   - Предложения проходят несколько стадий обсуждения (от идеи до утверждения).

2. **Совместимость**:

   - Реализация стандарта в браузерах или средах, таких как Node.js, может занимать время.
   - Для использования новейших возможностей можно применять транспилеры, такие как Babel.

---

## **Основные изменения в ECMAScript**

### **1. ES5 (2009)**

- `strict mode`: Строгий режим выполнения кода.
- Методы для массивов: `forEach`, `map`, `filter`, `reduce`.
- Работа с JSON: `JSON.parse`, `JSON.stringify`.
- Свойства объекта: `Object.defineProperty`.

---

#### **`strict mode` в JavaScript**

**`strict mode`** (строгий режим) — это специальный режим выполнения кода в JavaScript, который вводит более строгие правила интерпретации и выполнения. Он помогает писать более безопасный и предсказуемый код, устраняя некоторые "тихие" ошибки, улучшая производительность и предотвращая использование устаревших или потенциально небезопасных функций.

#### **Как включить строгий режим**

##### **1. Включение для всего файла**

Добавьте строку `"use strict";` в начало файла. Это активирует строгий режим для всего скрипта.

```javascript
'use strict';

x = 10; // Ошибка: x не объявлен
```

##### **2. Включение для функции**

Вы можете активировать строгий режим только для определённой функции, добавив `"use strict";` в её начало.

```javascript
function myFunction() {
  'use strict';
  y = 20; // Ошибка: y не объявлен
}
myFunction();
```

---

#### **Основные изменения и ограничения в строгом режиме**

##### **1. Ошибка при использовании необъявленных переменных**

В обычном режиме присваивание значения необъявленной переменной создаёт её глобально. В строгом режиме это вызывает ошибку.

```javascript
'use strict';
x = 10; // Ошибка: x не объявлен
```

##### **2. Запрет на удаление переменных, функций и объектов**

В строгом режиме нельзя удалять переменные или функции с помощью оператора `delete`.

```javascript
'use strict';
let x = 10;
delete x; // Ошибка: нельзя удалить переменную

function myFunc() {}
delete myFunc; // Ошибка: нельзя удалить функцию
```

##### **3. Запрет на дублирование имен параметров функций**

В строгом режиме нельзя использовать одинаковые имена для параметров функций.

```javascript
'use strict';
function myFunc(a, a) {
  // Ошибка
  return a;
}
```

##### **4. Использование зарезервированных слов запрещено**

Некоторые ключевые слова зарезервированы для будущих версий JavaScript. В строгом режиме их нельзя использовать в качестве переменных или имен функций.

```javascript
'use strict';
let public = 10; // Ошибка: "public" зарезервировано
```

##### **5. Ограничения на `this`**

В строгом режиме значение `this` в функции, вызванной без контекста, равно `undefined`, а не глобальному объекту.

```javascript
'use strict';
function myFunc() {
  console.log(this); // undefined
}
myFunc();
```

##### **6. Запрет на запись в `read-only` свойства**

Нельзя изменять свойства объектов, которые имеют атрибут `writable: false`.

```javascript
'use strict';
const obj = Object.freeze({ name: 'John' });
obj.name = 'Doe'; // Ошибка
```

##### **7. Запрет на добавление свойств к `non-extensible` объектам**

Если объект сделан "недополняемым" с помощью `Object.preventExtensions`, то в строгом режиме нельзя добавлять новые свойства.

```javascript
'use strict';
const obj = Object.preventExtensions({ name: 'John' });
obj.age = 30; // Ошибка
```

##### **8. Устранение "тихих" ошибок**

Некоторые операции, которые в обычном режиме игнорируются или выполняются без ошибок, в строгом режиме вызывают явные ошибки.

---

#### **Преимущества использования строгого режима**

1. **Ловит ошибки на ранней стадии**: Многие потенциально проблемные операции становятся явными.
2. **Улучшает производительность**: Некоторые оптимизации могут быть выполнены, так как строгий режим устраняет "опасные" конструкции.
3. **Запрет на использование устаревших функций**: Например, `with` и `arguments.caller`.

---

#### **Ограничения строгого режима**

1. **Совместимость**: Некоторые старые браузеры могут не поддерживать строгий режим. Однако современные браузеры поддерживают его полностью.
2. **Не распространяется на встроенные скрипты**: Если скрипт вставлен через `eval`, строгий режим должен быть явно включён внутри него.

---

#### **Полный пример**

```javascript
'use strict';

function calculate(a, b) {
  // Нельзя использовать одинаковые имена параметров
  // function(a, a) {} // Ошибка

  let sum = a + b; // Переменная должна быть объявлена
  return sum;
}

try {
  undeclaredVar = 10; // Ошибка: переменная не объявлена
} catch (e) {
  console.error(e.message);
}

console.log(calculate(5, 10)); // 15
```

---

#### **Когда использовать `strict mode`**

1. **Всегда**: Включение строгого режима помогает избежать множества потенциальных ошибок.
2. **Частично**: Если нужно только для конкретных функций, чтобы не ломать старый код.

Использование строгого режима — это практика, которая повышает качество кода и облегчает отладку.

---

### **2. ES6 (2015)**

Самое значительное обновление:

- **Объявление переменных**: `let` и `const`.
- **Стрелочные функции**: Краткая запись функций.
  ```javascript
  const sum = (a, b) => a + b;
  ```
- **Шаблонные строки**: Использование ``вместо`""`или`''`.
  ```javascript
  const name = 'John';
  console.log(`Hello, ${name}!`);
  ```
- **Классы**: Синтаксический сахар для прототипов.
  ```javascript
  class Animal {
    constructor(name) {
      this.name = name;
    }
    speak() {
      console.log(`${this.name} makes a noise.`);
    }
  }
  ```
- **Модули**: `import` и `export`.
  ```javascript
  import { myFunction } from './myModule.js';
  export const myFunction = () => console.log('Hello!');
  ```

### **3. ES7 (2016)**

- Метод `Array.prototype.includes` для проверки наличия элемента.
  ```javascript
  const arr = [1, 2, 3];
  console.log(arr.includes(2)); // true
  ```
- Оператор `**` для возведения в степень.
  ```javascript
  console.log(2 ** 3); // 8
  ```

### **4. ES8 (2017)**

- Асинхронные функции: `async/await`.
  ```javascript
  async function fetchData() {
    const data = await fetch('https://api.example.com/data');
    console.log(data);
  }
  ```

### **5. ES9 (2018)**

- Оператор Rest/Spread для объектов.
  ```javascript
  const person = { name: 'John', age: 25 };
  const clone = { ...person, city: 'New York' };
  console.log(clone); // { name: 'John', age: 25, city: 'New York' }
  ```

### **6. ES10 (2019)**

- Методы для массивов: `flat`, `flatMap`.
  ```javascript
  const arr = [1, [2, 3], [4, [5]]];
  console.log(arr.flat(2)); // [1, 2, 3, 4, 5]
  ```
- `Object.fromEntries`: Преобразование массива пар в объект.
  ```javascript
  const entries = [
    ['name', 'John'],
    ['age', 30],
  ];
  console.log(Object.fromEntries(entries)); // { name: 'John', age: 30 }
  ```

### **7. ES11 (2020)**

- Оператор объединения с null (`??`).
  ```javascript
  const value = null ?? 'default';
  console.log(value); // 'default'
  ```
- Опциональная цепочка (`?.`).
  ```javascript
  const obj = { name: 'John' };
  console.log(obj?.address?.city); // undefined
  ```

---

## **Зачем нужен ECMAScript?**

1. **Единый стандарт**: Все реализации JavaScript следуют одной спецификации.
2. **Новые возможности**: Развитие языка с добавлением современных функций.
3. **Совместимость**: Старые возможности сохраняются, чтобы код оставался работоспособным.

---

## **Работа с современными стандартами**

1. **Проверка поддержки браузерами**:

   - Используйте [Can I use](https://caniuse.com/) для проверки поддержки функций ECMAScript.

2. **Использование транспилеров**:

   - **Babel** позволяет писать код с использованием современных возможностей и компилировать его для старых браузеров.

3. **Полифилы**:

   - Например, библиотека **core-js** добавляет поддержку отсутствующих функций.

---
