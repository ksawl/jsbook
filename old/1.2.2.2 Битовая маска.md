# 1.2.2.2 Битовая маска

> [Index](./0%20Index.md)
> || [1.2.2 Типы данных](./1.2.2%20Типы%20данных.md)

Вот пример использования битовой маски в JavaScript, который иллюстрирует, как числа могут представлять несколько булевых значений одновременно. Этот подход часто используется в условиях ограниченных ресурсов, хотя его читаемость и поддерживаемость уступают более современным способам работы с данными.

## **Пример: Управление состояниями с помощью битовой маски**

Представим задачу, где у нас есть несколько состояний (флаги), которые можно включать и выключать:

1. **Чтение** (`READ`)
2. **Запись** (`WRITE`)
3. **Исполнение** (`EXECUTE`)

Каждое состояние кодируется в виде отдельного бита:

- `READ` — 1-й бит (значение `1`).
- `WRITE` — 2-й бит (значение `2`).
- `EXECUTE` — 3-й бит (значение `4`).

Мы будем использовать битовые операции для управления этими состояниями.

---

## **Код**

```javascript
// Константы для битовых флагов
const READ = 1; // 001
const WRITE = 2; // 010
const EXECUTE = 4; // 100

// Пример: назначение прав пользователю
let userPermissions = 0; // Изначально никаких прав

// Добавляем права
userPermissions |= READ; // Включаем чтение
userPermissions |= WRITE; // Включаем запись

console.log(userPermissions); // 3 (001 | 010 = 011)

// Проверяем, есть ли конкретное право
const canRead = (userPermissions & READ) !== 0; // true
const canWrite = (userPermissions & WRITE) !== 0; // true
const canExecute = (userPermissions & EXECUTE) !== 0; // false

console.log(`Can read: ${canRead}`); // true
console.log(`Can write: ${canWrite}`); // true
console.log(`Can execute: ${canExecute}`); // false

// Удаляем право
userPermissions &= ~WRITE; // Убираем право записи

console.log(userPermissions); // 1 (011 & ~010 = 001)

// Проверяем права после удаления
console.log(`Can write: ${(userPermissions & WRITE) !== 0}`); // false
```

---

## **Пояснение**

1. **Добавление прав (`|=`)**:

   - Оператор `|` используется для установки бита в `1`. Например, если мы хотим включить право `WRITE`, это соответствует операции `011 | 010 = 011`.

2. **Проверка прав (`&`)**:

   - Оператор `&` проверяет, установлен ли конкретный бит. Например, `011 & 001` вернёт `001`, что означает, что право `READ` включено.

3. **Удаление прав (`&= ~`)**:
   - Оператор `~` инвертирует все биты, а затем `&=` используется для установки конкретного бита в `0`. Например, `011 & ~010` даёт `001`, убирая право `WRITE`.

---

## **Почему битовые маски считаются сложными?**

- **Читаемость**: Код с битовыми операциями часто требует времени на понимание, особенно для тех, кто не знаком с этим подходом.
- **Ошибки**: Легко допустить ошибку, например, перепутать порядок или значения битов.
- **Поддержка**: Долгосрочная поддержка такого кода может быть сложной.

---

## **Когда использовать битовые маски**

1. **Ограниченные ресурсы**: Например, если нужно сохранить несколько флагов в одном байте для экономии памяти.
2. **Производительность**: В определённых сценариях битовые операции могут быть быстрее, чем работа с объектами или массивами.
3. **Сетевые протоколы**: Передача компактных данных в сетевых сообщениях.

---

## **Современная альтернатива**

Если оптимизация не критична, можно использовать более читаемые и удобные структуры данных, такие как объекты или массивы:

```javascript
const userPermissions = {
  read: true,
  write: true,
  execute: false,
};
console.log(userPermissions.read); // true
```

Этот подход более интуитивен и легко поддерживается, но потребляет больше памяти.
