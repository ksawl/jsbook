# **1.3.2 Циклы (for, while, do...while).**

> [Index](./0%20Index.md)
> || [1.3 Управляющие конструкции](./1.3%20Управляющие%20конструкции.md)

При написании скриптов зачастую встаёт задача сделать однотипное действие много раз.

Например, вывести товары из списка один за другим. Или просто перебрать все числа от 1 до 10 и для каждого выполнить одинаковый код.

Для многократного повторения одного участка кода предусмотрены циклы.

> [!NOTE]
>
> Кроме рассмотренных в данном разделе циклов существуют еще циклы
>
> -   `for…in` для перебора свойств объекта.
> -   `for…of` Перебираемые объекты для перебора массивов и перебираемых объектов.
>
> их мы рассмотрим позже

## `for`

Цикл `for` используется для выполнения блока кода определенное количество раз.
Более сложный, но при этом самый распространённый цикл — цикл for.

Выглядит он так:

```js
for (начало; условие; шаг) {
    // ... тело цикла ...
}
```

**Пример:**

```javascript
for (let i = 0; i < 3; i++) {
    // выведет 0, затем 1, затем 2
    alert(i);
}
```

**Рассмотрим конструкцию `for` подробней:**

| часть   | Действие  | Комментарий                                                                                |
| ------- | --------- | ------------------------------------------------------------------------------------------ |
| начало  | let i = 0 | Выполняется один раз при входе в цикл                                                      |
| условие | i < 3     | Проверяется перед каждой итерацией цикла. Если оно вычислится в `false`, цикл остановится. |
| тело    | alert(i)  | Выполняется снова и снова, пока условие вычисляется в `true`.                              |
| шаг     | i++       | Выполняется после тела цикла на каждой итерации перед проверкой условия.                   |

В целом, алгоритм работы цикла выглядит следующим образом:

```plaintext
Выполнить начало
→ (Если условие == true → Выполнить тело, Выполнить шаг)
→ (Если условие == true → Выполнить тело, Выполнить шаг)
→ (Если условие == true → Выполнить тело, Выполнить шаг)
→ ...
```

То есть, `начало` выполняется один раз, а затем каждая итерация заключается в проверке `условия`, после которой выполняется `тело` и `шаг`.

Если тема циклов для вас нова, может быть полезным вернуться к примеру выше и воспроизвести его работу на листе бумаги, шаг за шагом.

Вот в точности то, что происходит в нашем случае:

```js
// for (let i = 0; i < 3; i++) alert(i)

// Выполнить начало
let i = 0;
// Если условие == true → Выполнить тело, Выполнить шаг
if (i < 3) {
    alert(i);
    i++;
}
// Если условие == true → Выполнить тело, Выполнить шаг
if (i < 3) {
    alert(i);
    i++;
}
// Если условие == true → Выполнить тело, Выполнить шаг
if (i < 3) {
    alert(i);
    i++;
}
// ...конец, потому что теперь i == 3
```

> [!TIP]
>
> **Встроенное объявление переменной**
> В примере переменная счётчика `i` была объявлена прямо в цикле. Это так называемое «встроенное» объявление переменной. Такие переменные существуют только внутри цикла.
>
> ```js
> for (let i = 0; i < 3; i++) {
>     alert(i); // 0, 1, 2
> }
>
> alert(i); // ошибка, нет такой переменной
> ```
>
> Вместо объявления новой переменной мы можем использовать уже существующую:
>
> ```js
> let i = 0;
>
> for (i = 0; i < 3; i++) {
>     // используем существующую переменную
>     alert(i); // 0, 1, 2
> }
>
> alert(i); // 3, переменная доступна, т.к. была объявлена снаружи цикла
> ```

### Пропуск частей «for»

Любая часть `for` может быть пропущена.

Для примера, мы можем пропустить начало если нам ничего не нужно делать перед стартом цикла.

Вот так:

```js
let i = 0; // мы уже имеем объявленную i с присвоенным значением

for (; i < 3; i++) {
    // нет необходимости в "начале"
    alert(i); // 0, 1, 2
}
```

Можно убрать и шаг:

```js
let i = 0;

for (; i < 3; ) {
    alert(i++);
}
```

Это сделает цикл аналогичным `while (i < 3)`.

А можно и вообще убрать всё, получив бесконечный цикл:

```js
for (;;) {
    // будет выполняться вечно
}
```

При этом сами точки с запятой `;` обязательно должны присутствовать, иначе будет ошибка синтаксиса.

## `while`

Цикл `while` выполняет блок кода, пока условие истинно (`true`).

**Пример:**

```javascript
let i = 0;
while (i < 5) {
    console.log(i);
    i++;
}
```

Одно выполнение тела цикла по-научному называется итерация. Цикл в примере выше совершает пять итераций.

Если бы строка `i++` отсутствовала в примере выше, то цикл бы повторялся (в теории) вечно. На практике, конечно, браузер не позволит такому случиться, он предоставит пользователю возможность остановить «подвисший» скрипт, а JavaScript на стороне сервера придётся «убить» процесс.

Любое выражение или переменная может быть условием цикла, а не только сравнение: условие `while` вычисляется и преобразуется в логическое значение.

Например, `while (i)` – более краткий вариант `while (i != 0)`:

```js
let i = 3;
while (i) {
    // когда i будет равно 0, условие станет ложным, и цикл остановится
    alert(i);
    i--;
}
```

Фигурные скобки не требуются для тела цикла из одной строки
Если тело цикла состоит лишь из одной инструкции, мы можем опустить фигурные скобки `{…}`:

```js
let i = 3;
while (i) alert(i--);
```

## `do while`

Цикл `do while` выполняет блок кода хотя бы один раз, а затем продолжает выполнение, пока условие истинно (`true`).

```js
do {
    // тело цикла
} while (condition);
```

Цикл сначала выполнит тело, а затем проверит условие `condition`, и пока его значение равно `true`, он будет выполняться снова и снова.

**Пример:**

```javascript
let i = 0;
do {
    console.log(i);
    i++;
} while (i < 5);
```

> [!NOTE]
>
> Такая форма синтаксиса оправдана, если вы хотите, чтобы тело цикла выполнилось хотя бы один раз, даже если условие окажется ложным. На практике чаще используется форма с предусловием: `while(…) {…}`.

**Практический пример**

```js
let age;
let isFirstRun = true;

do {
    const message = isFirstRun
        ? 'Введите ваш возраст'
        : 'Введите корректное значение вашего возраста';
    age = +prompt(message, '');
    isFirstRun = false;
} while (!age || age < 0 || age > 100);

alert(`Ваш возраст ${age} лет`);
```

Приглашение `prompt` будет выводиться до тех пор, пока пользователь не введет корректные значения. Но этот пример будет так же работать и в конструкции с `while`.

```js
let age;
let isFirstRun = true;

while (!age || age < 0 || age > 100) {
    const message = isFirstRun
        ? 'Введите ваш возраст'
        : 'Введите корректное значение вашего возраста';
    age = +prompt(message, '');
    isFirstRun = false;
}

alert(`Ваш возраст ${age} лет`);
```

## Управляющие операторы в циклах

### `break`

Оператор `break` используется для выхода из цикла преждевременно. Обычно цикл завершается при вычислении условия в `false`.

Но мы можем выйти из цикла в любой момент с помощью специальной директивы `break`.

**Пример:**

```javascript
for (let i = 0; i < 10; i++) {
    if (i === 5) {
        break; // Выход из цикла
    }
    console.log(i); // Выводит числа от 0 до 4
}

let sum = 0;

while (true) {
    let value = +prompt('Введите число', '');

    if (!value) break; // (*)

    sum += value;
}
alert('Сумма: ' + sum);
```

Директива `break` полностью прекращает выполнение цикла и передаёт управление на строку за его телом.

> [!TIP]
>
> Вообще, сочетание «бесконечный цикл + `break»` – отличная штука для тех ситуаций, когда условие, по которому нужно прерваться, находится не в начале или конце цикла, а посередине или даже в нескольких местах его тела.

### `continue`

Директива `continue` – «облегчённая версия» `break`, пропускает текущую итерацию цикла и переходит к следующей. При её выполнении цикл не прерывается, а переходит к следующей итерации (если условие все ещё равно `true`).

Её используют, если понятно, что на текущем повторе цикла делать больше нечего.

**Пример:**

```javascript
for (let i = 0; i < 10; i++) {
    // если true, пропустить оставшуюся часть тела цикла
    if (i % 2 == 0) continue;

    alert(i); // 1, затем 3, 5, 7, 9
}
```

Для чётных значений `i`, директива `continue` прекращает выполнение тела цикла и передаёт управление на следующую итерацию `for` (со следующим числом). Таким образом `alert` вызывается только для нечётных значений.

> [!NOTE]
>
> **Директива `continue` позволяет избегать вложенности**
> Цикл, который обрабатывает только нечётные значения, мог бы выглядеть так:
>
> ```js
> for (let i = 0; i < 10; i++) {
>     if (i % 2) {
>         alert(i);
>     }
> }
> ```
>
> С технической точки зрения он полностью идентичен. Действительно, вместо `continue` можно просто завернуть действия в блок `if`.
>
> Однако мы получили дополнительный уровень вложенности фигурных скобок. Если код внутри `if` более длинный, то это ухудшает читаемость, в отличие от варианта с `continue`.

> [!WARNING]
>
> **Нельзя использовать `break/continue` справа от оператора „?“**
> Обратите внимание, что эти синтаксические конструкции не являются выражениями и не могут быть использованы с тернарным оператором `?`. В частности, использование таких директив, как `break/continue`, вызовет ошибку.
>
> Например, если мы возьмём этот код:
>
> ```js
> while (true) {
>     if (i > 5) {
>         alert(i);
>     } else {
>         continue;
>     }
> }
> ```
>
> …и перепишем его, используя вопросительный знак:
>
> ```js
> while (true) {
>     (i > 5) ? alert(i) : continue; // continue здесь приведёт к ошибке
> }
> ```
>
> …то будет синтаксическая ошибка.
>
> Это ещё один повод не использовать оператор вопросительного знака `?` вместо `if`.

### Метки для break/continue

Бывает, нужно выйти одновременно из нескольких уровней цикла сразу.

Например, в коде ниже мы проходимся циклами по `i` и `j`, запрашивая с помощью `prompt` координаты `(i, j)` с `(0,0)` до `(2,2)`:

```js
for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
        let input = prompt(`Значение на координатах (${i},${j})`, '');

        // Что если мы захотим перейти к Готово (ниже) прямо отсюда?
    }
}

alert('Готово!');
```

Нам нужен способ остановить выполнение, если пользователь отменит ввод.

Обычный `break` после `input` лишь прервёт внутренний цикл, но этого недостаточно. Достичь желаемого поведения можно с помощью меток.

Метка имеет вид идентификатора с двоеточием перед циклом:

```js
labelName: for (...) {
...
}
```

Вызов `break <labelName>` в цикле ниже ищет ближайший внешний цикл с такой меткой и переходит в его конец.

```js
outer: for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
        let input = prompt(`Значение на координатах (${i},${j})`, '');

        // если пустая строка или Отмена, то выйти из обоих циклов
        if (!input) break outer; // (*)

        // сделать что-нибудь со значениями...
    }
}

alert('Готово!');
```

В примере выше это означает, что вызовом `break outer` будет разорван внешний цикл до метки с именем `outer`.

Таким образом управление перейдёт со строки, помеченной `(*)`, к `alert('Готово!')`.

Можно размещать метку на отдельной строке:

```js
outer:
for (let i = 0; i < 3; i++) { ... }
```

Директива `continue` также может быть использована с меткой. В этом случае управление перейдёт на следующую итерацию цикла с меткой.

> [!WARNING]
>
> **Метки не позволяют «прыгнуть» куда угодно**
> Метки не дают возможности передавать управление в произвольное место кода.
>
> Например, нет возможности сделать следующее:
>
> ```js
> break label; // не прыгает к метке ниже
>
> label: for (...)
> ```
>
> Директива `break` должна находиться внутри блока кода. Технически, подойдет любой маркированный блок кода, например:
>
> ```js
> label: {
>     // ...
>     break label; // работает
>     // ...
> }
> ```
>
> …Хотя в 99.9% случаев `break` используется внутри циклов, как мы видели в примерах выше.
>
> К слову, `continue` возможно только внутри цикла.

## Задачи

### 1. Последнее значение цикла

Какое последнее значение выведет этот код? Почему?

```js
let i = 3;

while (i) {
    alert(i--);
}
```

### 2. Какие значения выведет цикл while?

Для каждого цикла запишите, какие значения он выведет. Потом сравните с ответом.

Оба цикла выводят `alert` с одинаковыми значениями или нет?

Префиксный вариант `++i`:

```js
let i = 0;
while (++i < 5) alert(i);
```

Постфиксный вариант `i++`

```js
let i = 0;
while (i++ < 5) alert(i);
```

### 3. Какие значения выведет цикл for?

Для каждого цикла запишите, какие значения он выведет. Потом сравните с ответом.

Оба цикла выведут `alert` с одинаковыми значениями или нет?

Постфиксная форма:

```js
for (let i = 0; i < 5; i++) alert(i);
```

Префиксная форма:

```js
for (let i = 0; i < 5; ++i) alert(i);
```

### 4. Выведите чётные числа

При помощи цикла for выведите чётные числа от 2 до 10.

### 5. Замените for на while

Перепишите код, заменив цикл `for` на `while`, без изменения поведения цикла.

```js
for (let i = 0; i < 3; i++) {
    alert(`number ${i}!`);
}
```

### 6. Повторять цикл, пока ввод неверен

Напишите цикл, который предлагает `prompt` ввести число, большее `100`. Если посетитель ввёл другое число – попросить ввести ещё раз, и так далее.

Цикл должен спрашивать число пока либо посетитель не введёт число, большее `100`, либо не нажмёт кнопку `Отмена (ESC)`.

Предполагается, что посетитель вводит только числа. Предусматривать обработку нечисловых строк в этой задаче необязательно.

### 7. Вывести простые числа

Натуральное число, большее `1`, называется простым, если оно ни на что не делится, кроме себя и `1`.

Другими словами, `n > 1` – простое, если при его делении на любое число кроме `1` и `n` есть остаток.

Например, `5` это простое число, оно не может быть разделено без остатка на `2`, `3` и `4`.

Напишите код, который выводит все простые числа из интервала от `2` до `n`.

Для `n = 10` результат должен быть `2,3,5,7`.

P.S. Код также должен легко модифицироваться для любых других интервалов.
