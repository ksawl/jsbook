# **1.2.2. Типы данных в JavaScript**

> [Index](./0%20Index.md)
> || [1.2.2.1 Методы Number](./1.2.2.1%20Методы%20Number.md)
> || [1.2.2.2 Битовая маска](./1.2.2.2%20Битовая%20маска.md)
> || [1.2.2.3 Методы String](./1.2.2.3%20Методы%20String.md)

JavaScript является *слабо типизированным* или *динамическим* языком. Это значит, что вам не нужно определять тип переменной заранее. Тип определится автоматически во время выполнения программы. Также это значит, что вы можете использовать одну переменную для хранения данных различных типов.

```js
var foo = 42; // сейчас foo типа Number
foo = 'bar'; // а теперь foo типа String
foo = true; // foo становится типа Boolean
```

## Стандарт ECMAScript определяет 8 типов:

- 6 типов данных являющихся примитивами:
  - [Number](https://developer.mozilla.org/ru/docs/Glossary/Number) (Число) : `typeof instance === "number"`
  - [String](https://developer.mozilla.org/ru/docs/Glossary/String) (Строка) : `typeof instance === "string"`
  - [Boolean](https://developer.mozilla.org/ru/docs/Glossary/Boolean) (Булев, Логический тип) : `typeof instance === "boolean"`
  - [Undefined](https://developer.mozilla.org/ru/docs/Glossary/Undefined) (Неопределённый тип) : `typeof instance === "undefined"`
  - [Symbol](https://developer.mozilla.org/en-US/docs/Glossary/Symbol) (в ECMAScript 6) : `typeof instance === "symbol"`
  - [BigInt](https://developer.mozilla.org/ru/docs/Glossary/BigInt) : `typeof instance === "bigint"`
- [Null](https://developer.mozilla.org/ru/docs/Glossary/Null) (Null тип ) : `typeof instance === "object"`. Специальный примитив, используемый не только для данных но и в качестве указателя на финальную точку в [Цепочке Прототипов](https://developer.mozilla.org/ru/docs/Web/JavaScript/Inheritance_and_the_prototype_chain);
- [Object](https://developer.mozilla.org/ru/docs/Glossary/Object) (Объект) : `typeof instance === "object"`. Простая структура, используемая не только для хранения данных, но и для создания других структур, где любая структура создаётся с использованием ключевого слова [`new`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/new): new [Object](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object), new [Array](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array), new [Map](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Map), new [Set](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Set), new [WeakMap](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakMap), new [WeakSet](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakSet), new [Date](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date) и множество других структур;

> [!IMPORTANT]
> Все типы данных в JavaScript, кроме объектов, являются иммутабельными (значения не могут быть модифицированы, а только перезаписаны новым полным значением). Например, в отличии от C, где строку можно посимвольно корректировать, в JavaScript строки пересоздаются только полностью. Значения таких типов называются «примитивными значениями».

## Проверка типа структур

Необходимо сделать предостережение относительно использования оператора `typeof` для определения типа структур, т.к. все структуры будут возвращать `"object"` при его использовании, так как назначение `typeof` — проверка типа данных, но не структур. Если проверить тип структуры всё же необходимо, то в этом случае желательно использовать оператор [instanceof](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/instanceof), так как именно он отвечает на вопрос о том, какой конструктор был использован для создания структуры.

Стоит отметить два особых случая работы оператора `typeof`: возврат `"object"` для значения `null` и `"function"` для функций: первое принято считать ошибкой языка, сохраненной ради обратной совместимости, второе является условностью, удобной для проверки на принадлежность значения категории функций, где функция - это особый, "вызываемый", объект.

```javascript
let number = 42; // Число
let text = 'Hello, world!'; // Строка
let isOnline = true; // Логическое значение
let notAssigned; // undefined
let empty = null; // null

console.log(typeof number); // Выведет: number
console.log(typeof text); // Выведет: string
console.log(typeof isOnline); // Выведет: boolean
console.log(typeof notAssigned); // Выведет: undefined
console.log(typeof empty); // Выведет: object (особенность языка)
```

Чаще всего операторы и функции автоматически приводят переданные им значения к нужному типу.

Например, `alert` автоматически преобразует любое значение к строке. Математические операторы преобразуют значения к числам.

Есть также случаи, когда нам нужно явно преобразовать значение в ожидаемый тип.

---

## **1. Числа (Number)**

Числа в JavaScript представлены одним типом, включая целые и дробные значения. В соответствии со стандартом ECMAScript, существует только один числовой тип, который представляет собой [64-битное число двойной точности согласно стандарту IEEE 754](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%BE_%D0%B4%D0%B2%D0%BE%D0%B9%D0%BD%D0%BE%D0%B9_%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D0%B8). Другими словами, **специального типа для целых чисел в JavaScript нет**. Это означает, что при числовых операциях вы можете получить неточное (округлённое) значение. В дополнение к возможности представлять числа с плавающей запятой, есть несколько символических значений: `+Infinity` (положительная бесконечность), `-Infinity` (отрицательная бесконечность), и `NaN` (не число).

В JavaScript тип `number` не может безопасно работать с числами, большими, чем `(2**53-1)` (т. е. `9007199254740991`) или меньшими, чем `-(2**53-1)` для отрицательных чисел.

Если говорить совсем точно, то, технически, тип number может хранить большие целые числа `(до 1.7976931348623157 * 10**308)`, но за пределами безопасного диапазона целых чисел `±(2**53-1)` будет ошибка точности, так как не все цифры помещаются в фиксированную 64-битную память. Поэтому можно хранить «приблизительное» значение.

Например, эти два числа (прямо за пределами безопасного диапазона) совпадают:

```js
console.log(9007199254740991 + 1); // 9007199254740992
console.log(9007199254740991 + 2); // 9007199254740992
```

То есть все нечетные целые числа, большие чем `(2**53-1)`, вообще не могут храниться в типе `number`.

В большинстве случаев безопасного диапазона чисел от `-(2**53-1)` до `(2**53-1)` вполне достаточно, но иногда нам требуется весь диапазон действительно гигантских целых чисел без каких-либо ограничений или пропущенных значений внутри него. Например, в криптографии или при использовании метки времени (`«timestamp»`) с микросекундами.

> [!CAUTION]
> Хотя число в большинстве случаев представляет только своё значение, JavaScript предоставляет [несколько бинарных операций](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators). Они могут использоваться для того, чтобы представлять число как несколько булевых значений, с помощью [битовой маски](https://ru.wikipedia.org/wiki/%D0%91%D0%B8%D1%82%D0%BE%D0%B2%D0%B0%D1%8F_%D0%BC%D0%B0%D1%81%D0%BA%D0%B0). Это считается плохой практикой, так как JavaScript предлагает другие способы представления булевых значений (например, массив элементов с булевыми значениями или объект, содержащий набор булевых свойств). Кроме того, битовые маски часто делают код более трудным для чтения, понимания и дальнейшей поддержки. Эта техника может быть необходима в условиях технических ограничений, таких как объём локального хранилища данных, или в такой экстремальной ситуации, когда каждый бит передаваемый по сети на счету. Данный подход следует использовать как крайнюю меру, когда не остаётся других путей для необходимой оптимизации.
>
> Подробное объяснение с примерами [1.2.2.2 Битовая маска](./1.2.2.2%20Битовая%20маска.md)

### **Особенности:**

- Поддержка операций: `+`, `-`, `*`, `/`, `%`, `**`.
- Математические операции в JavaScript «безопасны». Мы можем делать что угодно: делить на ноль, обращаться с нечисловыми строками как с числами и т.д. Скрипт никогда не остановится с фатальной ошибкой (не «умрёт»). В худшем случае мы получим `NaN` как результат выполнения.
- Специальные значения:
  - `NaN` (Not a Number) — результат недопустимой операции.
  - `Infinity` и `-Infinity` — бесконечности.
- Методы: `.parseInt()`, `.parseFloat()`, `.isNaN()`, `.isInteger()`, `.toFixed()`
- Ноль в JavaScript имеет два представления: -0 и +0. («0» это синоним +0). На практике это имеет малозаметный эффект. Например, выражение `+0 === -0` является истинным. Однако, это может проявиться при делении на ноль:

```js
let a = 42 / +0; // Infinity
let b = 42 / -0; // -Infinity
```

### **Примеры:**

```javascript
let a = 10; // Целое число
let b = 3.14; // Дробное число
let c = 1 / 0; // Infinity
let d = 'hello' * 2; // NaN
let e = 5 % 3; // 2

console.log(typeof a); // "number"
console.log(c); // Infinity
console.log(d); // NaN
console.log(e); // 2
```

### Приведение типов

Явное преобразование часто применяется, когда мы ожидаем получить число из строкового контекста, например из текстовых полей форм.
Если строка не может быть явно приведена к числу, то результатом преобразования будет `NaN`.

| value          | result                                                                                                                                                                                                                                  |
| -------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `undefined`    | `NaN`                                                                                                                                                                                                                                   |
| `null`         | `0`                                                                                                                                                                                                                                     |
| `true / false` | `1` / `0`                                                                                                                                                                                                                               |
| `string`       | Пробельные символы (пробелы, знаки табуляции `\t`, знаки новой строки `\n` и т. п.) по краям обрезаются. Далее, если остаётся пустая строка, то получаем `0`, иначе из непустой строки «считывается» число. При ошибке результат `NaN`. |

- Используйте `Number(value)`, унарный `+`, или методы парсинга (`parseInt`, `parseFloat`).
- Численное преобразование происходит в математических функциях и выражениях. Например, когда операция деления `/` применяется не к числу

```javascript
let str = '123';
console.log(Number(str)); // 123
console.log(+str); // 123
console.log(parseInt('123px')); // 123

let str = 'Любая строка вместо цифр';
console.log(Number(str)); // NaN

console.log('6' / '2'); // 3, строки преобразуются в числа
```

### **`NaN` (Not-a-Number)**

#### **Описание:**

`NaN` — это результат недопустимых арифметических операций, таких как деление строки на число или применение математических функций к недопустимым данным.

#### **Особенности:**

1. **Тип:**  
   `NaN` принадлежит к типу `number`.

   ```javascript
   console.log(typeof NaN); // "number"
   ```

2. **Уникальность:**  
   `NaN` не равен самому себе. Это значит, что проверка `NaN === NaN` возвращает `false`.

   ```javascript
   console.log(NaN == NaN); // false
   console.log(NaN === NaN); // false
   ```

3. **Проверка на `NaN`:**  
   Для проверки используйте функцию `isNaN()` или `Number.isNaN()`.

   - `isNaN()`: преобразует аргумент в число перед проверкой.
   - `Number.isNaN()`: проверяет только значения, которые изначально равны `NaN`.

4. **`NaN` влияет на результат**
   Если где-то в математическом выражении есть `NaN`, то оно распространяется на весь результат (есть только одно исключение: `NaN ** 0 === 1`).

#### **Примеры:**

```javascript
console.log('hello' * 2); // NaN
console.log(0 / 0); // NaN
console.log(Math.sqrt(-1)); // возвращает квадратный корень числа, если число < 0, то NaN
console.log(isNaN('hello')); // true (строка преобразована)
console.log(Number.isNaN('hello')); // false (без преобразования)
```

---

### **`Infinity` и `-Infinity`**

#### **Описание:**

`Infinity` и `-Infinity` представляют положительную и отрицательную бесконечность. Они возникают, когда число выходит за пределы допустимого диапазона или в результате операций, которые не имеют конечного значения.

#### **Особенности:**

1. **Тип:**  
   `Infinity` также принадлежит к типу `number`.

   ```javascript
   console.log(typeof Infinity); // "number"
   ```

2. **Предельные значения:**
   Для получения самого большого или самого меньшего доступного значения в пределах `+/-Infinity`, можно использовать константы [`Number.MAX_VALUE`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_VALUE) или [`Number.MIN_VALUE`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_VALUE). А начиная с ECMAScript 2015, вы также можете проверить, находится ли число в безопасном для целых чисел диапазоне, используя метод [`Number.isSafeInteger()`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger), либо константы [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER) и [`Number.MIN_SAFE_INTEGER`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_SAFE_INTEGER). За пределами этого диапазона операции с целыми числами будут небезопасными, и возвращать приближённые значения.
3. **Арифметические операции:**

   - Любое число, умноженное на `Infinity`, остаётся бесконечным.
   - Деление числа на `Infinity` даёт `0`.

   ```javascript
   console.log(1 / Infinity); // 0
   console.log(Infinity * 2); // Infinity
   ```

4. **Проверка на бесконечность:**  
   Используйте метод `isFinite()` или прямое сравнение.

   ```javascript
   console.log(isFinite(Infinity)); // false
   console.log(isFinite(42)); // true
   ```

#### **Примеры:**

```javascript
console.log(1 / 0); // Infinity
console.log(-1 / 0); // -Infinity
console.log(Number.MAX_VALUE * 2); // Infinity
console.log(-Number.MAX_VALUE * 2); // -Infinity
console.log(Infinity - Infinity); // NaN
```

---

### **Сравнение `NaN` и `Infinity`**

| Особенность        | `NaN`                                 | `Infinity`                                  |
| ------------------ | ------------------------------------- | ------------------------------------------- |
| **Тип**            | `number`                              | `number`                                    |
| **Возникает при:** | Недопустимых математических операциях | Делении на ноль или переполнении            |
| **Равенство**      | Не равен самому себе (`NaN !== NaN`)  | Равен самому себе (`Infinity === Infinity`) |
| **Проверка**       | `isNaN()` или `Number.isNaN()`        | `isFinite()` для проверки конечности        |
| **Особенности**    | Распространённый источник ошибок      | Часто используется в вычислениях            |

---

### **Практическое использование и обработка**

#### **Работа с `NaN`:**

1. Проверяйте ввод пользователя:

   ```javascript
   let input = 'abc';
   let result = parseInt(input);
   if (isNaN(result)) {
     console.log('Недопустимое значение!');
   }
   ```

2. Избегайте использования `==` для проверки, используйте `isNaN()`:

   ```javascript
   console.log(NaN == NaN); // false
   console.log(isNaN(NaN)); // true
   ```

#### **Работа с `Infinity`:**

1. Используйте проверки на конечность:

   ```javascript
   let largeNumber = 1e309; // больше, чем максимальное число
   console.log(isFinite(largeNumber)); // false
   ```

2. Обрабатывайте деление на ноль:

   ```javascript
   let num = 5;
   let divisor = 0;
   if (divisor === 0) {
     console.log('Ошибка: деление на ноль!');
   } else {
     console.log(num / divisor);
   }
   ```

---

## **2. Строки (String)**

В JavaScript любые текстовые данные являются строками. Не существует отдельного типа «символ», который есть в ряде других языков.

Внутренний формат для строк — всегда `UTF-16`, вне зависимости от кодировки страницы.

Строки — последовательность символов, заключенная в одинарные `' '`, двойные `" "`, или обратные кавычки `` `  ` ``.

В JavaScript для представления текстовых данных служит тип [`String`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String). Он представляет собой цепочку «элементов» 16-битных беззнаковых целочисленных значений. Каждый такой элемент занимает свою позицию в строке. Первый элемент имеет индекс 0, следующий — 1, и так далее. Длина строки — это количество элементов в ней.

В отличие от языков подобных C, строки в JavaScript являются иммутабельными. Это означает, что после того, как строковое значение создано, его нельзя модифицировать. Нельзя взять символ посередине и заменить его. Как только строка создана — она такая навсегда. Остаётся лишь создать новую строку путём совершения некой операции над исходной строкой.

```js
let str = 'Hi';

str[0] = 'h'; // ошибка
alert(str[0]); // не работает
```

> [!WARNING]
> Используйте строки только для текстовых данных. Для составных структур преобразуйте строки в подобающие конструкции.

### **Особенности:**

- Конкатенация через `+` или шаблонные строки.
- Получить часть исходной строки выборкой отдельных символов, либо применением метода [`String.substr()`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/substr).
- Объединить две строки в одну, применив оператор (`+`) или метод [`String.concat()`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/concat).
- Методы: `.length`, `.toUpperCase()`, `.toLowerCase()`, `.includes()`, `.slice()`.

### **Примеры:**

```javascript
let single = 'Hello';
let double = 'World';
let template = `Привет, ${single} ${double}!`;

alert(`результат: ${1 + 2}`); // результат: 3
console.log(template); // Привет, Hello World!
console.log(single.length); // 5
console.log(single.toUpperCase()); // HELLO
```

Ещё одно преимущество обратных кавычек — они могут занимать более одной строки, вот так:

```js
let guestList = `Guests:
 * John
 * Pete
 * Mary
`;

alert(guestList); // список гостей, состоящий из нескольких строк
```

Многострочные строки также можно создавать с помощью одинарных и двойных кавычек, используя так называемый «символ перевода строки», который записывается как `\n`:

```js
let guestList = 'Guests:\n * John\n * Pete\n * Mary';

alert(guestList); // список гостей, состоящий из нескольких строк
```

Есть и другие, реже используемые спецсимволы. Вот список:

| Символ        | Описание                                                                                                                                                                                                |
| ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| \n            | Перевод строки                                                                                                                                                                                          |
| \r            | В текстовых файлах Windows для перевода строки используется комбинация символов `\r\n`, а на других ОС это просто `\n`. Это так по историческим причинам, ПО под Windows обычно понимает и просто `\n`. |
| \\', \\", \\` | Кавычки                                                                                                                                                                                                 |
| \\\           | Обратный слеш                                                                                                                                                                                           |
| \t            | Знак табуляции                                                                                                                                                                                          |
| \b, \f, \v    | Backspace, Form Feed и Vertical Tab — оставлены для обратной совместимости, сейчас не используются.                                                                                                     |

Как вы можете видеть, все спецсимволы начинаются с обратного слеша, `\` — так называемого «символа экранирования».

Он также используется, если необходимо вставить в строку кавычку.

К примеру:

```
alert('I\'m the Walrus!'); // I'm the Walrus!
alert("Say \"Hello\""); // Say "Hello"
```

но более красивый вариант использовать в таком случае разнородные кавычки

```js
alert("I'm the Walrus!"); // I'm the Walrus!
alert('Say "Hello"'); // Say "Hello"
```

### Приведение типов

- Используйте метод `String(value)` или конкатенацию с пустой строкой.

```javascript
let num = 123;
console.log(String(num)); // "123"
console.log(num + ''); // "123"

let value = true;
console.log(typeof value); // boolean
value = String(value); // теперь value это строка "true
console.log(typeof value); // string
```

### **Получение части строки**

В JavaScript получение части строки или выборка отдельных символов может быть выполнена несколькими способами. Рассмотрим их подробнее с примерами.

#### **1. Использование метода `charAt`**

Метод возвращает символ по указанному индексу строки.

```javascript
const str = 'JavaScript';
const char = str.charAt(4); // Индексация начинается с 0
console.log(char); // "S"
```

---

#### **2. Использование метода `at`**

Получить символ, который занимает позицию `pos` можно используя метод `str.at(pos)`. Первый символ занимает нулевую позицию.

```js
let str = `Hello`;

// получаем первый символ
alert(str.at(0)); // H

// получаем последний символ
alert(str.at(-1)); // o
```

Как вы можете видеть, преимущество метода `.at(pos)` заключается в том, что он допускает отрицательную позицию. Если `pos` – отрицательное число, то отсчет ведется от конца строки.

Таким образом, `.at(-1)` означает последний символ, а `.at(-2)` – тот, что перед ним, и т.д.

#### **3. Обращение к строке как к массиву**

В современных версиях JavaScript можно использовать синтаксис квадратных скобок для доступа к символу. Квадратные скобки всегда возвращают undefined для отрицательных индексов.

```javascript
const str = 'JavaScript';
const char = str[4];
alert(str[-2]); // undefined
console.log(char); // "S"
```

---

#### **4. Извлечение подстроки с помощью `substring`**

Метод возвращает подстроку между двумя индексами.

```javascript
const str = 'JavaScript';
const substr = str.substring(4, 10); // Индекс начала включается, а конец — нет
console.log(substr); // "Script"
```

---

#### **5. Использование метода `substr` (устарел)**

Метод возвращает часть строки, начиная с указанного индекса и заданной длины. Этот метод устарел, но всё ещё работает.

```javascript
const str = 'JavaScript';
const substr = str.substr(4, 6); // Начинаем с индекса 4 и берём 6 символов
console.log(substr); // "Script"
```

---

#### **6. Извлечение с помощью `slice`**

Метод похож на `substring`, но поддерживает отрицательные индексы.

```javascript
const str = 'JavaScript';
const substr = str.slice(4, -1); // С 4-го символа до предпоследнего
console.log(substr); // "Scrip"
```

---

#### **7. Доступ к последнему символу строки**

Для получения последнего символа можно использовать длину строки.

```javascript
const str = 'JavaScript';
const lastChar = str[str.length - 1];
console.log(lastChar); // "t"
```

---

#### **8. Получение нескольких символов с помощью `split`**

Если нужно получить массив символов, можно использовать `split`.

```javascript
const str = 'JavaScript';
const chars = str.split(''); // Разбиваем строку на массив символов
console.log(chars[4]); // "S"
console.log(chars); // ["J", "a", "v", "a", "S", "c", "r", "i", "p", "t"]
```

---

#### **9. Получение символов с помощью `for..of`**

Также можно перебрать строку посимвольно, используя `for..of`:

```js
for (let char of 'Hello') {
  alert(char); // H,e,l,l,o (char — сначала "H", потом "e", потом "l" и т.д.)
}
```

---

#### **Итог**

Выбор способа зависит от ваших потребностей:

- Для извлечения отдельного символа: `charAt` или `[]`.
- Для извлечения подстроки: `substring`, `slice` или (в редких случаях) `substr`.
- Для работы с массивами символов: `split`.

---

## **3. Логический тип (Boolean)**

Логическое (или булевое) значение - это примитивный тип данных, который может содержать в себе `true` или `false` (истина или ложь). JavaScript использует приведение типа, чтобы привести значение к `true\false`. Есть явные и скрытые методы преобразования значений в их логические аналоги.

```js
let nameFieldChecked = true; // да, поле отмечено
let ageFieldChecked = false; // нет, поле не отмечено
```

Булевые значения также могут быть результатом сравнений:

```js
let isGreater = 4 > 1;

alert(isGreater); // true (результатом сравнения будет "да")
```

### **Используется:**

- В условиях (`if`, `while`).
- В логических операциях (`&&`, `||`, `!`).

### Приведение типов

- `Boolean()` - это глобальная функция, которая конвертирует значение, переданное в него, в логическое. Не стоит использовать его с ключевым словом `new` (`new Boolean`), т.к. это создает сущность Boolean, которая является объектом.
- Двойное отрицание при помощи оператора `!`. Двойной оператор `!!` действует следующим образом: первый знак `!` приводит значение к логическому и инвертирует его. Например, `!true` равняется `false`. Второй оператор `!` снова инвертирует полученное значение. В нашем примере `!false` приравнивается к `true`.

Значения, приводимые к `false`: `false`, `0`, `""`, `null`, `undefined`, `NaN`. Всё остальное — `true`.

```js
// False
Boolean(false); // false
Boolean(undefined); // false
Boolean(null); // false
Boolean(!!null); // false
Boolean(''); // false
Boolean(NaN); // false
Boolean(0); // false
Boolean(-0); // false
Boolean(0n); // false
// True
Boolean(true); // true
Boolean('hi'); // true
Boolean(1); // true
Boolean([]); // true
Boolean([0]); // true
Boolean([1]); // true
Boolean({}); // true
Boolean({ a: 1 }); // true
```

### **Примеры:**

```javascript
let isOnline = true;
let hasAccess = false;

console.log(isOnline && hasAccess); // false
console.log(isOnline || hasAccess); // true
console.log(!isOnline); // false
```

---

## **4. `null`**

Специальное значение, которое указывает на "ничто" или "пустое место" или «значение неизвестно». Оно формирует отдельный тип, который содержит только значение `null`.

В JavaScript `null` не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках.

### **Особенности:**

- Присваивается вручную, чтобы показать отсутствие значения.
- Все JavaScript-программисты давно привыкли к тому, что `typeof null === 'object'; // true`, хотя фактически null — примитивное значение. Многие знают, что это баг, и лично Брэндан Айк это [признает](http://wiki.ecmascript.org/doku.php?id=harmony:typeof_null). Этот баг, вероятно, никогда не будет исправлен из-за необходимости сохранения обратной совместимости существующего кода с новыми версиями языка.

### **Примеры:**

```javascript
let user = null;
console.log(user); // null
console.log(typeof user); // "object" (ошибка языка)
```

---

## **5. `undefined`**

Специальное значение `undefined` также стоит особняком. Оно формирует тип из самого себя так же, как и `null`. Значение переменной, которая была объявлена, но не инициализирована, то есть переменой не было присвоено значение.

### **Особенности:**

- Появляется автоматически, если переменная или свойство объекта не инициализированы.

### **Примеры:**

```javascript
let x;
console.log(x); // undefined
console.log(typeof x); // "undefined"
```

Технически мы можем присвоить значение `undefined` любой переменной:

```js
let age = 123;

// изменяем значение на undefined
age = undefined;

alert(age); // "undefined"
```

…Но так делать не рекомендуется. Обычно `null` используется для присвоения переменной «пустого» или «неизвестного» значения, а `undefined` – для проверок, была ли переменная назначена.

---

## **6. Символы (Symbol)**

Уникальные идентификаторы. Используются для создания уникальных свойств объектов. Символы являются нововведением JavaScript начиная с ECMAScript 2015. Символ — это **уникальное** и **иммутабельное** примитивное значение, которое может быть использовано как ключ для свойства объекта

### **Особенности:**

- Не равны друг другу, даже если имеют одинаковое описание.

### **Примеры:**

```javascript
let sym1 = Symbol('id');
let sym2 = Symbol('id');

console.log(sym1 === sym2); // false
console.log(typeof sym1); // "symbol"
```

---

## **7. BigInt**

Тип данных для работы с большими числами, которые выходят за пределы `Number`.

> [!IMPORTANT] Поддержка
> В данный момент BigInt поддерживается только в браузерах Firefox, Chrome, Edge и Safari, но не поддерживается в IE.

Чтобы создать значение типа `BigInt`, необходимо добавить n в конец числового литерала или вызвать функцию `BigInt()`, которая создаст число типа `BigInt` из переданного аргумента. Аргументом может быть число, строка и др.

### **Особенности:**

- Добавляется суффикс `n` к числу.
- Не смешивается с `Number`.

### **Примеры:**

```javascript
let big = 123456789012345678901234567890n;
let small = 10;
const sameBigint = BigInt('1234567890123456789012345678901234567890');
const bigintFromNumber = BigInt(10); // то же самое, что и 10n

console.log(big + 1n); // 123456789012345678901234567891n
// console.log(big + small); // Ошибка: нельзя смешивать BigInt и Number
```

### **Математические операторы**

`BigInt` можно использовать как обычные числа, к примеру:

```js
alert(1n + 2n); // 3

alert(5n / 2n); // 2
```

Обратите внимание: операция деления `5/2` возвращает округлённый результат, без дробной части. Все операции с числами типа `bigint` возвращают `bigint`.

В математических операциях мы не можем смешивать `bigint` и обычные числа:

```js
alert(1n + 2); // Error: Cannot mix BigInt and other types
```

Мы должны явно их конвертировать: используя либо `BigInt()`, либо `Number()`, например:

```js
let bigint = 1n;
let number = 2;

// конвертируем number в bigint
alert(bigint + BigInt(number)); // 3

// конвертируем `bigint` в number
alert(Number(bigint) + number); // 3
```

Конвертирование `bigint` в число всегда происходит неявно и без генерации ошибок, но если значение `bigint` слишком велико и не подходит под тип `number`, то дополнительные биты будут отброшены, так что следует быть осторожными с такими преобразованиями.

> [!IMPORTANT] К `BigInt` числам нельзя применить унарный оператор `+`
> Унарный оператор `+value` является хорошо известным способом конвертировать произвольное значение `value` в число.
>
> Данный оператор не поддерживается при работе с `BigInt` числами:
>
> ```js
> let bigint = 1n;
>
> alert(+bigint); // Ошибка!
> ```
>
> Мы должны использовать `Number()` для преобразования `bigint` к `number`.

### **Операции сравнения**

Операции сравнения, такие как `<`, `>`, работают с `bigint` и обычными числами как обычно:

```js
alert(2n > 1n); // true

alert(2n > 1); // true
```

Пожалуйста, обратите внимание, что обычные и `bigint` числа принадлежат к разным типам, они могут быть равны только при нестрогом сравнении `==`:

```js
alert(1 == 1n); // true

alert(1 === 1n); // false
```

### **Логические операции**

В `if` или любом другом логическом операторе `bigint` число ведёт себя как обычное число.

К примеру, в `if bigint 0n` преобразуется в `false`, другие значения преобразуются в `true`:

```js
if (0n) {
  // никогда не выполнится
}
```

Логические операторы `||`, `&&` и другие также работают с `bigint` числами как с обычными числами:

```js
alert(1n || 2); // 1

alert(0n || 2); // 2
```

### **Полифилы**

Создание полифила для `BigInt` – достаточно непростая задача. Причина в том, что многие операторы в JavaScript, такие как `+`, `-` и др., ведут себя по-разному с `bigint` по сравнению с обычными числами.

К примеру, деление `bigint` числа всегда возвращает `bigint` (округлённое при необходимости).

Чтобы эмулировать такое поведение, полифил должен будет проанализировать код и заменить все такие операторы на свои вызовы. Такая реализация будет тяжеловесной, не очень хорошей с точки зрения производительности.

Вот почему на данный момент нет хорошо реализованного полифила.

Существует обратное решение, предложеное разработчиками библиотеки **JSBI**.

Эта библиотека реализует большие числа, используя собственные методы. Мы можем использовать их вместо встроенных `BigInt`:

| Операция           | Встроенный      | BigInt JSBI             |
| ------------------ | --------------- | ----------------------- |
| Создание из number | a = BigInt(789) | a = JSBI.BigInt(789)    |
| Сложение           | c = a + b       | c = JSBI.add(a, b)      |
| Вычитание          | c = a - b       | c = JSBI.subtract(a, b) |

…А затем использовать полифил (плагин **Babel**) для замены вызовов **JSBI** на встроенные `Bigint` для браузеров, которые их поддерживают.

Другими словами, данный подход предлагает использовать **JSBI** вместо встроенных `BigInt`. **JSBI** внутри себя работает с числами как с `BigInt`, эмулирует их с соблюдением всех требований спецификации. Таким образом, мы можем выполнять JSBI-код в интерпретаторах, которые не поддерживают `Bigint`, а для тех, которые поддерживают – полифил преобразует вызовы в обычные `Bigint`.

---

## Отличие `Number` от `BigInt`

`Number` и `BigInt` — это числовые типы данных в JavaScript, но они имеют различия в назначении, представлении, возможностях и ограничениях.

### **1. Диапазон значений**

#### **Number**

- Основан на формате **IEEE 754 (64-битный)**, использует 53 бита для представления значащих цифр.
- Диапазон:
  - Максимум: `±2**53−1` - `(9,007,199,254,740,991)`.
  - Числа за пределами этого диапазона теряют точность.

#### **BigInt**

- Поддерживает произвольную длину числа.
- Может представлять числа за пределами диапазона `Number` без потери точности.

**Пример:**

```javascript
let big = 1234567890123456789012345678901234567890n; // BigInt
let num = 12345678901234567890; // Number (потеря точности)

console.log(big); // 1234567890123456789012345678901234567890n
console.log(num); // 12345678901234567168 (потеря точности)
```

---

### **2. Тип данных**

- `Number`: используется для чисел с плавающей точкой (дробные и целые).
- `BigInt`: используется только для целых чисел.

**Пример:**

```javascript
let num = 1.23; // Допустимо для Number
let big = 10n; // Допустимо для BigInt
// let invalid = 1.23n; // Ошибка: BigInt не поддерживает дробные числа
```

---

### **3. Операции и совместимость**

- **Смешивание `Number` и `BigInt` недопустимо:**  
   Операции между `Number` и `BigInt` вызовут ошибку.
  ```javascript
  let big = 10n;
  let num = 5;
  // console.log(big + num); // Ошибка: нельзя смешивать BigInt и Number
  ```
- **Приведение типов:**  
   Чтобы выполнить операции, нужно явно преобразовать тип.

  ```javascript
  let big = 10n;
  let num = 5;

  console.log(big + BigInt(num)); // 15n
  console.log(Number(big) + num); // 15
  ```

---

### **4. Производительность**

- `BigInt` работает медленнее, чем `Number`, из-за необходимости обработки произвольной длины числа.
- Используйте `BigInt`, только если требуется точность для больших чисел.

---

### **5. Специальные значения**

- `Number` имеет значения `Infinity`, `-Infinity`, и `NaN`.
- `BigInt` не поддерживает такие значения.

**Пример:**

```javascript
console.log(1 / 0); // Infinity (Number)
console.log(BigInt(1) / 0n); // Ошибка: деление на ноль
```

---

### **Когда использовать BigInt?**

- Если вы работаете с числами больше 253−12^{53} - 1.
- Для вычислений, требующих высокой точности (например, криптография, работа с длинными идентификаторами).

---

### **Сравнение с учетом особенностей**

| Особенность          | `Number`                       | `BigInt`                 |
| -------------------- | ------------------------------ | ------------------------ |
| Тип                  | Число с плавающей точкой       | Только целые числа       |
| Диапазон             | ±253−12^{53} - 1               | Ограничен только памятью |
| Потеря точности      | Да (за пределами диапазона)    | Нет                      |
| Специальные значения | `Infinity`, `-Infinity`, `NaN` | Не поддерживает          |
| Производительность   | Быстрее                        | Медленнее                |

---

## **8. Объекты (Object)**

Объект (`Object`) — это один из ключевых типов данных в JavaScript, который используется для хранения коллекций данных и более сложных сущностей. Объекты создаются как наборы пар "ключ-значение", где ключами могут быть строки или символы, а значениями — любые данные.

### **Примеры:**

```javascript
let user = {
  name: 'Alice',
  age: 30,
};

console.log(user.name); // Alice
console.log(typeof user); // "object"
```

### **1. Создание объектов**

#### **1.1. Литерал объекта**

Самый простой способ создать объект — использовать фигурные скобки `{}`.

```javascript
let person = {
  name: 'John',
  age: 30,
  isEmployed: true,
};
```

#### **1.2. Конструктор `Object`**

Используется редко, но иногда полезен.

```javascript
let person = new Object();
person.name = 'John';
person.age = 30;
```

#### **1.3. С помощью `Object.create(proto)`**

Создаёт объект с указанным прототипом.

```javascript
let proto = { greet: () => console.log('Hello!') };
let obj = Object.create(proto);
obj.name = 'Alice';
console.log(obj.greet()); // "Hello!"
```

---

### **2. Доступ к свойствам**

#### **2.1. Точечная нотация**

Используется, когда имя свойства известно и соответствует правилам идентификаторов.

```javascript
console.log(person.name); // "John"
```

#### **2.2. Квадратные скобки**

Позволяет работать с динамическими или невалидными именами свойств (например, с пробелами или символами).

```javascript
console.log(person['name']); // "John"

let key = 'age';
console.log(person[key]); // 30
```

---

### **3. Добавление, обновление и удаление свойств**

#### **Добавление и обновление**

Можно просто присвоить значение свойству.

```javascript
person.city = 'New York'; // добавление
person.age = 31; // обновление
console.log(person); // {name: "John", age: 31, isEmployed: true, city: "New York"}
```

#### **Удаление**

Используйте оператор `delete`.

```javascript
delete person.city;
console.log(person); // {name: "John", age: 31, isEmployed: true}
```

---

### **4. Перебор свойств объекта**

#### **4.1. `for...in`**

Перебирает все перечисляемые свойства объекта.

```javascript
for (let key in person) {
  console.log(`${key}: ${person[key]}`);
}
// name: John
// age: 30
// isEmployed: true
```

#### **4.2. `Object.keys()`**

Возвращает массив ключей.

```javascript
console.log(Object.keys(person)); // ["name", "age", "isEmployed"]
```

#### **4.3. `Object.values()`**

Возвращает массив значений.

```javascript
console.log(Object.values(person)); // ["John", 30, true]
```

#### **4.4. `Object.entries()`**

Возвращает массив пар `[ключ, значение]`.

```javascript
console.log(Object.entries(person)); // [["name", "John"], ["age", 30], ["isEmployed", true]]
```

---

### **5. Копирование объектов**

#### **5.1. Поверхностное копирование с `Object.assign()`**

```javascript
let clone = Object.assign({}, person);
console.log(clone); // {name: "John", age: 30, isEmployed: true}
```

#### **5.2. Поверхностное копирование с оператором распространения (`...`)**

```javascript
let clone = { ...person };
console.log(clone); // {name: "John", age: 30, isEmployed: true}
```

#### **5.3. Глубокое копирование**

Для вложенных объектов используйте `structuredClone()` или библиотеки вроде Lodash.

```javascript
let deepClone = structuredClone(person);
```

---

### **6. Методы объекта**

Объекты могут содержать методы — функции, которые являются свойствами объекта.

#### **Пример:**

```javascript
let person = {
  name: 'John',
  age: 30,
  greet() {
    console.log(`Hello, my name is ${this.name}`);
  },
};

person.greet(); // "Hello, my name is John"
```

---

### **7. Специальные возможности и методы `Object`**

#### **`Object.freeze(obj)`**

Замораживает объект: невозможно добавить, удалить или изменить свойства.

```javascript
let frozen = Object.freeze({ name: 'John' });
frozen.name = 'Alice'; // Ошибка в строгом режиме
```

#### **`Object.seal(obj)`**

Запрещает добавление и удаление свойств, но изменение существующих разрешено.

```javascript
let sealed = Object.seal({ name: 'John' });
sealed.name = 'Alice'; // Работает
delete sealed.name; // Ошибка в строгом режиме
```

#### **`Object.isFrozen(obj)` и `Object.isSealed(obj)`**

Проверяют, заморожен или запечатан объект.

```javascript
console.log(Object.isFrozen(frozen)); // true
console.log(Object.isSealed(sealed)); // true
```

#### **`Object.getOwnPropertyDescriptors(obj)`**

Возвращает описание всех свойств объекта.

```javascript
console.log(Object.getOwnPropertyDescriptors(person));
/*
{
  name: {value: "John", writable: true, enumerable: true, configurable: true},
  age: {value: 30, writable: true, enumerable: true, configurable: true}
}
*/
```

#### **`Object.hasOwn(obj, key)`**

Проверяет, является ли свойство собственным (не из прототипа).

```javascript
console.log(Object.hasOwn(person, 'name')); // true
```

---

### **8. Прототипы и наследование**

Объекты могут наследовать свойства и методы через прототипы.

#### **Пример:**

```javascript
let animal = {
  eats: true,
  walk() {
    console.log('Animal walks');
  },
};

let rabbit = Object.create(animal);
rabbit.jumps = true;

console.log(rabbit.eats); // true (унаследовано)
rabbit.walk(); // "Animal walks"
```

---

### **9. Пример практической работы с объектом**

```javascript
let car = {
  brand: 'Toyota',
  model: 'Camry',
  year: 2020,
  getInfo() {
    return `${this.brand} ${this.model}, ${this.year}`;
  },
};

console.log(car.getInfo()); // "Toyota Camry, 2020"

car.owner = 'John';
console.log(Object.keys(car)); // ["brand", "model", "year", "getInfo", "owner"]

delete car.year;
console.log(car); // {brand: "Toyota", model: "Camry", getInfo: [Function: getInfo], owner: "John"}
```

---
