# **1.2.2. Типы данных в JavaScript**

> [Index](./0%20Index.md)
> || [1.2.2.1 Методы Number](./1.2.2.1%20Методы%20Number.md)
> || [1.2.2.2 Битовая маска](./1.2.2.2%20Битовая%20маска.md)
> || [1.2.2.3 Методы String](./1.2.2.3%20Методы%20String.md)

JavaScript является *слабо типизированным* или *динамическим* языком. Это значит, что вам не нужно определять тип переменной заранее. Тип определится автоматически во время выполнения программы. Также это значит, что вы можете использовать одну переменную для хранения данных различных типов.

```js
var foo = 42; // сейчас foo типа Number
foo = 'bar'; // а теперь foo типа String
foo = true; // foo становится типа Boolean
```

JavaScript позволяет нам работать с примитивными типами данных – строками, числами и т.д., как будто они являются объектами. У них есть и методы. Мы изучим их позже, а сначала разберём, как это всё работает, потому что, конечно, примитивы – не объекты.

## Стандарт ECMAScript определяет 8 типов:

- 6 типов данных являющихся примитивами:
  - [Number](https://developer.mozilla.org/ru/docs/Glossary/Number) (Число) : `typeof instance === "number"`
  - [String](https://developer.mozilla.org/ru/docs/Glossary/String) (Строка) : `typeof instance === "string"`
  - [Boolean](https://developer.mozilla.org/ru/docs/Glossary/Boolean) (Булев, Логический тип) : `typeof instance === "boolean"`
  - [Undefined](https://developer.mozilla.org/ru/docs/Glossary/Undefined) (Неопределённый тип) : `typeof instance === "undefined"`
  - [Symbol](https://developer.mozilla.org/en-US/docs/Glossary/Symbol) (в ECMAScript 6) : `typeof instance === "symbol"`
  - [BigInt](https://developer.mozilla.org/ru/docs/Glossary/BigInt) : `typeof instance === "bigint"`
- [Null](https://developer.mozilla.org/ru/docs/Glossary/Null) (Null тип ) : `typeof instance === "object"`. Специальный примитив, используемый не только для данных но и в качестве указателя на финальную точку в [Цепочке Прототипов](https://developer.mozilla.org/ru/docs/Web/JavaScript/Inheritance_and_the_prototype_chain);
- [Object](https://developer.mozilla.org/ru/docs/Glossary/Object) (Объект) : `typeof instance === "object"`. Может хранить множество значений как свойства. Простая структура, используемая не только для хранения данных, но и для создания других структур, где любая структура создаётся с использованием ключевого слова [`new`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/new): new [Object](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object), new [Array](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array), new [Map](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Map), new [Set](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Set), new [WeakMap](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakMap), new [WeakSet](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakSet), new [Date](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date) и множество других структур;

> [!IMPORTANT]
>
> Все типы данных в JavaScript, кроме объектов, являются иммутабельными (значения не могут быть модифицированы, а только перезаписаны новым полным значением). Например, в отличии от C, где строку можно посимвольно корректировать, в JavaScript строки пересоздаются только полностью. Значения таких типов называются «примитивными значениями».

## **Примитив как объект**

Вот парадокс, с которым столкнулся создатель JavaScript:

- Есть много всего, что хотелось бы сделать с примитивами, такими как строка или число. Было бы замечательно, если бы мы могли обращаться к ним при помощи методов.
- Примитивы должны быть лёгкими и быстрыми насколько это возможно.

Выбранное решение, хотя выглядит оно немного неуклюже:

- Примитивы остаются примитивами. Одно значение, как и хотелось.
- Язык позволяет осуществлять доступ к методам и свойствам строк, чисел, булевых значений и символов.

Чтобы это работало, при таком доступе создаётся специальный «объект-обёртка», который предоставляет нужную функциональность, а после удаляется.
Каждый примитив имеет свой собственный «объект-обёртку», которые называются: `String`, `Number`, `Boolean`, `Symbol` и `BigInt`. Таким образом, они имеют разный набор методов.

К примеру, существует метод `str.toUpperCase()`, который возвращает строку в верхнем регистре.

Вот, как он работает:

```js
let str = 'Привет';

alert(str.toUpperCase()); // ПРИВЕТ
```

Очень просто, не правда ли? Вот, что на самом деле происходит в `str.toUpperCase()`:

1. Строка `str` – примитив. В момент обращения к его свойству, создаётся специальный объект, который знает значение строки и имеет такие полезные методы, как `toUpperCase()`.
2. Этот метод запускается и возвращает новую строку (показывается в `alert`).
3. Специальный объект удаляется, оставляя только примитив `str`.

Получается, что примитивы могут предоставлять методы, и в то же время оставаться «лёгкими».

Движок JavaScript сильно оптимизирует этот процесс. Он даже может пропустить создание специального объекта. Однако, он всё же должен придерживаться спецификаций и работать так, как будто он его создаёт.

Число имеет собственный набор методов. Например, `toFixed(n)` округляет число до `n` знаков после запятой.

```js
let num = 1.23456;

alert(num.toFixed(2)); // 1.23
```

Более подробно с различными свойствами и методами мы познакомимся позже.

> [!CAUTION]
>
> **Конструкторы String/Number/Boolean предназначены только для внутреннего пользования**
> Некоторые языки, такие как Java, позволяют явное создание «объектов-обёрток» для примитивов при помощи такого синтаксиса как `new Number(1)` или `new Boolean(false)`.
>
> В JavaScript, это тоже возможно по историческим причинам, но очень не рекомендуется. В некоторых местах последствия могут быть катастрофическими.
>
> Например:
>
> ```js
> alert(typeof 0); // "число"
>
> alert(typeof new Number(0)); // "object"!
> ```
>
> Объекты в `if` всегда дают `true`, так что в нижеприведённом примере будет показан `alert`:
>
> ```js
> let zero = new Number(0);
>
> if (zero) {
>   // zero возвращает "true", так как является объектом
>   alert('zero имеет «истинное» значение?!?');
> }
> ```
>
> С другой стороны, использование функций `String`/`Number`/`Boolean` без оператора `new` – вполне разумно и полезно. Они превращают значение в соответствующий примитивный тип: в строку, в число, в булевый тип.
>
> К примеру, следующее вполне допустимо:
>
> ```js
> let num = Number('123'); // превращает строку в число
> ```

> [!CAUTION]
>
> **null/undefined не имеют методов**
> Особенные примитивы null и undefined являются исключениями. У них нет соответствующих «объектов-обёрток», и они не имеют никаких методов. В некотором смысле, они «самые примитивные».
>
> Попытка доступа к свойствам такого значения возвратит ошибку:
>
> ```js
> alert(null.test); // ошибка
> ```

## Проверка типа структур

Оператор `typeof` возвращает тип аргумента. Это полезно, когда мы хотим обрабатывать значения различных типов по-разному или просто хотим сделать проверку.

У него есть две синтаксические формы:

```
// Обычный синтаксис
typeof 5; // Выведет "number"
// Синтаксис, напоминающий вызов функции (встречается реже)
typeof(5); // Также выведет "number"
```

Если передается выражение, то нужно заключать его в скобки, т.к. `typeof` имеет более высокий приоритет, чем бинарные операторы:

```js
typeof 50 + ' Квартир'; // Выведет "number Квартир"
typeof (50 + ' Квартир'); // Выведет "string"
```

Другими словами, скобки необходимы для определения типа значения, которое получилось в результате выполнения выражения в них.

Вызов `typeof x` возвращает строку с именем типа:

```js
typeof undefined; // "undefined"
typeof 0; // "number"
typeof 10n; // "bigint"
typeof true; // "boolean"
typeof 'foo'; // "string"
typeof Symbol('id'); // "symbol"
typeof Math; // "object"  (1)
typeof null; // "object"  (2)
typeof alert; // "function"  (3)
```

Последние три строки нуждаются в пояснении:

- `Math` — это встроенный объект, который предоставляет математические операции и константы.
- Результатом вызова `typeof null` является "`object`". Это официально признанная ошибка в `typeof`, ведущая начало с времён создания JavaScript и сохранённая для совместимости. Конечно, `null` не является объектом. Это специальное значение с отдельным типом.
- Вызов `typeof alert` возвращает "`function`", потому что `alert` является функцией. Мы изучим функции в следующих главах, где заодно увидим, что в JavaScript нет специального типа «функция». Функции относятся к объектному типу. Но `typeof` обрабатывает их особым образом, возвращая "`function`". Так тоже повелось от создания JavaScript. Формально это неверно, но может быть удобным на практике.

```javascript
let number = 42; // Число
let text = 'Hello, world!'; // Строка
let isOnline = true; // Логическое значение
let notAssigned; // undefined
let empty = null; // null

console.log(typeof number); // Выведет: number
console.log(typeof text); // Выведет: string
console.log(typeof isOnline); // Выведет: boolean
console.log(typeof notAssigned); // Выведет: undefined
console.log(typeof empty); // Выведет: object (особенность языка)
```

Чаще всего операторы и функции автоматически приводят переданные им значения к нужному типу.

Например, `alert` автоматически преобразует любое значение к строке. Математические операторы преобразуют значения к числам.

Есть также случаи, когда нам нужно явно преобразовать значение в ожидаемый тип.

> [!IMPORTANT]
> Необходимо сделать предостережение относительно использования оператора `typeof` для определения типа структур, т.к. все структуры будут возвращать `"object"` при его использовании, так как назначение `typeof` — проверка типа данных, но не структур. Если проверить тип структуры всё же необходимо, то в этом случае желательно использовать оператор [instanceof](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/instanceof), так как именно он отвечает на вопрос о том, какой конструктор был использован для создания структуры.

> [!IMPORTANT]
> Стоит отметить два особых случая работы оператора `typeof`: возврат `"object"` для значения `null` и `"function"` для функций: первое принято считать ошибкой языка, сохраненной ради обратной совместимости, второе является условностью, удобной для проверки на принадлежность значения категории функций, где функция - это особый, "вызываемый", объект.

---

## **1. Числа (Number)**

Числа в JavaScript представлены одним типом, включая целые и дробные значения. В соответствии со стандартом ECMAScript, существует только один числовой тип, который представляет собой [64-битное число двойной точности согласно стандарту IEEE 754](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%BE_%D0%B4%D0%B2%D0%BE%D0%B9%D0%BD%D0%BE%D0%B9_%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D0%B8). Другими словами, **специального типа для целых чисел в JavaScript нет**. Это означает, что при числовых операциях вы можете получить неточное (округлённое) значение. В дополнение к возможности представлять числа с плавающей запятой, есть несколько символических значений: `+Infinity` (положительная бесконечность), `-Infinity` (отрицательная бесконечность), и `NaN` (не число).

В JavaScript тип `number` не может безопасно работать с числами, большими, чем `(2**53-1)` (т. е. `9007199254740991`) или меньшими, чем `-(2**53-1)` для отрицательных чисел.

Если говорить совсем точно, то, технически, тип number может хранить большие целые числа `(до 1.7976931348623157 * 10**308)`, но за пределами безопасного диапазона целых чисел `±(2**53-1)` будет ошибка точности, так как не все цифры помещаются в фиксированную 64-битную память. Поэтому можно хранить «приблизительное» значение.

Например, эти два числа (прямо за пределами безопасного диапазона) совпадают:

```js
console.log(9007199254740991 + 1); // 9007199254740992
console.log(9007199254740991 + 2); // 9007199254740992
```

То есть все нечетные целые числа, большие чем `(2**53-1)`, вообще не могут храниться в типе `number`.

В большинстве случаев безопасного диапазона чисел от `-(2**53-1)` до `(2**53-1)` вполне достаточно, но иногда нам требуется весь диапазон действительно гигантских целых чисел без каких-либо ограничений или пропущенных значений внутри него. Например, в криптографии или при использовании метки времени (`«timestamp»`) с микросекундами.

> [!CAUTION]
>
> Хотя число в большинстве случаев представляет только своё значение, JavaScript предоставляет [несколько бинарных операций](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators). Они могут использоваться для того, чтобы представлять число как несколько булевых значений, с помощью [битовой маски](https://ru.wikipedia.org/wiki/%D0%91%D0%B8%D1%82%D0%BE%D0%B2%D0%B0%D1%8F_%D0%BC%D0%B0%D1%81%D0%BA%D0%B0). Это считается плохой практикой, так как JavaScript предлагает другие способы представления булевых значений (например, массив элементов с булевыми значениями или объект, содержащий набор булевых свойств). Кроме того, битовые маски часто делают код более трудным для чтения, понимания и дальнейшей поддержки. Эта техника может быть необходима в условиях технических ограничений, таких как объём локального хранилища данных, или в такой экстремальной ситуации, когда каждый бит передаваемый по сети на счету. Данный подход следует использовать как крайнюю меру, когда не остаётся других путей для необходимой оптимизации.
>
> Подробное объяснение с примерами [1.2.2.2 Битовая маска](./1.2.2.2%20Битовая%20маска.md)

### **Особенности:**

- Поддержка операций: `+`, `-`, `*`, `/`, `%`, `**`.
- Математические операции в JavaScript «безопасны». Мы можем делать что угодно: делить на ноль, обращаться с нечисловыми строками как с числами и т.д. Скрипт никогда не остановится с фатальной ошибкой (не «умрёт»). В худшем случае мы получим `NaN` как результат выполнения.
- Специальные значения:
  - `NaN` (Not a Number) — результат недопустимой операции.
  - `Infinity` и `-Infinity` — бесконечности.
- Методы: `.parseInt()`, `.parseFloat()`, `.isNaN()`, `.isInteger()`, `.toFixed()`
- Ноль в JavaScript имеет два представления: -0 и +0. («0» это синоним +0). На практике это имеет малозаметный эффект. Например, выражение `+0 === -0` является истинным. Однако, это может проявиться при делении на ноль:

```js
let a = 42 / +0; // Infinity
let b = 42 / -0; // -Infinity
```

### **Способы записи числа**

Представьте, что нам надо записать число 1 миллиард. Самый очевидный путь:

```js
let billion = 1000000000;
```

Мы также можем использовать символ нижнего подчёркивания `_` в качестве разделителя:

```js
let billion = 1_000_000_000;
```

Символ нижнего подчёркивания `_` – это «синтаксический сахар», он делает число более читабельным. Движок JavaScript попросту игнорирует `_` между цифрами, поэтому в примере выше получается точно такой же миллиард, как и в первом случае.

Однако в реальной жизни мы в основном стараемся не писать длинные последовательности нулей, так как можно легко ошибиться. Укороченная запись может выглядеть как `"1млрд"` или `"7.3млрд"` для 7 миллиардов 300 миллионов. Такой принцип работает для всех больших чисел.

В JavaScript, чтобы укоротить запись числа, мы можем добавить к нему букву `"e"` и указать необходимое количество нулей:

```js
let billion = 1e9; // 1 миллиард, буквально: 1 и 9 нулей

alert(7.3e9); // 7.3 миллиарда (7,300,000,000)
```

Другими словами, `"e"` умножает число на 1 с указанным количеством нулей.

```js
1e3 === 1 * 1000; // e3 означает *1000
1.23e6 === 1.23 * 1000000; // e6 означает *1000000
```

А сейчас давайте запишем что-нибудь очень маленькое. К примеру, 1 микросекунду (одна миллионная секунды):

```js
let mcs = 0.000001;
```

В этом случае нам также поможет `"e"`. Если мы хотим избежать записи длинной последовательности из нулей, мы можем сделать так:

```js
let ms = 1e-6; // шесть нулей слева от 1
```

Если мы подсчитаем количество нулей в `0.000001`, их будет `6`. Естественно, верная запись `1e-6`.

Другими словами, отрицательное число после `"e"` подразумевает деление на 1 с указанным количеством нулей:

```js

// 1 делится на 1 с 3 нулями
1e-3 === 1 / 1000 (=0.001)

// 1.23 делится на 1 с 6 нулями
1.23e-6 === 1.23 / 1000000 (=0.00000123)
```

### **Шестнадцатеричные, двоичные и восьмеричные числа**

Шестнадцатеричные числа широко используются в JavaScript для представления цветов, кодировки символов и многого другого. Естественно, есть короткий стиль записи: `0x`, после которого указывается число.

Например:

```
alert( 0xff ); // 255
alert( 0xFF ); // 255 (то же самое, регистр не имеет значения)
```

Двоичные и восьмеричные числа используются не так часто, но они также поддерживаются: `0b` для двоичных и `0o` для восьмеричных:

```js
let a = 0b11111111; // двоичная (бинарная) форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255

alert(a == b); // true, с двух сторон число 255
```

Есть только 3 системы счисления с такой поддержкой. Для других систем счисления мы рекомендуем использовать функцию `parseInt`.

### **Примеры:**

```javascript
let a = 10; // Целое число
let b = 3.14; // Дробное число
let c = 1 / 0; // Infinity
let d = 'hello' * 2; // NaN
let e = 5 % 3; // 2

console.log(typeof a); // "number"
console.log(c); // Infinity
console.log(d); // NaN
console.log(e); // 2
```

### Приведение типов

Явное преобразование часто применяется, когда мы ожидаем получить число из строкового контекста, например из текстовых полей форм.
Если строка не может быть явно приведена к числу, то результатом преобразования будет `NaN`.

| value          | result                                                                                                                                                                                                                                  |
| -------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `undefined`    | `NaN`                                                                                                                                                                                                                                   |
| `null`         | `0`                                                                                                                                                                                                                                     |
| `true / false` | `1` / `0`                                                                                                                                                                                                                               |
| `string`       | Пробельные символы (пробелы, знаки табуляции `\t`, знаки новой строки `\n` и т. п.) по краям обрезаются. Далее, если остаётся пустая строка, то получаем `0`, иначе из непустой строки «считывается» число. При ошибке результат `NaN`. |

- Используйте `Number(value)`, унарный `+`, или методы парсинга (`parseInt`, `parseFloat`).
- Численное преобразование происходит в математических функциях и выражениях. Например, когда операция деления `/` применяется не к числу

```javascript
let str = '123';
console.log(Number(str)); // 123
console.log(+str); // 123
console.log(parseInt('123px')); // 123

let str = 'Любая строка вместо цифр';
console.log(Number(str)); // NaN

console.log('6' / '2'); // 3, строки преобразуются в числа
```

### **`NaN` (Not-a-Number)**

#### **Описание:**

`NaN` — это результат недопустимых арифметических операций, таких как деление строки на число или применение математических функций к недопустимым данным.

#### **Особенности:**

1. **Тип:**  
   `NaN` принадлежит к типу `number`.

   ```javascript
   console.log(typeof NaN); // "number"
   ```

2. **Уникальность:**  
   `NaN` не равен самому себе. Это значит, что проверка `NaN === NaN` возвращает `false`.

   ```javascript
   console.log(NaN == NaN); // false
   console.log(NaN === NaN); // false
   ```

3. **Проверка на `NaN`:**  
   Для проверки используйте функцию `isNaN()` или `Number.isNaN()`.

   - `isNaN()`: преобразует аргумент в число перед проверкой.
   - `Number.isNaN()`: проверяет только значения, которые изначально равны `NaN`.

4. **`NaN` влияет на результат**
   Если где-то в математическом выражении есть `NaN`, то оно распространяется на весь результат (есть только одно исключение: `NaN ** 0 === 1`).

#### **Примеры:**

```javascript
console.log('hello' * 2); // NaN
console.log(0 / 0); // NaN
console.log(Math.sqrt(-1)); // возвращает квадратный корень числа, если число < 0, то NaN
console.log(isNaN('hello')); // true (строка преобразована)
console.log(Number.isNaN('hello')); // false (без преобразования)
```

---

### **`Infinity` и `-Infinity`**

#### **Описание:**

`Infinity` и `-Infinity` представляют положительную и отрицательную бесконечность. Они возникают, когда число выходит за пределы допустимого диапазона или в результате операций, которые не имеют конечного значения.

#### **Особенности:**

1. **Тип:**  
   `Infinity` также принадлежит к типу `number`.

   ```javascript
   console.log(typeof Infinity); // "number"
   ```

2. **Предельные значения:**
   Для получения самого большого или самого меньшего доступного значения в пределах `+/-Infinity`, можно использовать константы [`Number.MAX_VALUE`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_VALUE) или [`Number.MIN_VALUE`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_VALUE). А начиная с ECMAScript 2015, вы также можете проверить, находится ли число в безопасном для целых чисел диапазоне, используя метод [`Number.isSafeInteger()`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger), либо константы [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER) и [`Number.MIN_SAFE_INTEGER`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_SAFE_INTEGER). За пределами этого диапазона операции с целыми числами будут небезопасными, и возвращать приближённые значения.
3. **Арифметические операции:**

   - Любое число, умноженное на `Infinity`, остаётся бесконечным.
   - Деление числа на `Infinity` даёт `0`.

   ```javascript
   console.log(1 / Infinity); // 0
   console.log(Infinity * 2); // Infinity
   ```

4. **Проверка на бесконечность:**  
    Используйте метод `isFinite()` или прямое сравнение.

   ```javascript
   console.log(isFinite(42)); // true
   alert(isFinite('15')); // true
   alert(isFinite('str')); // false, потому что специальное значение: NaN
   alert(isFinite(Infinity)); // false, потому что специальное значение: Infinity
   ```

   Иногда `isFinite` используется для проверки, содержится ли в строке число:

   ```js
   let num = +prompt('Введите число:', '');

   // вернёт true всегда, кроме ситуаций, когда аргумент - Infinity/-Infinity или не число
   alert(isFinite(num));
   ```

   Помните, что пустая строка интерпретируется как `0` во всех числовых функциях, включая `isFinite`.

#### **Примеры:**

```javascript
console.log(1 / 0); // Infinity
console.log(-1 / 0); // -Infinity
console.log(Number.MAX_VALUE * 2); // Infinity
console.log(-Number.MAX_VALUE * 2); // -Infinity
console.log(Infinity - Infinity); // NaN
```

---

### **Сравнение `NaN` и `Infinity`**

| Особенность        | `NaN`                                 | `Infinity`                                  |
| ------------------ | ------------------------------------- | ------------------------------------------- |
| **Тип**            | `number`                              | `number`                                    |
| **Возникает при:** | Недопустимых математических операциях | Делении на ноль или переполнении            |
| **Равенство**      | Не равен самому себе (`NaN !== NaN`)  | Равен самому себе (`Infinity === Infinity`) |
| **Проверка**       | `isNaN()` или `Number.isNaN()`        | `isFinite()` для проверки конечности        |
| **Особенности**    | Распространённый источник ошибок      | Часто используется в вычислениях            |

> [!CAUTION]
>
> **Number.isNaN и Number.isFinite**
> Методы `Number.isNaN` и `Number.isFinite` – это более «строгие» версии функций `isNaN` и `isFinite`. Они не преобразуют аргумент в число, а наоборот – первым делом проверяют, является ли аргумент числом (принадлежит ли он к типу number).
>
> `Number.isNaN(value)` возвращает `true` только в том случае, если аргумент принадлежит к типу `number` и является `NaN`. Во всех остальных случаях возвращает `false`.
>
> ```js
> alert(Number.isNaN(NaN)); // true
> alert(Number.isNaN('str' / 2)); // true
>
> // Обратите внимание на разный результат:
> alert(Number.isNaN('str')); // false, так как "str" является строкой, а не числом
> alert(isNaN('str')); // true, так как isNaN сначала преобразует строку "str" в число и в результате преобразования получает NaN
> ```
>
> `Number.isFinite(value)` возвращает `true` только в том случае, если аргумент > принадлежит к типу `number` и не является `NaN/Infinity/-Infinity`. Во всех остальных случаях возвращает `false`.
>
> ```js
> alert(Number.isFinite(123)); // true
> alert(Number.isFinite(Infinity)); // false
> alert(Number.isFinite(2 / 0)); // false
>
> // Обратите внимание на разный результат:
> alert(Number.isFinite('123')); // false, так как "123" является строкой, а не числом
> alert(isFinite('123')); // true, так как isFinite сначала преобразует строку "123" в число 123
> ```
>
> Не стоит считать `Number.isNaN` и `Number.isFinite` более «корректными» версиями функций `isNaN` и `isFinite`. Это дополняющие друг-друга инструменты для разных задач.

---

### **Практическое использование и обработка**

#### **Работа с `NaN`:**

1. Проверяйте ввод пользователя:

   ```javascript
   let input = 'abc';
   let result = parseInt(input);
   if (isNaN(result)) {
     console.log('Недопустимое значение!');
   }
   ```

2. Избегайте использования `==` для проверки, используйте `isNaN()`:

   ```javascript
   console.log(NaN == NaN); // false
   console.log(isNaN(NaN)); // true
   ```

#### **Работа с `Infinity`:**

1. Используйте проверки на конечность:

   ```javascript
   let largeNumber = 1e309; // больше, чем максимальное число
   console.log(isFinite(largeNumber)); // false
   ```

2. Обрабатывайте деление на ноль:

   ```javascript
   let num = 5;
   let divisor = 0;
   if (divisor === 0) {
     console.log('Ошибка: деление на ноль!');
   } else {
     console.log(num / divisor);
   }
   ```

### **Округление**

Одна из часто используемых операций при работе с числами – это округление.

В JavaScript есть несколько встроенных функций для работы с округлением:

- **Math.floor** - Округление в меньшую сторону: `3.1` становится `3`, а `-1.1` — `-2`.
- **Math.ceil** - Округление в большую сторону: `3.1` становится `4`, а `-1.1` — `-1`.
- **Math.round** - Округление до ближайшего целого: `3.1` становится `3`, `3.6` — `4`, а `-1.1` — `-1`.
- **Math.trunc** (не поддерживается в Internet Explorer) - Производит удаление дробной части без округления: `3.1` становится `3`, а `-1.1` — `-1`.

Ниже представлена таблица с различиями между функциями округления:

| Number | Math.floor | Math.ceil | Math.round | Math.trunc |
| ------ | ---------- | --------- | ---------- | ---------- |
| 3.1    | 3          | 4         | 3          | 3          |
| 3.6    | 3          | 4         | 4          | 3          |
| -1.1   | -2         | -1        | -1         | -1         |
| -1.6   | -2         | -1        | -2         | -1         |

Эти функции охватывают все возможные способы обработки десятичной части. Что если нам надо округлить число до n-ого количества цифр в дробной части?

Например, у нас есть `1.2345` и мы хотим округлить число до 2-х знаков после запятой, оставить только `1.23`.

Есть два пути решения:

1. Умножить и разделить.

Например, чтобы округлить число до второго знака после запятой, мы можем умножить число на 100, вызвать функцию округления и разделить обратно.

```js
let num = 1.23456;

alert( Math.round(num \* 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23
```

Метод `toFixed(n)` округляет число до `n` знаков после запятой и возвращает строковое представление результата.

```js
let num = 12.34;
alert(num.toFixed(1)); // "12.3"
```

Округляет значение до ближайшего числа, как в большую, так и в меньшую сторону, аналогично методу `Math.round`:

```js
let num = 12.36;
alert(num.toFixed(1)); // "12.4"
```

Обратите внимание, что результатом `toFixed` является строка. Если десятичная часть короче, чем необходима, будут добавлены нули в конец строки:

```js
let num = 12.34;
alert(num.toFixed(5)); // "12.34000", добавлены нули, чтобы получить 5 знаков после запятой
```

Мы можем преобразовать полученное значение в число, используя унарный оператор `+` или `Number()`, пример с унарным оператором: `+num.toFixed(5)`.

### **Неточные вычисления**

Внутри JavaScript число представлено в виде 64-битного формата IEEE-754. Для хранения числа используется 64 бита: 52 из них используется для хранения цифр, 11 для хранения положения десятичной точки и один бит отведён на хранение знака.

Если число слишком большое, оно переполнит 64-битное хранилище, JavaScript вернёт бесконечность:

```js
alert(1e500); // Infinity
```

Наиболее часто встречающаяся ошибка при работе с числами в JavaScript – это потеря точности.

Посмотрите на это (неверное!) сравнение:

```js
alert(0.1 + 0.2 == 0.3); // false
```

Да-да, сумма `0.1` и `0.2` не равна `0.3`.

Странно! Что тогда, если не `0.3`?

```js
alert(0.1 + 0.2); // 0.30000000000000004
```

Ой! Здесь гораздо больше последствий, чем просто некорректное сравнение. Представьте, вы делаете интернет-магазин и посетители формируют заказ из 2-х позиций за $0.10 и $0.20. Итоговый заказ будет $0.30000000000000004. Это будет сюрпризом для всех.

Но почему это происходит?

Число хранится в памяти в бинарной форме, как последовательность бит – единиц и нулей. Но дроби, такие как 0.1, 0.2, которые выглядят довольно просто в десятичной системе счисления, на самом деле являются бесконечной дробью в двоичной форме.

```js
alert((0.1).toString(2)); // 0.0001100110011001100110011001100110011001100110011001101
alert((0.2).toString(2)); // 0.001100110011001100110011001100110011001100110011001101
alert((0.1 + 0.2).toString(2)); // 0.0100110011001100110011001100110011001100110011001101
```

Другими словами, что такое 0.1? Это единица делённая на десять — 1/10, одна десятая. В десятичной системе счисления такие числа легко представимы, по сравнению с одной третьей: 1/3, которая становится бесконечной дробью 0.33333(3).

Деление на 10 гарантированно хорошо работает в десятичной системе, но деление на 3 – нет. По той же причине и в двоичной системе счисления, деление на 2 обязательно сработает, а 1/10 становится бесконечной дробью.

В JavaScript нет возможности для хранения точных значений 0.1 или 0.2, используя двоичную систему, точно также, как нет возможности хранить одну третью в десятичной системе счисления.

Числовой формат IEEE-754 решает эту проблему путём округления до ближайшего возможного числа. Правила округления обычно не позволяют нам увидеть эту «крошечную потерю точности», но она существует.

Пример:

```js
alert((0.1).toFixed(20)); // 0.10000000000000000555
```

И когда мы суммируем 2 числа, их «неточности» тоже суммируются.

Вот почему 0.1 + 0.2 – это не совсем 0.3.

> [!TIP]
>
> Не только в JavaScript
> Справедливости ради заметим, что ошибка в точности вычислений для чисел с плавающей точкой сохраняется в любом другом языке, где используется формат IEEE 754, включая PHP, Java, C, Perl и Ruby.

Можно ли обойти проблему? Конечно, наиболее надёжный способ — это округлить результат используя метод `toFixed(n)`:

```js
let sum = 0.1 + 0.2;
alert(sum.toFixed(2)); // "0.30"
```

Помните, что метод `toFixed` всегда возвращает строку. Это гарантирует, что результат будет с заданным количеством цифр в десятичной части. Также это удобно для форматирования цен в интернет-магазине $0.30. В других случаях можно использовать унарный оператор `+`, чтобы преобразовать строку в число:

```js
let sum = 0.1 + 0.2;
alert(+sum.toFixed(2)); // 0.3
```

Также можно временно умножить число на 100 (или на большее), чтобы привести его к целому, выполнить математические действия, а после разделить обратно. Суммируя целые числа, мы уменьшаем погрешность, но она всё равно появляется при финальном делении:

```js
alert( (0.1 _ 10 + 0.2 _ 10) / 10 ); // 0.3
alert( (0.28 _ 100 + 0.14 _ 100) / 100); // 0.4200000000000001
```

Таким образом, метод умножения/деления уменьшает погрешность, но полностью её не решает.

Иногда можно попробовать полностью отказаться от дробей. Например, если мы в нашем интернет-магазине начнём использовать центы вместо долларов. Но что будет, если мы применим скидку 30%? На практике у нас не получится полностью избавиться от дроби. Просто используйте округление, чтобы отрезать «хвосты», когда надо.

> [!TIP]
>
> **Забавный пример**
> Попробуйте выполнить его:
>
> ```js
> // Привет! Я – число, растущее само по себе!
> alert(9999999999999999); // покажет 10000000000000000
> ```
>
> Причина та же – потеря точности. Из 64 бит, отведённых на число, сами цифры числа занимают до 52 бит, > остальные 11 бит хранят позицию десятичной точки и один бит – знак. Так что если 52 бит не хватает на цифры, то при записи пропадут младшие разряды.
>
> Интерпретатор не выдаст ошибку, но в результате получится «не совсем то число», что мы и видим в примере выше. Как говорится: «как смог, так записал».

> [!TIP]
>
> **Два нуля**
> Другим забавным следствием внутреннего представления чисел является наличие двух нулей: `0` и `-0`.
>
> Все потому, что знак представлен отдельным битом, так что, любое число может быть положительным и отрицательным, включая нуль.
>
> В большинстве случаев это поведение незаметно, так как операторы в JavaScript воспринимают их одинаковыми.

---

## **2. Строки (String)**

В JavaScript любые текстовые данные являются строками. Не существует отдельного типа «символ», который есть в ряде других языков.

Внутренний формат для строк — всегда `UTF-16`, вне зависимости от кодировки страницы.

Строки — последовательность символов, заключенная в одинарные `' '`, двойные `" "`, или обратные кавычки `` `  ` ``.

В JavaScript для представления текстовых данных служит тип [`String`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String). Он представляет собой цепочку «элементов» 16-битных беззнаковых целочисленных значений. Каждый такой элемент занимает свою позицию в строке. Первый элемент имеет индекс 0, следующий — 1, и так далее. Длина строки — это количество элементов в ней.

В отличие от языков подобных C, строки в JavaScript являются иммутабельными. Это означает, что после того, как строковое значение создано, его нельзя модифицировать. Нельзя взять символ посередине и заменить его. Как только строка создана — она такая навсегда. Остаётся лишь создать новую строку путём совершения некой операции над исходной строкой.

```js
let str = 'Hi';

str[0] = 'h'; // ошибка
alert(str[0]); // не работает
```

> [!WARNING]
>
> Используйте строки только для текстовых данных. Для составных структур преобразуйте строки в подобающие конструкции.

### **Особенности:**

- Конкатенация через `+` или шаблонные строки.
- Получить часть исходной строки выборкой отдельных символов, либо применением метода [`String.substr()`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/substr).
- Объединить две строки в одну, применив оператор (`+`) или метод [`String.concat()`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/concat).
- Методы: `.length`, `.toUpperCase()`, `.toLowerCase()`, `.includes()`, `.slice()`.

### **Примеры:**

```javascript
let single = 'Hello';
let double = 'World';
let template = `Привет, ${single} ${double}!`;

alert(`результат: ${1 + 2}`); // результат: 3
console.log(template); // Привет, Hello World!
console.log(single.length); // 5
console.log(single.toUpperCase()); // HELLO
```

Ещё одно преимущество обратных кавычек — они могут занимать более одной строки, вот так:

```js
let guestList = `Guests:
 * John
 * Pete
 * Mary
`;

alert(guestList); // список гостей, состоящий из нескольких строк
```

Многострочные строки также можно создавать с помощью одинарных и двойных кавычек, используя так называемый «символ перевода строки», который записывается как `\n`:

```js
let guestList = 'Guests:\n * John\n * Pete\n * Mary';

alert(guestList); // список гостей, состоящий из нескольких строк
```

Есть и другие, реже используемые спецсимволы. Вот список:

| Символ        | Описание                                                                                                                                                                                                |
| ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| \n            | Перевод строки                                                                                                                                                                                          |
| \r            | В текстовых файлах Windows для перевода строки используется комбинация символов `\r\n`, а на других ОС это просто `\n`. Это так по историческим причинам, ПО под Windows обычно понимает и просто `\n`. |
| \\', \\", \\` | Кавычки                                                                                                                                                                                                 |
| \\\           | Обратный слеш                                                                                                                                                                                           |
| \t            | Знак табуляции                                                                                                                                                                                          |
| \b, \f, \v    | Backspace, Form Feed и Vertical Tab — оставлены для обратной совместимости, сейчас не используются.                                                                                                     |

Как вы можете видеть, все спецсимволы начинаются с обратного слеша, `\` — так называемого «символа экранирования».

Он также используется, если необходимо вставить в строку кавычку.

К примеру:

```
alert('I\'m the Walrus!'); // I'm the Walrus!
alert("Say \"Hello\""); // Say "Hello"
```

но более красивый вариант использовать в таком случае разнородные кавычки

```js
alert("I'm the Walrus!"); // I'm the Walrus!
alert('Say "Hello"'); // Say "Hello"
```

### Приведение типов

- Используйте метод `String(value)` или конкатенацию с пустой строкой.

```javascript
let num = 123;
console.log(String(num)); // "123"
console.log(num + ''); // "123"

let value = true;
console.log(typeof value); // boolean
value = String(value); // теперь value это строка "true
console.log(typeof value); // string
```

### **Получение части строки**

В JavaScript получение части строки или выборка отдельных символов может быть выполнена несколькими способами. Рассмотрим их подробнее с примерами.

#### **1. Использование метода `charAt`**

Метод возвращает символ по указанному индексу строки.

```javascript
const str = 'JavaScript';
const char = str.charAt(4); // Индексация начинается с 0
console.log(char); // "S"
```

---

#### **2. Использование метода `at`**

Получить символ, который занимает позицию `pos` можно используя метод `str.at(pos)`. Первый символ занимает нулевую позицию.

```js
let str = `Hello`;

// получаем первый символ
alert(str.at(0)); // H

// получаем последний символ
alert(str.at(-1)); // o
```

Как вы можете видеть, преимущество метода `.at(pos)` заключается в том, что он допускает отрицательную позицию. Если `pos` – отрицательное число, то отсчет ведется от конца строки.

Таким образом, `.at(-1)` означает последний символ, а `.at(-2)` – тот, что перед ним, и т.д.

#### **3. Обращение к строке как к массиву**

В современных версиях JavaScript можно использовать синтаксис квадратных скобок для доступа к символу. Квадратные скобки всегда возвращают undefined для отрицательных индексов.

```javascript
const str = 'JavaScript';
const char = str[4];
alert(str[-2]); // undefined
console.log(char); // "S"
```

---

#### **4. Извлечение подстроки с помощью `substring`**

Метод возвращает подстроку между двумя индексами.

```javascript
const str = 'JavaScript';
const substr = str.substring(4, 10); // Индекс начала включается, а конец — нет
console.log(substr); // "Script"
```

---

#### **5. Использование метода `substr` (устарел)**

Метод возвращает часть строки, начиная с указанного индекса и заданной длины. Этот метод устарел, но всё ещё работает.

```javascript
const str = 'JavaScript';
const substr = str.substr(4, 6); // Начинаем с индекса 4 и берём 6 символов
console.log(substr); // "Script"
```

---

#### **6. Извлечение с помощью `slice`**

Метод похож на `substring`, но поддерживает отрицательные индексы.

```javascript
const str = 'JavaScript';
const substr = str.slice(4, -1); // С 4-го символа до предпоследнего
console.log(substr); // "Scrip"
```

---

#### **7. Доступ к последнему символу строки**

Для получения последнего символа можно использовать длину строки.

```javascript
const str = 'JavaScript';
const lastChar = str[str.length - 1];
console.log(lastChar); // "t"
```

---

#### **8. Получение нескольких символов с помощью `split`**

Если нужно получить массив символов, можно использовать `split`.

```javascript
const str = 'JavaScript';
const chars = str.split(''); // Разбиваем строку на массив символов
console.log(chars[4]); // "S"
console.log(chars); // ["J", "a", "v", "a", "S", "c", "r", "i", "p", "t"]
```

---

#### **9. Получение символов с помощью `for..of`**

Также можно перебрать строку посимвольно, используя `for..of`:

```js
for (let char of 'Hello') {
  alert(char); // H,e,l,l,o (char — сначала "H", потом "e", потом "l" и т.д.)
}
```

---

#### **Итог**

Выбор способа зависит от ваших потребностей:

- Для извлечения отдельного символа: `charAt` или `[]`.
- Для извлечения подстроки: `substring`, `slice` или (в редких случаях) `substr`.
- Для работы с массивами символов: `split`.

---

## **3. Логический тип (Boolean)**

Логическое (или булевое) значение - это примитивный тип данных, который может содержать в себе `true` или `false` (истина или ложь). JavaScript использует приведение типа, чтобы привести значение к `true\false`. Есть явные и скрытые методы преобразования значений в их логические аналоги.

```js
let nameFieldChecked = true; // да, поле отмечено
let ageFieldChecked = false; // нет, поле не отмечено
```

Булевые значения также могут быть результатом сравнений:

```js
let isGreater = 4 > 1;

alert(isGreater); // true (результатом сравнения будет "да")
```

### **Используется:**

- В условиях (`if`, `while`).
- В логических операциях (`&&`, `||`, `!`).

### Приведение типов

- `Boolean()` - это глобальная функция, которая конвертирует значение, переданное в него, в логическое. Не стоит использовать его с ключевым словом `new` (`new Boolean`), т.к. это создает сущность Boolean, которая является объектом.
- Двойное отрицание при помощи оператора `!`. Двойной оператор `!!` действует следующим образом: первый знак `!` приводит значение к логическому и инвертирует его. Например, `!true` равняется `false`. Второй оператор `!` снова инвертирует полученное значение. В нашем примере `!false` приравнивается к `true`.

Значения, приводимые к `false`: `false`, `0`, `""`, `null`, `undefined`, `NaN`. Всё остальное — `true`.

```js
// False
Boolean(false); // false
Boolean(undefined); // false
Boolean(null); // false
Boolean(!!null); // false
Boolean(''); // false
Boolean(NaN); // false
Boolean(0); // false
Boolean(-0); // false
Boolean(0n); // false
// True
Boolean(true); // true
Boolean('hi'); // true
Boolean(1); // true
Boolean([]); // true
Boolean([0]); // true
Boolean([1]); // true
Boolean({}); // true
Boolean({ a: 1 }); // true
```

### **Примеры:**

```javascript
let isOnline = true;
let hasAccess = false;

console.log(isOnline && hasAccess); // false
console.log(isOnline || hasAccess); // true
console.log(!isOnline); // false
```

---

## **4. `null`**

Специальное значение, которое указывает на "ничто" или "пустое место" или «значение неизвестно». Оно формирует отдельный тип, который содержит только значение `null`.

В JavaScript `null` не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках.

### **Особенности:**

- Присваивается вручную, чтобы показать отсутствие значения.
- Все JavaScript-программисты давно привыкли к тому, что `typeof null === 'object'; // true`, хотя фактически null — примитивное значение. Многие знают, что это баг, и лично Брэндан Айк это [признает](http://wiki.ecmascript.org/doku.php?id=harmony:typeof_null). Этот баг, вероятно, никогда не будет исправлен из-за необходимости сохранения обратной совместимости существующего кода с новыми версиями языка.

### **Примеры:**

```javascript
let user = null;
console.log(user); // null
console.log(typeof user); // "object" (ошибка языка)
```

---

## **5. `undefined`**

Специальное значение `undefined` также стоит особняком. Оно формирует тип из самого себя так же, как и `null`. Значение переменной, которая была объявлена, но не инициализирована, то есть переменой не было присвоено значение.

### **Особенности:**

- Появляется автоматически, если переменная или свойство объекта не инициализированы.

### **Примеры:**

```javascript
let x;
console.log(x); // undefined
console.log(typeof x); // "undefined"
```

Технически мы можем присвоить значение `undefined` любой переменной:

```js
let age = 123;

// изменяем значение на undefined
age = undefined;

alert(age); // "undefined"
```

…Но так делать не рекомендуется. Обычно `null` используется для присвоения переменной «пустого» или «неизвестного» значения, а `undefined` – для проверок, была ли переменная назначена.

---

## **6. Символы (Symbol)**

Уникальные идентификаторы. Используются для создания уникальных свойств объектов. Символы являются нововведением JavaScript начиная с ECMAScript 2015. Символ — это **уникальное** и **иммутабельное** примитивное значение, которое может быть использовано как ключ для свойства объекта

### **Особенности:**

- Не равны друг другу, даже если имеют одинаковое описание.

### **Примеры:**

```javascript
let sym1 = Symbol('id');
let sym2 = Symbol('id');

console.log(sym1 === sym2); // false
console.log(typeof sym1); // "symbol"
```

---

## **7. BigInt**

Тип данных для работы с большими числами, которые выходят за пределы `Number`.

> [!IMPORTANT]
>
> **Поддержка**
>
> В данный момент BigInt поддерживается только в браузерах Firefox, Chrome, Edge и Safari, но не поддерживается в IE.

Чтобы создать значение типа `BigInt`, необходимо добавить n в конец числового литерала или вызвать функцию `BigInt()`, которая создаст число типа `BigInt` из переданного аргумента. Аргументом может быть число, строка и др.

### **Особенности:**

- Добавляется суффикс `n` к числу.
- Не смешивается с `Number`.

### **Примеры:**

```javascript
let big = 123456789012345678901234567890n;
let small = 10;
const sameBigint = BigInt('1234567890123456789012345678901234567890');
const bigintFromNumber = BigInt(10); // то же самое, что и 10n

console.log(big + 1n); // 123456789012345678901234567891n
// console.log(big + small); // Ошибка: нельзя смешивать BigInt и Number
```

### **Математические операторы**

`BigInt` можно использовать как обычные числа, к примеру:

```js
alert(1n + 2n); // 3

alert(5n / 2n); // 2
```

Обратите внимание: операция деления `5/2` возвращает округлённый результат, без дробной части. Все операции с числами типа `bigint` возвращают `bigint`.

В математических операциях мы не можем смешивать `bigint` и обычные числа:

```js
alert(1n + 2); // Error: Cannot mix BigInt and other types
```

Мы должны явно их конвертировать: используя либо `BigInt()`, либо `Number()`, например:

```js
let bigint = 1n;
let number = 2;

// конвертируем number в bigint
alert(bigint + BigInt(number)); // 3

// конвертируем `bigint` в number
alert(Number(bigint) + number); // 3
```

Конвертирование `bigint` в число всегда происходит неявно и без генерации ошибок, но если значение `bigint` слишком велико и не подходит под тип `number`, то дополнительные биты будут отброшены, так что следует быть осторожными с такими преобразованиями.

> [!IMPORTANT]
>
> К `BigInt` числам нельзя применить унарный оператор `+`
>
> Унарный оператор `+value` является хорошо известным способом конвертировать произвольное значение `value` в число.
>
> Данный оператор не поддерживается при работе с `BigInt` числами:
>
> ```js
> let bigint = 1n;
>
> alert(+bigint); // Ошибка!
> ```
>
> Мы должны использовать `Number()` для преобразования `bigint` к `number`.

### **Операции сравнения**

Операции сравнения, такие как `<`, `>`, работают с `bigint` и обычными числами как обычно:

```js
alert(2n > 1n); // true

alert(2n > 1); // true
```

Пожалуйста, обратите внимание, что обычные и `bigint` числа принадлежат к разным типам, они могут быть равны только при нестрогом сравнении `==`:

```js
alert(1 == 1n); // true

alert(1 === 1n); // false
```

### **Логические операции**

В `if` или любом другом логическом операторе `bigint` число ведёт себя как обычное число.

К примеру, в `if bigint 0n` преобразуется в `false`, другие значения преобразуются в `true`:

```js
if (0n) {
  // никогда не выполнится
}
```

Логические операторы `||`, `&&` и другие также работают с `bigint` числами как с обычными числами:

```js
alert(1n || 2); // 1

alert(0n || 2); // 2
```

### **Полифилы**

Создание полифила для `BigInt` – достаточно непростая задача. Причина в том, что многие операторы в JavaScript, такие как `+`, `-` и др., ведут себя по-разному с `bigint` по сравнению с обычными числами.

К примеру, деление `bigint` числа всегда возвращает `bigint` (округлённое при необходимости).

Чтобы эмулировать такое поведение, полифил должен будет проанализировать код и заменить все такие операторы на свои вызовы. Такая реализация будет тяжеловесной, не очень хорошей с точки зрения производительности.

Вот почему на данный момент нет хорошо реализованного полифила.

Существует обратное решение, предложеное разработчиками библиотеки **JSBI**.

Эта библиотека реализует большие числа, используя собственные методы. Мы можем использовать их вместо встроенных `BigInt`:

| Операция           | Встроенный      | BigInt JSBI             |
| ------------------ | --------------- | ----------------------- |
| Создание из number | a = BigInt(789) | a = JSBI.BigInt(789)    |
| Сложение           | c = a + b       | c = JSBI.add(a, b)      |
| Вычитание          | c = a - b       | c = JSBI.subtract(a, b) |

…А затем использовать полифил (плагин **Babel**) для замены вызовов **JSBI** на встроенные `Bigint` для браузеров, которые их поддерживают.

Другими словами, данный подход предлагает использовать **JSBI** вместо встроенных `BigInt`. **JSBI** внутри себя работает с числами как с `BigInt`, эмулирует их с соблюдением всех требований спецификации. Таким образом, мы можем выполнять JSBI-код в интерпретаторах, которые не поддерживают `Bigint`, а для тех, которые поддерживают – полифил преобразует вызовы в обычные `Bigint`.

---

## Отличие `Number` от `BigInt`

`Number` и `BigInt` — это числовые типы данных в JavaScript, но они имеют различия в назначении, представлении, возможностях и ограничениях.

### **1. Диапазон значений**

#### **Number**

- Основан на формате **IEEE 754 (64-битный)**, использует 53 бита для представления значащих цифр.
- Диапазон:
  - Максимум: `±2**53−1` - `(9,007,199,254,740,991)`.
  - Числа за пределами этого диапазона теряют точность.

#### **BigInt**

- Поддерживает произвольную длину числа.
- Может представлять числа за пределами диапазона `Number` без потери точности.

**Пример:**

```javascript
let big = 1234567890123456789012345678901234567890n; // BigInt
let num = 12345678901234567890; // Number (потеря точности)

console.log(big); // 1234567890123456789012345678901234567890n
console.log(num); // 12345678901234567168 (потеря точности)
```

---

### **2. Тип данных**

- `Number`: используется для чисел с плавающей точкой (дробные и целые).
- `BigInt`: используется только для целых чисел.

**Пример:**

```javascript
let num = 1.23; // Допустимо для Number
let big = 10n; // Допустимо для BigInt
// let invalid = 1.23n; // Ошибка: BigInt не поддерживает дробные числа
```

---

### **3. Операции и совместимость**

- **Смешивание `Number` и `BigInt` недопустимо:**  
   Операции между `Number` и `BigInt` вызовут ошибку.
  ```javascript
  let big = 10n;
  let num = 5;
  // console.log(big + num); // Ошибка: нельзя смешивать BigInt и Number
  ```
- **Приведение типов:**  
   Чтобы выполнить операции, нужно явно преобразовать тип.

  ```javascript
  let big = 10n;
  let num = 5;

  console.log(big + BigInt(num)); // 15n
  console.log(Number(big) + num); // 15
  ```

---

### **4. Производительность**

- `BigInt` работает медленнее, чем `Number`, из-за необходимости обработки произвольной длины числа.
- Используйте `BigInt`, только если требуется точность для больших чисел.

---

### **5. Специальные значения**

- `Number` имеет значения `Infinity`, `-Infinity`, и `NaN`.
- `BigInt` не поддерживает такие значения.

**Пример:**

```javascript
console.log(1 / 0); // Infinity (Number)
console.log(BigInt(1) / 0n); // Ошибка: деление на ноль
```

---

### **Когда использовать BigInt?**

- Если вы работаете с числами больше 253−12^{53} - 1.
- Для вычислений, требующих высокой точности (например, криптография, работа с длинными идентификаторами).

---

### **Сравнение с учетом особенностей**

| Особенность          | `Number`                       | `BigInt`                 |
| -------------------- | ------------------------------ | ------------------------ |
| Тип                  | Число с плавающей точкой       | Только целые числа       |
| Диапазон             | ±253−12^{53} - 1               | Ограничен только памятью |
| Потеря точности      | Да (за пределами диапазона)    | Нет                      |
| Специальные значения | `Infinity`, `-Infinity`, `NaN` | Не поддерживает          |
| Производительность   | Быстрее                        | Медленнее                |

---

## **8. Объекты (Object)**

Объект (`Object`) — это один из ключевых типов данных в JavaScript, который используется для хранения коллекций данных и более сложных сущностей. Объекты создаются как наборы пар "ключ-значение", где ключами могут быть строки или символы, а значениями — любые данные.

### **Примеры:**

```javascript
let user = {
  name: 'Alice',
  age: 30,
};

console.log(user.name); // Alice
console.log(typeof user); // "object"
```

### **1. Создание объектов**

#### **1.1. Литерал объекта**

Самый простой способ создать объект — использовать фигурные скобки `{}`.

```javascript
let person = {
  name: 'John',
  age: 30,
  isEmployed: true,
};
```

#### **1.2. Конструктор `Object`**

Используется редко, но иногда полезен.

```javascript
let person = new Object();
person.name = 'John';
person.age = 30;
```

#### **1.3. С помощью `Object.create(proto)`**

Создаёт объект с указанным прототипом.

```javascript
let proto = { greet: () => console.log('Hello!') };
let obj = Object.create(proto);
obj.name = 'Alice';
console.log(obj.greet()); // "Hello!"
```

---

### **2. Доступ к свойствам**

#### **2.1. Точечная нотация**

Используется, когда имя свойства известно и соответствует правилам идентификаторов.

```javascript
console.log(person.name); // "John"
```

#### **2.2. Квадратные скобки**

Позволяет работать с динамическими или невалидными именами свойств (например, с пробелами или символами).

```javascript
console.log(person['name']); // "John"

let key = 'age';
console.log(person[key]); // 30
```

---

### **3. Добавление, обновление и удаление свойств**

#### **Добавление и обновление**

Можно просто присвоить значение свойству.

```javascript
person.city = 'New York'; // добавление
person.age = 31; // обновление
console.log(person); // {name: "John", age: 31, isEmployed: true, city: "New York"}
```

#### **Удаление**

Используйте оператор `delete`.

```javascript
delete person.city;
console.log(person); // {name: "John", age: 31, isEmployed: true}
```

---

### **4. Перебор свойств объекта**

#### **4.1. `for...in`**

Перебирает все перечисляемые свойства объекта.

```javascript
for (let key in person) {
  console.log(`${key}: ${person[key]}`);
}
// name: John
// age: 30
// isEmployed: true
```

#### **4.2. `Object.keys()`**

Возвращает массив ключей.

```javascript
console.log(Object.keys(person)); // ["name", "age", "isEmployed"]
```

#### **4.3. `Object.values()`**

Возвращает массив значений.

```javascript
console.log(Object.values(person)); // ["John", 30, true]
```

#### **4.4. `Object.entries()`**

Возвращает массив пар `[ключ, значение]`.

```javascript
console.log(Object.entries(person)); // [["name", "John"], ["age", 30], ["isEmployed", true]]
```

---

### **5. Копирование объектов**

#### **5.1. Поверхностное копирование с `Object.assign()`**

```javascript
let clone = Object.assign({}, person);
console.log(clone); // {name: "John", age: 30, isEmployed: true}
```

#### **5.2. Поверхностное копирование с оператором распространения (`...`)**

```javascript
let clone = { ...person };
console.log(clone); // {name: "John", age: 30, isEmployed: true}
```

#### **5.3. Глубокое копирование**

Для вложенных объектов используйте `structuredClone()` или библиотеки вроде Lodash.

```javascript
let deepClone = structuredClone(person);
```

---

### **6. Методы объекта**

Объекты могут содержать методы — функции, которые являются свойствами объекта.

#### **Пример:**

```javascript
let person = {
  name: 'John',
  age: 30,
  greet() {
    console.log(`Hello, my name is ${this.name}`);
  },
};

person.greet(); // "Hello, my name is John"
```

---

### **7. Специальные возможности и методы `Object`**

#### **`Object.freeze(obj)`**

Замораживает объект: невозможно добавить, удалить или изменить свойства.

```javascript
let frozen = Object.freeze({ name: 'John' });
frozen.name = 'Alice'; // Ошибка в строгом режиме
```

#### **`Object.seal(obj)`**

Запрещает добавление и удаление свойств, но изменение существующих разрешено.

```javascript
let sealed = Object.seal({ name: 'John' });
sealed.name = 'Alice'; // Работает
delete sealed.name; // Ошибка в строгом режиме
```

#### **`Object.isFrozen(obj)` и `Object.isSealed(obj)`**

Проверяют, заморожен или запечатан объект.

```javascript
console.log(Object.isFrozen(frozen)); // true
console.log(Object.isSealed(sealed)); // true
```

#### **`Object.getOwnPropertyDescriptors(obj)`**

Возвращает описание всех свойств объекта.

```javascript
console.log(Object.getOwnPropertyDescriptors(person));
/*
{
  name: {value: "John", writable: true, enumerable: true, configurable: true},
  age: {value: 30, writable: true, enumerable: true, configurable: true}
}
*/
```

#### **`Object.hasOwn(obj, key)`**

Проверяет, является ли свойство собственным (не из прототипа).

```javascript
console.log(Object.hasOwn(person, 'name')); // true
```

---

### **8. Прототипы и наследование**

Объекты могут наследовать свойства и методы через прототипы.

#### **Пример:**

```javascript
let animal = {
  eats: true,
  walk() {
    console.log('Animal walks');
  },
};

let rabbit = Object.create(animal);
rabbit.jumps = true;

console.log(rabbit.eats); // true (унаследовано)
rabbit.walk(); // "Animal walks"
```

---

### **9. Пример практической работы с объектом**

```javascript
let car = {
  brand: 'Toyota',
  model: 'Camry',
  year: 2020,
  getInfo() {
    return `${this.brand} ${this.model}, ${this.year}`;
  },
};

console.log(car.getInfo()); // "Toyota Camry, 2020"

car.owner = 'John';
console.log(Object.keys(car)); // ["brand", "model", "year", "getInfo", "owner"]

delete car.year;
console.log(car); // {brand: "Toyota", model: "Camry", getInfo: [Function: getInfo], owner: "John"}
```

---
