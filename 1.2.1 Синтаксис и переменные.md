# **1.2.1 Синтаксис и переменные**

> [Index](./0%20Index.md)

## **Синтаксис**

Инструкции – это синтаксические конструкции и команды, которые выполняют действия. В коде может быть столько инструкций, сколько мы захотим. Инструкции могут отделяться точкой с запятой.

Например, здесь мы разделили сообщение «Привет Мир» на два вызова alert:

```
alert('Привет'); alert('Мир');
```

Обычно каждую инструкцию пишут на новой строке, чтобы код было легче читать:

```js
alert('Привет');
alert('Мир');
```

### Точка с запятой

В большинстве случаев точку с запятой можно не ставить, если есть переход на новую строку.

Так тоже будет работать:

```
alert('Привет')
alert('Мир')
```

В этом случае JavaScript интерпретирует перенос строки как «неявную» точку с запятой. Это называется автоматическая вставка точки с запятой.

В большинстве случаев новая строка подразумевает точку с запятой. Но «в большинстве случаев» не значит «всегда»!

В некоторых ситуациях новая строка всё же не означает точку с запятой. Например:

```
alert(3 +
1

- 2);
```

Код выведет 6, потому что JavaScript не вставляет здесь точку с запятой. Интуитивно очевидно, что, если строка заканчивается знаком "+", значит, это «незавершённое выражение», поэтому точка с запятой не требуется. И в этом случае всё работает, как задумано.

Но есть ситуации, где JavaScript «забывает» вставить точку с запятой там, где она нужна и ошибки, которые при этом появляются, достаточно сложно обнаруживать и исправлять.

> [!TIP]
>
> **Пример ошибки**
>
> Если вы хотите увидеть конкретный пример такой ошибки, обратите внимание на этот код:
>
> ```js
> alert('Hello');
>
> [1, 2].forEach(alert);
> ```
>
> Пока нет необходимости знать значение скобок `[]` и `forEach`. Мы изучим их позже. Пока что просто запомните результат выполнения этого кода: выводится Hello, затем 1, затем 2.
>
> А теперь давайте уберем точку с запятой после alert:
>
> ```
> alert('Hello')
>
> [1, 2].forEach(alert);
> ```
>
> Этот код отличается от кода, приведенного выше, только в одном: пропала точка с запятой в конце первой строки.
>
> Если мы запустим этот код, выведется только первый `alert`, а затем мы получим ошибку (вам может потребоваться открыть консоль, чтобы увидеть её)!
>
> Это потому что JavaScript не вставляет точку с запятой перед квадратными скобками `[...]`. И поэтому код в последнем примере выполняется, как одна инструкция.
>
> Вот как движок видит его:
>
> ```js
> alert('Hello')[(1, 2)].forEach(alert);
> ```
>
> Выглядит странно, правда? Такое слияние в данном случае неправильное. Мы должны поставить точку с запятой после `alert`, чтобы код работал правильно.
>
> Это может произойти и в некоторых других ситуациях.

Рекомендуется ставить точку с запятой между инструкциями, даже если они отделены переносами строк. Это правило широко используется в сообществе разработчиков. Стоит отметить ещё раз – в большинстве случаев можно не ставить точку с запятой. Но безопаснее, особенно для новичка, ставить её.

### Комментарии

Со временем программы становятся всё сложнее и сложнее. Возникает необходимость добавлять комментарии, которые бы описывали, что делает код и почему.

Комментарии могут находиться в любом месте скрипта. Они не влияют на его выполнение, поскольку движок просто игнорирует их.

Однострочные комментарии начинаются с двойной косой черты `//`.

Часть строки после `//` считается комментарием. Такой комментарий может как занимать строку целиком, так и находиться после инструкции.

Как здесь:

```js
// Этот комментарий занимает всю строку
alert('Привет');

alert('Мир'); // Этот комментарий следует за инструкцией
```

Многострочные комментарии начинаются косой чертой со звёздочкой `/*` и заканчиваются звёздочкой с косой чертой `*/`.

Как вот здесь:

```js
/* Пример с двумя сообщениями.
Это - многострочный комментарий.
*/
alert('Привет');
alert('Мир');
```

Содержимое комментария игнорируется, поэтому, если мы поместим код внутри `/* … */`, он не будет исполняться.

Это бывает удобно для временного отключения участка кода:

```js
/* Закомментировали код
alert('Привет');
*/
alert('Мир');
```

> [!TIP]
>
> **Используйте горячие клавиши!**
>
> В большинстве редакторов строку кода можно закомментировать, нажав комбинацию клавиш `Ctrl+/` для однострочного комментария и что-то вроде `Ctrl+Shift+/` – для многострочных комментариев (выделите кусок кода и нажмите комбинацию клавиш). В системе Mac попробуйте Cmd вместо Ctrl и Option вместо Shift.

> [!WARNING]
>
> **Вложенные комментарии не поддерживаются!**
>
> Не может быть `/*...*/` внутри `/*...*/`.
>
> Такой код «умрёт» с ошибкой:
>
> ```js
> /*
> /* вложенный комментарий ?!? */
> */
> alert( 'Мир' );
> ```

Не стесняйтесь использовать комментарии в своём коде.

Комментарии увеличивают размер кода, но это не проблема. Есть множество инструментов, которые минифицируют код перед публикацией на рабочий сервер. Они убирают комментарии, так что они не содержатся в рабочих скриптах. Таким образом, комментарии никоим образом не вредят рабочему коду.

### **Синтаксический сахар**

**Синтаксический сахар (syntactic sugar)** — это элемент синтаксиса языка программирования, который упрощает запись кода и делает его более понятным для человека, при этом не добавляя новых возможностей или функционала. Он существует исключительно для удобства разработчиков, улучшая читаемость и сокращая объем кода.

> [!NOTE]
>
> **Особенности синтаксического сахара**
>
> - Не добавляет новой логики или функциональности.
> - Упрощает и делает код более лаконичным.
> - Часто используется для сокращения шаблонного кода.
> - За кулисами преобразуется в более базовую форму во время компиляции или интерпретации.

#### **1. Тернарный оператор**

- Тернарный оператор (`? :`) — синтаксический сахар для условных операторов `if...else`.

**Код без синтаксического сахара:**

```javascript
let result;
if (x > 10) {
  result = 'Больше 10';
} else {
  result = 'Меньше или равно 10';
}
```

**Код с синтаксическим сахаром:**

```javascript
let result = x > 10 ? 'Больше 10' : 'Меньше или равно 10';
```

---

#### **2. Стрелочные функции (arrow functions)**

- В JavaScript стрелочные функции — это синтаксический сахар для сокращения записи анонимных функций.

**Без стрелочных функций:**

```javascript
const add = function (a, b) {
  return a + b;
};
```

**С использованием стрелочных функций:**

```javascript
const add = (a, b) => a + b;
```

---

#### **3. Деструктуризация**

- Деструктуризация позволяет извлекать значения из объектов или массивов более компактно.

**Без деструктуризации:**

```javascript
const person = { name: 'Alice', age: 25 };
const name = person.name;
const age = person.age;
```

**С деструктуризацией:**

```javascript
const { name, age } = person;
```

---

#### **4. Шаблонные строки**

- Шаблонные строки — это сахар для объединения строк с помощью конкатенации.

**Без шаблонных строк:**

```javascript
const name = 'Alice';
const greeting = 'Привет, ' + name + '!';
```

**С использованием шаблонных строк:**

```javascript
const greeting = `Привет, ${name}!`;
```

---

#### **5. Операторы `??` и `?.`**

- Оператор **нулевого слияния (`??`)** и **опциональная цепочка (`?.`)** упрощают проверку на `null` или `undefined`.

**Без синтаксического сахара:**

```javascript
let value = obj && obj.prop ? obj.prop : 'default';
```

**С использованием `?.` и `??`:**

```javascript
let value = obj?.prop ?? 'default';
```

---

> [!NOTE]
>
> **Преимущества синтаксического сахара**
>
> 1.  **Читаемость**: Код становится проще для понимания.
> 2.  **Сокращение кода**: Уменьшается количество строк и повторяющихся шаблонов.
> 3.  **Меньше ошибок**: Благодаря упрощению конструкции снижается вероятность допустить ошибку.

> [!WARNING]
>
> **Недостатки синтаксического сахара**
>
> 1.  **Скрытая сложность**: Если не знать, как сахар работает под капотом, можно столкнуться с непредсказуемым поведением.
> 2.  **Учебная нагрузка**: Новичкам иногда сложнее понять код, насыщенный синтаксическим сахаром.
> 3.  **Сложность отладки**: После трансформации (например, через Babel) отладка может стать менее интуитивной.

> [!IMPORTANT]
>
> **Заключение**
>
> Синтаксический сахар — это мощный инструмент, который делает код лаконичным и понятным. Однако важно помнить, что он не меняет сути работы кода, а лишь упрощает его запись. Используйте его разумно, чтобы поддерживать баланс между удобством и ясностью.

## **Переменные**

Переменные в JavaScript — это именованные контейнеры для хранения данных. Особенности их объявления и поведения зависят от используемого ключевого слова (директивой): `var`, `let` или `const`.

- `var`: устаревший способ объявления переменной, избегайте его использования.
- `let`: используется для переменных, значение которых может изменяться.
- `const`: для переменных, значение которых не изменяется.

**Пример кода:**

```javascript
let name = 'Alice'; // Переменная, которая может изменяться
const age = 25; // Переменная, которая не может изменяться
var city = 'London'; // Устаревший способ (не рекомендуется)

console.log(name); // Выведет: Alice
console.log(age); // Выведет: 25
```

### **Объявление переменной**

Для создания переменной в JavaScript используйте ключевое слово `let`.

Приведённая ниже инструкция создаёт (другими словами, объявляет) переменную с именем `«message»`:

```js
let message;
```

Теперь можно поместить в неё данные (другими словами, определить переменную), используя оператор присваивания `=`:

```js
let message;
message = 'Hello'; // сохранить строку 'Hello' в переменной с именем message
```

Строка сохраняется в области памяти, связанной с переменной. Мы можем получить к ней доступ, используя имя переменной:

```js
let message;
message = 'Hello!';

alert(message); // показывает содержимое переменной
```

Для краткости можно совместить объявление переменной и запись данных в одну строку:

```js
let message = 'Hello!'; // определяем переменную и присваиваем ей значение

alert(message); // Hello!
```

Мы также можем объявить несколько переменных в одной строке:

```
let user = 'John', age = 25, message = 'Hello';
```

Такой способ может показаться короче, но мы не рекомендуем его. Для лучшей читаемости объявляйте каждую переменную на новой строке.

Многострочный вариант немного длиннее, но легче для чтения:

```js
let user = 'John';
let age = 25;
let message = 'Hello';
```

Некоторые люди также определяют несколько переменных в таком вот многострочном стиле:

```js
let user = 'John',
  age = 25,
  message = 'Hello';
```

…Или даже с запятой в начале строки:

```
let user = 'John'
  , age = 25
  , message = 'Hello';
```

В принципе, все эти варианты работают одинаково. Так что это вопрос личного вкуса и эстетики.

### **Ограничения**

В JavaScript есть два ограничения, касающиеся имён переменных:

- Имя переменной должно содержать только буквы, цифры или символы `$` и `_`.
- Первый символ не должен быть цифрой.

Если имя содержит несколько слов, обычно используется `верблюжья нотация`, то есть, слова следуют одно за другим, где каждое следующее слово начинается с заглавной буквы: `myVeryLongName`.

Самое интересное – знак доллара `'$'` и подчёркивание `'_'` также можно использовать в названиях. Это обычные символы, как и буквы, без какого-либо особого значения.

Эти имена являются допустимыми:

```js
let $ = 1; // объявили переменную с именем "$"
let _ = 2; // а теперь переменную с именем "_"

alert($ + _); // 3
```

Примеры неправильных имён переменных:

```js
let 1a; // не может начинаться с цифры
let my-name; // дефис '-' не разрешён в имени
```

> [!NOTE]
>
> **Нелатинские буквы разрешены, но не рекомендуются**
>
> Можно использовать любой язык, включая кириллицу или даже иероглифы, например:
>
> ```js
> let имя = '...';
> let 我 = '...';
> ```
>
> Технически здесь нет ошибки, такие имена разрешены, но есть международная традиция использовать английский язык в именах переменных. Даже если мы пишем небольшой скрипт, у него может быть долгая жизнь впереди. Людям из других стран, возможно, придётся прочесть его не один раз.

> [!WARNING]
>
> **Регистр имеет значение**
>
> Переменные с именами `apple` и `APPLE` – это две разные переменные.

> [!CAUTION]
>
> **Зарезервированные имена**
>
> Существует список [зарезервированных слов](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Lexical_grammar#%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%B5_%D1%81%D0%BB%D0%BE%D0%B2%D0%B0), которые нельзя использовать в качестве имён переменных, потому что они используются самим языком.
>
> Например: `let`, `class`, `return` и `function` зарезервированы.
>
> Приведённый ниже код даёт синтаксическую ошибку:
>
> ```js
> let let = 5; // нельзя назвать переменную "let", ошибка!
> let return = 5; // также нельзя назвать переменную "return", ошибка!
> ```

> [!CAUTION]
>
> **Создание переменной без использования `use strict`**
>
> Обычно нам нужно определить переменную перед её использованием. Но в старые времена было технически возможно создать переменную простым присвоением значения без использования `let`. Это все ещё работает, если мы не включаем `use strict` в наших файлах, чтобы обеспечить совместимость со старыми скриптами.
>
> ```js
> // заметка: "use strict" в этом примере не используется
>
> num = 5; // если переменная "num" раньше не существовала, она создаётся
>
> alert(num); // 5
> ```
>
> Это плохая практика, которая приводит к ошибке в строгом режиме:
>
> ```js
> 'use strict';
>
> num = 5; // ошибка: num is not defined
> ```

### **Константы**

Широко распространена практика использования констант в качестве псевдонимов для трудно запоминаемых значений, которые известны до начала исполнения скрипта.

Названия таких констант пишутся с использованием заглавных букв и подчёркивания.

Например, сделаем константы для различных цветов в «шестнадцатеричном формате»:

```js
const COLOR_RED = '#F00';
const COLOR_GREEN = '#0F0';
const COLOR_BLUE = '#00F';
const COLOR_ORANGE = '#FF7F00';

// ...когда нам нужно выбрать цвет
let color = COLOR_ORANGE;
alert(color); // #FF7F00
```

> [!TIP]
>
> **Преимущества:**
>
> `COLOR_ORANGE` гораздо легче запомнить, чем `"#FF7F00"`.
> Гораздо легче допустить ошибку при вводе `"#FF7F00"`, чем при вводе `COLOR_ORANGE`.
> При чтении кода `COLOR_ORANGE` намного понятнее, чем `#FF7F00`.

**Когда мы должны использовать для констант заглавные буквы, а когда называть их нормально?**

Название «константа» просто означает, что значение переменной никогда не меняется. Но есть константы, которые известны до выполнения (например, шестнадцатеричное значение для красного цвета), а есть константы, которые вычисляются во время выполнения сценария, но не изменяются после их первоначального назначения.

Например:

```js
const pageLoadTime = /* время, потраченное на загрузку веб-страницы */;
```

Значение `pageLoadTime` неизвестно до загрузки страницы, поэтому её имя записано обычными, а не прописными буквами. Но это всё ещё константа, потому что она не изменяется после назначения.

Другими словами, константы с именами, записанными заглавными буквами, используются только как псевдонимы для **«жёстко закодированных»** значений.

### **Названия переменных**

В разговоре о переменных необходимо упомянуть, что есть ещё одна чрезвычайно важная вещь.

Название переменной должно иметь ясный и понятный смысл, говорить о том, какие данные в ней хранятся.

Именование переменных – это один из самых важных и сложных навыков в программировании. Быстрый взгляд на имена переменных может показать, какой код был написан новичком, а какой – опытным разработчиком.

В реальном проекте большая часть времени тратится на изменение и расширение существующей кодовой базы, а не на написание чего-то совершенно нового с нуля. Когда мы возвращаемся к коду после какого-то промежутка времени, гораздо легче найти информацию, которая хорошо размечена. Или, другими словами, когда переменные имеют хорошие имена.

Пожалуйста, потратьте время на обдумывание правильного имени переменной перед её объявлением. Делайте так, и будете вознаграждены.

> [!TIP]
>
> **Несколько хороших правил:**
>
> - Используйте легко читаемые имена, такие как `userName` или `shoppingCart`.
> - Избегайте использования аббревиатур или коротких имён, таких как `a`, `b`, `c`, за исключением тех случаев, когда вы точно знаете, что так нужно.
> - Делайте имена максимально описательными и лаконичными. Примеры плохих имён: `data` и `value`. Такие имена ничего не говорят. Их можно использовать только в том случае, если из контекста кода очевидно, какие данные хранит переменная.
> - Договоритесь с вашей командой об используемых терминах. Если посетитель сайта называется `«user»`, тогда мы должны называть связанные с ним переменные `currentUser` или `newUser`, а не, к примеру, `currentVisitor` или `newManInTown`.

Звучит просто? Действительно, это так, но на практике для создания описательных и кратких имён переменных зачастую требуется подумать.

> [!IMPORTANT]
>
> **Повторно использовать или создавать новую переменную?**
>
> Есть ленивые программисты, которые вместо объявления новых переменных повторно используют существующие.
>
> В результате их переменные похожи на коробки, в которые люди бросают разные предметы, не меняя на них этикетки. Что сейчас находится внутри коробки? Кто знает? Нам необходимо подойти поближе и проверить.
>
> Такие программисты немного экономят на объявлении переменных, но теряют в десять раз больше при отладке.
>
> Дополнительная переменная – это добро, а не зло.
>
> Современные JavaScript-минификаторы и браузеры оптимизируют код достаточно хорошо, поэтому он не создаёт проблем с производительностью. Использование разных переменных для разных значений может даже помочь движку оптимизировать ваш код.

### **1. `var` (устаревший способ)**

- **Особенности:**
  1. **Функциональная область видимости (function scope):**  
     Переменные, объявленные с `var`, доступны внутри всей функции, в которой они объявлены.
  2. **Поднятие (hoisting):**  
     Переменная, объявленная через `var`, "поднимается" к началу своей области видимости, но значение остается `undefined` до момента присвоения.
  3. **Не ограничена блоком:**  
     Если `var` объявлена внутри блока (`if`, `for`), она все равно доступна за его пределами.
- **Пример:**

```javascript
if (true) {
  var x = 10; // доступна за пределами блока
}
console.log(x); // 10
```

#### **Почему не следует использовать `var`?**

1. **Неявное поднятие (hoisting):**  
   Переменные `var` поднимаются, что может приводить к путанице.

   ```javascript
   console.log(a); // undefined
   var a = 10;
   ```

2. **Неограниченная область видимости:**  
   Переменная `var` доступна за пределами блока, где она объявлена. Это может привести к ошибкам.

   ```javascript
   for (var i = 0; i < 5; i++) {
     console.log(i); // 0, 1, 2, 3, 4
   }
   console.log(i); // 5 (ожидали, что i будет недоступна)
   ```

3. **Нет защиты от повторного объявления:**  
   Переменная `var` может быть объявлена несколько раз, что сложно отследить.

   ```javascript
   var x = 10;
   var x = 20; // допустимо, но нежелательно
   console.log(x); // 20
   ```

4. **Проблемы с отладкой:**  
   Поведение `var` может быть непредсказуемым, особенно в сложных функциях с вложенными блоками.

### **2. `let` (современный способ)**

Объяснение, почему было выбрано название "let" можно найти [здесь](https://stackoverflow.com/questions/37916940/why-was-the-name-let-chosen-for-block-scoped-variable-declarations-in-javascri).

- **Особенности:**

  1. **Блочная область видимости (block scope):**  
      Областью видимости переменных, объявленных ключевым словом let, является блок, в котором они объявлены, и все его подблоки. В этом работа директива let схожа с работой директивы var. Основная разница заключается в том, что областью видимости переменной, объявленной директивой var, является вся функция, в которой она объявлена

     ```js
     function varTest() {
       var x = 1;
       if (true) {
         var x = 2; // та же переменная!
         console.log(x); // 2
       }
       console.log(x); // 2
     }

     function letTest() {
       let x = 1;
       if (true) {
         let x = 2; // другая переменная
         console.log(x); // 2
       }
       console.log(x); // 1
     }
     ```

     В стандарте ECMAScript 2015 переменные, объявленные директивой let, переносятся в начало блока. Но если вы сошлётесь в блоке на переменную, до того как она объявлена директивой let, то это приведёт к выбросу исключения ReferenceError, потому что переменная находится во "временной мёртвой зоне" с начала блока и до места её объявления. (В отличии от переменной, объявленной через var, которая просто будет содержать значение undefined)

     ```js
     function do_something() {
       console.log(bar); // undefined
       console.log(foo); // ReferenceError: foo is not defined
       var bar = 1;
       let foo = 2;
     }
     ```

  2. **Повторное объявление**
     Повторное объявление той же переменной в том же блоке или функции приведёт к выбросу исключения `SyntaxError`.

     ```js
     if (x) {
       let foo;
       let foo; // SyntaxError thrown.
     }
     ```

  3. **Поднятие (hoisting) без инициализации:**
     Переменные "поднимаются", но доступ к ним до объявления вызывает ошибку (`ReferenceError`).
  4. **Можно менять значение:**
     Значение переменной, объявленной через `let`, можно изменять.

- **Пример:**

```javascript
let x = 10; // Присваиваем значение

if (true) {
  let y = 20; // доступна только внутри блока
  let x = 50; // Присваеваем новое значение?
  console.log(y); // 20
  console.log(x); // 50
}

console.log(y); // Ошибка: y не определена
console.log(x); // 10
```

### **3. `const` (для неизменяемых переменных)**

- **Особенности:**
  1. **Блочная область видимости:**  
     Как и `let`, переменные `const` доступны только внутри блока, где они объявлены.
  2. **Нельзя переназначать значение:**  
     После присвоения значения переменной `const` его нельзя изменить.
  3. **Объекты и массивы:**  
     Структуры данных, объявленные через `const`, можно изменять внутри (например, добавлять элементы в массив), но нельзя переназначать переменную.
- **Пример:**

```javascript
const z = 30;
z = 40; // Ошибка: нельзя переназначить значение

const arr = [1, 2, 3];
arr.push(4); // Это допустимо
console.log(arr); // [1, 2, 3, 4]
```

### **Рекомендации**

- Используйте **`let`** для переменных, значение которых может изменяться.
- Используйте **`const`** для значений, которые не должны изменяться после их определения.
- Избегайте использования **`var`**, чтобы избежать возможных ошибок и путаницы.

**Пример правильного использования:**

```javascript
const pi = 3.14159; // Константа
let radius = 5; // Переменная, которую можно изменить

let area = pi * radius ** 2;
console.log('Площадь круга:', area);
```

---
