# **1.2.4 Область видимости и Hoisting**

> [Index](./0%20Index.md)

## **Область видимости (Scope)**

**Область видимости** — это контекст, в котором определены переменные, функции и объекты. Она определяет, откуда переменные доступны и управляет их временем жизни. В JavaScript область видимости играет ключевую роль в организации и работе кода.

---

### **Типы областей видимости в JavaScript**

1. **Глобальная область видимости (Global Scope)**

   - Все переменные и функции, объявленные вне функций и блоков, принадлежат глобальной области.
   - Они доступны из любого места в коде.

   **Пример:**

   ```javascript
   let globalVar = 'Я глобальная переменная';

   function printGlobal() {
     console.log(globalVar); // Доступна
   }

   printGlobal();
   console.log(globalVar); // Доступна
   ```

---

2. **Функциональная область видимости (Function Scope)**

   - Переменные, объявленные с помощью `var`, `let` или `const` внутри функции, доступны только внутри этой функции.
   - Это изолированная область, не доступная извне.

   **Пример:**

   ```javascript
   function example() {
     let localVar = 'Я локальная переменная';
     console.log(localVar); // Доступна здесь
   }

   example();
   // console.log(localVar); // Ошибка: localVar не определена
   ```

---

3. **Блочная область видимости (Block Scope)**

   - Переменные, объявленные с помощью `let` и `const`, существуют только внутри блока `{ ... }`.
   - Это более строгая область видимости, чем у `var`.

   **Пример:**

   ```javascript
   if (true) {
     let blockVar = 'Я в блоке';
     console.log(blockVar); // Доступна
   }

   // console.log(blockVar); // Ошибка: blockVar не определена
   ```

   Переменные, объявленные с помощью `var`, игнорируют блочную область:

   ```javascript
   if (true) {
     var blockIgnored = 'Я игнорирую блок';
   }

   console.log(blockIgnored); // Доступна
   ```

---

4. **Лексическая область видимости (Lexical Scope)**

   - Область видимости определяется местоположением функции в коде.
   - Функция имеет доступ к переменным, объявленным в области, в которой она была определена, даже если вызывается из другой области.

   **Пример:**

   ```javascript
   function outer() {
     let outerVar = 'Я снаружи';

     function inner() {
       console.log(outerVar); // Доступна
     }

     inner();
   }

   outer();
   ```

---

5. **Область видимости модуля (Module Scope)**

   - В модулях JavaScript (`import/export`) каждое подключаемое или экспортируемое значение имеет свою область видимости.
   - Переменные модуля недоступны глобально.

   **Пример:**

   ```javascript
   // module.js
   const moduleVar = 'Я внутри модуля';
   export default moduleVar;

   // main.js
   import moduleVar from './module.js';
   console.log(moduleVar); // "Я внутри модуля"
   ```

---

### **Hoisting (Поднятие)**

В JavaScript переменные и функции поднимаются (hoisted) в начало своей области видимости. Это значит, что они могут быть использованы до их объявления, но с разными особенностями для `var`, `let`, `const` и функций:

- **`var`** поднимается и инициализируется со значением `undefined`.
- **`let` и `const`** поднимаются, но недоступны до фактической инициализации (временная мёртвая зона).
- **Функции** поднимаются целиком, включая их тело.

**Пример:**

```javascript
console.log(a); // undefined
var a = 5;

console.log(b); // Ошибка: Cannot access 'b' before initialization
let b = 10;

console.log(c); // Ошибка: Cannot access 'c' before initialization
const c = 15;

foo(); // Работает
function foo() {
  console.log('Функция поднята!');
}
```

---

### **Замыкания и область видимости**

Замыкание (closure) — это функция, которая запоминает область видимости, в которой была создана, даже после того, как эта область вышла из выполнения.

**Пример:**

```javascript
function outer() {
  let count = 0;

  return function inner() {
    count++;
    console.log(count);
  };
}

const counter = outer();
counter(); // 1
counter(); // 2
```

Функция `inner` запоминает значение переменной `count`, даже когда `outer` завершила выполнение.

---

### **Практическое использование областей видимости**

1. **Избегайте глобальных переменных** — это делает код менее предсказуемым. Используйте модули или функции для ограничения областей видимости.
2. **Понимайте лексическую область видимости** — она помогает писать понятный код, избегая конфликтов переменных.
3. **Не забывайте о замыканиях** — они мощный инструмент, но их неправильное использование может привести к утечкам памяти.

Область видимости — основа понимания JavaScript, и знание её работы поможет вам избежать многих ошибок и создавать более понятный и поддерживаемый код.

## **Hoisting**

**Hoisting** (поднятие) — это механизм JavaScript, при котором объявления переменных, функций или классов перемещаются в верхнюю часть их области видимости **во время компиляции**, до выполнения кода. Это позволяет использовать переменные или функции до их фактического объявления в коде.

---

### **Как работает Hoisting?**

- **Переменные, объявленные через `var`, `let` и `const`**, а также **функции и классы** поднимаются, но обрабатываются по-разному.
- `Hoisting` касается **только объявления**, но не инициализации. То есть, значение переменной не поднимается — только её имя.

---

### **Hoisting переменных**

#### **1. Переменные, объявленные с помощью `var`**

- Объявление переменной поднимается, но её значение становится `undefined`, пока выполнение не дойдёт до строки с инициализацией.

```javascript
console.log(a); // undefined
var a = 10;
console.log(a); // 10
```

Этот код интерпретируется так:

```javascript
var a;
console.log(a); // undefined
a = 10;
console.log(a); // 10
```

---

#### **2. Переменные, объявленные с помощью `let` и `const`**

- Они также поднимаются, но находятся в **"временной мёртвой зоне" (temporal dead zone)** с момента начала области видимости до строки с объявлением.

```javascript
console.log(b); // Ошибка: Cannot access 'b' before initialization
let b = 20;
```

```javascript
console.log(c); // Ошибка: Cannot access 'c' before initialization
const c = 30;
```

Объяснение:

- Переменные `let` и `const` существуют в области видимости, но недоступны до их фактического объявления.

---

### **Hoisting функций**

#### **1. Функции, объявленные через `function declaration`**

- Полностью поднимаются вместе с телом функции, поэтому их можно вызывать до объявления.

```javascript
console.log(sum(5, 10)); // 15

function sum(a, b) {
  return a + b;
}
```

Этот код интерпретируется так:

```javascript
function sum(a, b) {
  return a + b;
}
console.log(sum(5, 10)); // 15
```

---

#### **2. Функции, объявленные через `function expression`**

- Hoisting поднимает только объявление переменной, а не функцию. Поэтому доступ к функции до её объявления вызывает ошибку.

```javascript
console.log(multiply(5, 10)); // Ошибка: multiply is not a function

var multiply = function (a, b) {
  return a * b;
};
```

Этот код интерпретируется так:

```javascript
var multiply;
console.log(multiply(5, 10)); // Ошибка: multiply is not a function
multiply = function (a, b) {
  return a * b;
};
```

---

#### **3. Стрелочные функции (arrow functions)**

- Работают аналогично `function expression`. Только объявление переменной поднимается.

```javascript
console.log(divide(10, 2)); // Ошибка: Cannot access 'divide' before initialization

let divide = (a, b) => a / b;
```

---

### **Hoisting классов**

- Классы поднимаются, но остаются в **"временной мёртвой зоне"**, подобно `let` и `const`.

```javascript
const user = new User(); // Ошибка: Cannot access 'User' before initialization

class User {
  constructor(name) {
    this.name = name;
  }
}
```

Объяснение:

- Класс объявляется, но его нельзя использовать до строки, где он фактически определён.

---

### **Как избежать путаницы с Hoisting?**

1. **Соблюдайте порядок кода.**
   - Всегда объявляйте переменные и функции перед их использованием.
2. **Используйте `let` и `const`.**
   - Они делают поведение более предсказуемым.
3. **Проверяйте код линтерами.**
   - Например, ESLint может предупреждать о возможных проблемах с `hoisting`.

---

### **Пример с объяснением**

Рассмотрим сложный пример:

```javascript
console.log(a); // undefined
var a = 5;

function greet() {
  console.log(b); // undefined
  var b = 10;
  console.log(b); // 10
}
greet();

console.log(c); // Ошибка: Cannot access 'c' before initialization
let c = 15;
```

**Как это интерпретируется:**

1. Объявление `var a` поднимается, но значение инициализируется позже:

   ```javascript
   var a; // Hoisting
   console.log(a); // undefined
   a = 5;
   ```

2. В функции `greet` переменная `b` поднимается только в её локальной области:

   ```javascript
   function greet() {
     var b; // Hoisting
     console.log(b); // undefined
     b = 10;
     console.log(b); // 10
   }
   ```

3. Переменная `c` объявлена через `let` и находится в "мёртвой зоне" до её инициализации.

---

### **Вывод**

`Hoisting` — это важная концепция, которую необходимо понимать для правильного написания JavaScript-кода. Используйте `let` и `const`, чтобы избежать неожиданных ошибок, и старайтесь писать код, следуя линейной логике.
