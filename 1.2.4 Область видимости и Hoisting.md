# **1.2.4 Область видимости и Hoisting**

> [Index](./0%20Index.md)

## **Область видимости (Scope)**

**Область видимости** — это контекст, в котором определены переменные, функции и объекты. Она определяет, откуда переменные доступны и управляет их временем жизни. В JavaScript область видимости играет ключевую роль в организации и работе кода.

В JavaScript контекст (context) и область видимости (scope) — это разные концепции, которые важно понимать для работы с кодом.

---

### **Типы областей видимости в JavaScript**

1. **Глобальная область видимости (Global Scope)**

    - Все переменные и функции, объявленные вне функций и блоков, принадлежат глобальной области.
    - Они доступны из любого места в коде.

    **Пример:**

    ```javascript
    let globalVar = 'Я глобальная переменная';

    function printGlobal() {
        console.log(globalVar); // Доступна
    }

    printGlobal();
    console.log(globalVar); // Доступна
    ```

---

2. **Функциональная область видимости (Function Scope)**

    - Переменные, объявленные с помощью `var`, `let` или `const` внутри функции, доступны только внутри этой функции.
    - Это изолированная область, не доступная извне.

    **Пример:**

    ```javascript
    function example() {
        let localVar = 'Я локальная переменная';
        console.log(localVar); // Доступна здесь
    }

    example();
    // console.log(localVar); // Ошибка: localVar не определена
    ```

---

3. **Блочная область видимости (Block Scope)**

    - Переменные, объявленные с помощью `let` и `const`, существуют только внутри блока `{ ... }`. Таким образом, переменные `let` и `const` не будут доступны за пределами блока, и произойдет ошибка **ReferenceError**.
    - Это более строгая область видимости, чем у `var`.

    **Пример:**

    ```javascript
    if (true) {
        let blockVar = 'Я в блоке';
        console.log(blockVar); // Доступна
    }

    // console.log(blockVar); // Ошибка: blockVar не определена
    ```

    ```js
    {
        let foo = function () {
            return 'Внутри блока';
        };
    }

    console.log(foo()); // ReferenceError: foo is not defined
    ```

    Следует подчеркнуть, что использование `var` может привести к неожиданному поведению, особенно в крупных проектах. Переменные, объявленные с помощью `var`, игнорируют блочную область:

    ```js
    {
        var foo = function () {
            return 'Внутри блока';
        };
    }

    console.log(foo()); // 'Внутри блока'
    ```

    ```javascript
    if (true) {
        var blockIgnored = 'Я игнорирую блок';
    }

    console.log(blockIgnored); // Доступна
    ```

---

4. **Лексическая область видимости (Lexical Scope)**

    - Область видимости определяется местоположением функции в коде.
    - Функция имеет доступ к переменным, объявленным в области, в которой она была определена, даже если вызывается из другой области. Это свойство особенно важно для работы с замыканиями, поскольку они позволяют функциям сохранять доступ к своей лексической области видимости, даже когда вызываются за её пределами.

    **Пример:**

    ```javascript
    let globalVar = 'Глобальная';

    function outer() {
        let outerVar = 'Я снаружи';

        function inner() {
            var innerVar = 'Я внутри';
            console.log(globalVar); // Доступна
            console.log(innerVar); // Доступна
            console.log(outerVar); // Доступна
        }

        inner();
        console.log(innerVar); // ReferenceError: outerVar is not defined
    }

    outer();
    console.log(innerVar); // ReferenceError: outerVar is not defined
    console.log(outerVar); // ReferenceError: outerVar is not defined
    ```

    > [!TIP]
    >
    > Преимущества лексической области видимости
    > Простота и предсказуемость: Код легче понять и предсказать его поведение.
    >
    > Инкапсуляция: Переменные и функции могут быть скрыты в локальных областях видимости, что снижает риск конфликтов имён и улучшает безопасность кода.
    >
    > Мощные замыкания: Позволяют создавать функции с устойчивыми состояниями, что полезно для работы с асинхронными операциями и функциями обратного вызова.

---

5. **Область видимости модуля (Module Scope)**

    Область видимости модуля связана с использованием JavaScript-модулей (`ESModules`), где каждая единица кода имеет свою локальную область видимости. Это позволяет изолировать переменные и функции, предотвращая их доступ извне модуля, если они не экспортированы.

    **Пример с использованием `ESModules`:**

    ```javascript
    // module.js
    const privateVar = 'Приватная переменная';
    export const publicVar = 'Публичная переменная';

    export function getPublicVar() {
        return publicVar;
    }

    // main.js
    import { publicVar, getPublicVar } from './module.js';
    console.log(publicVar); // 'Публичная переменная'
    console.log(getPublicVar()); // 'Публичная переменная'
    // console.log(privateVar); // Ошибка: privateVar не определена
    ```

    Для сравнения, в старом стандарте **CommonJS** используется другой подход к организации модульной области видимости. Например:

    ```javascript
    // module.js
    const privateVar = 'Приватная переменная';
    const publicVar = 'Публичная переменная';

    module.exports = {
        publicVar,
        getPublicVar: () => publicVar,
    };

    // main.js
    const { publicVar, getPublicVar } = require('./module.js');
    console.log(publicVar); // 'Публичная переменная'
    console.log(getPublicVar()); // 'Публичная переменная'
    ```

    Таким образом, использование модульной области видимости помогает поддерживать чистоту и модульность кода, что важно для масштабируемых приложений.

    - В модулях JavaScript (`import/export`) каждое подключаемое или экспортируемое значение имеет свою область видимости.
    - Переменные модуля недоступны глобально.

    **Пример:**

    ```javascript
    // module.js
    const moduleVar = 'Я внутри модуля';
    export default moduleVar;

    // main.js
    import moduleVar from './module.js';
    console.log(moduleVar); // "Я внутри модуля"
    ```

---

### **Замыкания и область видимости**

Замыкание (**closure**) — это функция, которая запоминает свою лексическую область видимости, даже если она вызывается за её пределами. Замыкания позволяют функциям сохранять доступ к переменным и функциям, определённым в их области видимости, даже после того, как внешняя функция завершила своё выполнение.

**Пример:**

```javascript
function outer() {
    let count = 0;

    return function inner() {
        count++;
        console.log(count);
    };
}

const counter = outer();
counter(); // 1
counter(); // 2
```

Функция `inner` запоминает значение переменной `count`, даже когда `outer` завершила выполнение. Это свойство замыканий делает их полезными для создания приватных данных или инкапсуляции логики, позволяя функции сохранять состояние между вызовами.

---

### **Практическое использование областей видимости**

1. **Избегайте глобальных переменных** — это делает код менее предсказуемым. Используйте модули или функции для ограничения областей видимости.
2. **Понимайте лексическую область видимости** — она помогает писать понятный код, избегая конфликтов переменных.
3. **Не забывайте о замыканиях** — они мощный инструмент, но их неправильное использование может привести к утечкам памяти.

> [!NOTE]
> Область видимости — основа понимания JavaScript, и знание её работы поможет вам избежать многих ошибок и создавать более понятный и поддерживаемый код.

### Задачи

#### Задача 1:

Глобальная и локальная область видимости
Что будет выведено в консоль? Объясните почему. Рассмотрите сценарий, где в одной области используется несколько переменных с одинаковыми именами, чтобы понять, как работает механизм поиска переменных в стеке областей видимости.
Что будет выведено в консоль? Объясните почему.

```js
let x = 10;

function example() {
    let x = 20;
    console.log(x);
}

example();
console.log(x);
```

#### Задача 2:

Область видимости в цикле
Что будет выведено в консоль?

```js
for (let i = 0; i < 3; i++) {
    console.log(i);
}

console.log(i); // ?
```

#### Задача 3:

Блоковая область видимости
Определите, что будет выведено в консоль:

```js
{
    let a = 5;
    const b = 10;
    var c = 15;
}

console.log(typeof a);
console.log(typeof b);
console.log(typeof c);
```

#### Задача 4:

Область видимости переменной `var`
Какой результат будет у этого кода?

```js
function testVarScope() {
    if (true) {
        var x = 5;
    }
    console.log(x);
}

testVarScope();
```

#### Задача 5:

Вложенные функции и области видимости
Какой результат будет у этого кода?

```js
function outer() {
    let outerVar = 'Я снаружи';

    function inner() {
        let innerVar = 'Я внутри';
        console.log(outerVar); // ?
        console.log(innerVar); // ?
    }

    inner();
    console.log(innerVar); // ?
}

outer();
```

## **Hoisting (поднятие)**

**Hoisting** (поднятие) — это механизм JavaScript, при котором объявления переменных, функций или классов перемещаются в верхнюю часть их области видимости **во время компиляции** (до выполнения кода). Это позволяет использовать переменные или функции до их фактического объявления в коде.

### **Типы hoisting в JavaScript**

В JavaScript переменные и функции поднимаются (`hoisted`) в начало своей области видимости. Этот процесс можно представить визуально для лучшего понимания.

#### **Пример с псевдокодом**

```plaintext
1. Объявления переменных и функций идентифицируются на этапе компиляции.
2. Все объявления перемещаются вверх текущей области видимости.
3. Инициализация остаётся на месте.
```

#### **Графическая схема**

1. Код до обработки hoisting:

```javascript
console.log(a);
var a = 5;
test();
function test() {
    console.log(b);
    let b = 10;
}
```

2.  Как это интерпретируется движком JavaScript:

    1. Объявления переменных и функций поднимаются:

    ```js
    var a; // Получает значение undefined
    function test() {
        let b; // Переменная b поднимается, но остаётся в "временной мёртвой зоне"
    }
    ```

    2. Инициализация переменных и вызов функций остаются на своих местах:

    ```js
    console.log(a); // undefined (a поднимается, но ещё не инициализирована)
    a = 5; // Инициализация переменной a
    test(); // Вызов функции test
    ```

    3. Тело функции `test`:

    ```js
    function test() {
        console.log(b); // Ошибка: Cannot access 'b' before initialization
        let b = 10; // Инициализация переменной b
    }
    ```

    **Полная интерпретация**
    Объединив шаги выше, получим:

    ```javascript
    var a; // Переменная a поднимается

    function test() {
        // Функция test поднимается целиком
        let b; // Переменная b поднимается, но остаётся в "временной мёртвой зоне"
        console.log(b); // Ошибка: Cannot access 'b' before initialization
        b = 10; // Инициализация переменной b
    }

    console.log(a); // undefined
    a = 5; // Инициализация переменной a
    test(); // Вызов функции test
    ```

    **Объяснение:**

    4. Поднятие переменной `a`:

    Переменная `a` объявляется и поднимается в верхнюю часть области видимости. На момент вызова `console.log(a)`, переменная уже существует, но ещё не инициализирована, поэтому выводится `undefined`.

    5. Поднятие функции `test`:

    Функция `test` объявляется и поднимается целиком, включая её тело. Это позволяет вызывать функцию `test` до её фактического определения в коде.

    6. Вызов `test`:

    Внутри функции `test` переменная `b`, объявленная с помощью `let`, поднимается, но остаётся в **"временной мёртвой зоне"** до строки с инициализацией. Поэтому при попытке доступа к `b` до её объявления возникает ошибка **Cannot access 'b' before initialization.**

### **Hoisting переменных и функций**

Переменные и функции поднимаются по-разному:

-   **`var`**: Переменная поднимается и инициализируется со значением `undefined`.
-   **`let`** и **`const`**: Переменные поднимаются, но недоступны до фактической инициализации (временная мёртвая зона).
-   **Функции** поднимаются целиком, включая их тело.

**Пример:**

```javascript
console.log(a); // undefined
var a = 5;

console.log(b); // Ошибка: Cannot access 'b' before initialization
let b = 10;

console.log(c); // Ошибка: Cannot access 'c' before initialization
const c = 15;

foo(); // Работает
function foo() {
    console.log('Функция поднята!');
}
```

---

### **Как работает Hoisting?**

Hoisting (поднятие) может приводить к непредвиденным последствиям при одновременном использовании функций и переменных с одинаковыми именами.

**Например:**

```javascript
console.log(test); // Вывод: ƒ test() {...}
var test = 10;
function test() {
    console.log('Функция test');
}
console.log(test); // Вывод: 10
```

В этом случае объявление функции `test` поднимается выше, чем объявление переменной `test`. Однако при выполнении кода переменной присваивается значение `10`, что приводит к её переопределению и невозможности вызова функции через имя `test`.

> [!NOTE]
>
> -   Переменные, объявленные через `var`, `let` и `const`, а также функции и классы поднимаются, но обрабатываются по-разному.
> -   `Hoisting` касается **только объявления**, но не инициализации. То есть, значение переменной не поднимается — только её имя.

---

### **Hoisting переменных**

#### **1. Переменные, объявленные с помощью `var`**

-   Объявление переменной поднимается, но её значение становится `undefined`, пока выполнение не дойдёт до строки с инициализацией.

```javascript
console.log(a); // undefined
var a = 10;
console.log(a); // 10
```

Этот код интерпретируется так:

```javascript
var a;
console.log(a); // undefined
a = 10;
console.log(a); // 10
```

---

#### **2. Переменные, объявленные с помощью `let` и `const`**

-   Они также поднимаются, но находятся в **"временной мёртвой зоне" (temporal dead zone)** до строки с объявлением.

```javascript
console.log(b); // Ошибка: Cannot access 'b' before initialization
let b = 20;
```

```javascript
console.log(c); // Ошибка: Cannot access 'c' before initialization
const c = 30;
```

---

### **Hoisting функций**

#### **1. Функции, объявленные через `function declaration`**

-   Полностью поднимаются вместе с телом функции, поэтому их можно вызывать до объявления.

```javascript
console.log(sum(5, 10)); // 15

function sum(a, b) {
    return a + b;
}
```

Этот код интерпретируется так:

```javascript
function sum(a, b) {
    return a + b;
}
console.log(sum(5, 10)); // 15
```

---

#### **2. Функции, объявленные через `function expression`**

-   Hoisting поднимает только объявление переменной, а не функцию. Поэтому доступ к функции до её объявления вызывает ошибку.

```javascript
console.log(multiply(5, 10)); // Ошибка: multiply is not a function

var multiply = function (a, b) {
    return a * b;
};
```

Этот код интерпретируется так:

```javascript
var multiply;
console.log(multiply(5, 10)); // Ошибка: multiply is not a function
multiply = function (a, b) {
    return a * b;
};
```

---

#### **3. Стрелочные функции (arrow functions)**

-   Работают аналогично `function expression`. Только объявление переменной поднимается.

```javascript
console.log(divide(10, 2)); // Ошибка: Cannot access 'divide' before initialization

let divide = (a, b) => a / b;
```

---

### **Hoisting классов**

-   Классы поднимаются, но остаются в **"временной мёртвой зоне"**, подобно `let` и `const`.

```javascript
const user = new User(); // Ошибка: Cannot access 'User' before initialization

class User {
    constructor(name) {
        this.name = name;
    }
}
```

**Объяснение:**

Класс объявляется, но его нельзя использовать до строки, где он фактически определён. Это поведение связано с особенностями объявления классов через class в ES6.

---

### **Как избежать путаницы с Hoisting?**

1. **Соблюдайте порядок кода.**
    - Объявляйте переменные и функции перед их использованием.
2. **Используйте `let` и `const`**
    - Они делают поведение более предсказуемым.
3. **Проверяйте код линтерами.**
    - Например, ESLint может предупреждать о возможных проблемах с `hoisting`.

---

### **Пример с объяснением**

Рассмотрим сложный пример:

```javascript
console.log(a); // undefined
var a = 5;

function greet() {
    console.log(b); // undefined
    var b = 10;
    console.log(b); // 10
}
greet();

console.log(c); // Ошибка: Cannot access 'c' before initialization
let c = 15;
```

**Как это интерпретируется:**

1. Объявление `var a` поднимается, но значение инициализируется позже:

    ```javascript
    var a; // Hoisting
    console.log(a); // undefined
    a = 5;
    ```

2. В функции `greet` переменная `b` поднимается только в её локальной области:

    ```javascript
    function greet() {
        var b; // Hoisting
        console.log(b); // undefined
        b = 10;
        console.log(b); // 10
    }
    ```

3. Переменная `c` объявлена через `let` и находится в "мёртвой зоне" до её инициализации.

---

### **Вывод**

`Hoisting` — это важная концепция, которую необходимо понимать для правильного написания JavaScript-кода. Используйте `let` и `const`, чтобы избежать неожиданных ошибок, и старайтесь писать код, следуя линейной логике.

### Задачи

#### Задача 1:

Поднятие переменных `var`
Что выведет этот код?

```js
console.log(a);
var a = 5;
```

#### Задача 2:

Поднятие функции
Объясните, что произойдёт:

```js
hello();

function hello() {
    console.log('Привет, мир!');
}
```

#### Задача 3:

Поднятие переменной `let`
Чем отличается выполнение этого кода от `var`?

```js
console.log(b);
let b = 10;
```

#### Задача 4:

Поднятие объявлений и инициализации
Что будет выведено?

```js
console.log(x);
var x = 5;
x = 10;
console.log(x);
```

#### Задача 5:

Поднятие функций и выражений
Какая ошибка произойдёт? Почему?

```js
greet();

var greet = function () {
    console.log('Привет!');
};
```
